!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.7	//
ALT	kbd.h	11;"	d
AS	Makefile	/^AS = $(TOOLPREFIX)gas$/;"	m
ASFLAGS	Makefile	/^ASFLAGS = -m32$/;"	m
ASSERT	lapic.c	22;"	d	file:
Align	umalloc.c	/^typedef long Align;$/;"	t	file:
BACK	sh.c	12;"	d	file:
BACKSPACE	console.c	17;"	d	file:
BBLOCK	fs.h	47;"	d
BCAST	lapic.c	24;"	d	file:
BPB	fs.h	44;"	d
BSIZE	fs.h	8;"	d
B_BUSY	buf.h	10;"	d
B_DIRTY	buf.h	12;"	d
B_VALID	buf.h	11;"	d
C	console.c	194;"	d	file:
C	kbd.h	32;"	d
C	kernel.asm	/^#define C(x)  ((x)-'@')  \/\/ Control-x$/;"	d
CAPSLOCK	kbd.h	13;"	d
CC	Makefile	/^CC = $(TOOLPREFIX)gcc-3.4$/;"	m
CFLAGS	Makefile	/^CFLAGS = -fno-builtin -O2 -Wall -MD -ggdb -m32$/;"	m
CLEAR_PAGE_RESERVED	pmap.h	56;"	d
CONSOLE	dev.h	8;"	d
CR0_AM	mmu.h	25;"	d
CR0_CD	mmu.h	27;"	d
CR0_EM	mmu.h	20;"	d
CR0_ET	mmu.h	22;"	d
CR0_MP	mmu.h	19;"	d
CR0_NE	mmu.h	23;"	d
CR0_NW	mmu.h	26;"	d
CR0_PE	mmu.h	18;"	d
CR0_PG	mmu.h	28;"	d
CR0_TS	mmu.h	21;"	d
CR0_WP	mmu.h	24;"	d
CR4_DE	mmu.h	33;"	d
CR4_MCE	mmu.h	31;"	d
CR4_PCE	mmu.h	30;"	d
CR4_PSE	mmu.h	32;"	d
CR4_PVI	mmu.h	35;"	d
CR4_TSD	mmu.h	34;"	d
CR4_VME	mmu.h	36;"	d
CRTPORT	console.c	15;"	d	file:
CTL	kbd.h	10;"	d
DELIVS	lapic.c	21;"	d	file:
DIRSIZ	fs.h	50;"	d
DPL_USER	mmu.h	126;"	d
Disassembly	bootblock.asm	/^Disassembly of section .text:$/;"	l
Disassembly	cat.asm	/^Disassembly of section .text:$/;"	l
Disassembly	echo.asm	/^Disassembly of section .text:$/;"	l
Disassembly	forktest.asm	/^Disassembly of section .text:$/;"	l
Disassembly	grep.asm	/^Disassembly of section .text:$/;"	l
Disassembly	init.asm	/^Disassembly of section .text:$/;"	l
Disassembly	kernel.asm	/^Disassembly of section .text:$/;"	l
Disassembly	kill.asm	/^Disassembly of section .text:$/;"	l
Disassembly	ln.asm	/^Disassembly of section .text:$/;"	l
Disassembly	ls.asm	/^Disassembly of section .text:$/;"	l
Disassembly	mkdir.asm	/^Disassembly of section .text:$/;"	l
Disassembly	rm.asm	/^Disassembly of section .text:$/;"	l
Disassembly	sh.asm	/^Disassembly of section .text:$/;"	l
Disassembly	usertests.asm	/^Disassembly of section .text:$/;"	l
Disassembly	wc.asm	/^Disassembly of section .text:$/;"	l
Disassembly	zombie.asm	/^Disassembly of section .text:$/;"	l
E0ESC	kbd.h	17;"	d
E820MAX	pmap.h	10;"	d
E820_ARM	pmap.h	11;"	d
E820_ARR	pmap.h	12;"	d
ELF_MAGIC	elf.h	3;"	d
ELF_PROG_FLAG_EXEC	elf.h	40;"	d
ELF_PROG_FLAG_READ	elf.h	42;"	d
ELF_PROG_FLAG_WRITE	elf.h	41;"	d
ELF_PROG_LOAD	elf.h	37;"	d
EMBRYO	proc.h	/^enum proc_state { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:proc_state
ENABLE	lapic.c	16;"	d	file:
EOI	lapic.c	14;"	d	file:
ERROR	lapic.c	32;"	d	file:
ESR	lapic.c	17;"	d	file:
EXEC	sh.c	8;"	d	file:
E_MAP_EXIST	errorno.h	6;"	d
E_NOT_AT_PGBOUND	errorno.h	5;"	d
E_NO_MEM	errorno.h	7;"	d
FD_CLOSED	file.h	/^  enum { FD_CLOSED, FD_NONE, FD_PIPE, FD_INODE } type;$/;"	e	enum:file::__anon4
FD_INODE	file.h	/^  enum { FD_CLOSED, FD_NONE, FD_PIPE, FD_INODE } type;$/;"	e	enum:file::__anon4
FD_NONE	file.h	/^  enum { FD_CLOSED, FD_NONE, FD_PIPE, FD_INODE } type;$/;"	e	enum:file::__anon4
FD_PIPE	file.h	/^  enum { FD_CLOSED, FD_NONE, FD_PIPE, FD_INODE } type;$/;"	e	enum:file::__anon4
FILES	Makefile	/^FILES = $(shell grep -v '^\\#' runoff.list)$/;"	m
FL_AC	mmu.h	90;"	d
FL_AF	mmu.h	75;"	d
FL_CF	mmu.h	73;"	d
FL_DF	mmu.h	80;"	d
FL_ID	mmu.h	93;"	d
FL_IF	mmu.h	79;"	d
FL_IOPL_0	mmu.h	83;"	d
FL_IOPL_1	mmu.h	84;"	d
FL_IOPL_2	mmu.h	85;"	d
FL_IOPL_3	mmu.h	86;"	d
FL_IOPL_MASK	mmu.h	82;"	d
FL_NT	mmu.h	87;"	d
FL_OF	mmu.h	81;"	d
FL_PF	mmu.h	74;"	d
FL_RF	mmu.h	88;"	d
FL_SF	mmu.h	77;"	d
FL_TF	mmu.h	78;"	d
FL_VIF	mmu.h	91;"	d
FL_VIP	mmu.h	92;"	d
FL_VM	mmu.h	89;"	d
FL_ZF	mmu.h	76;"	d
FreeAreaSize	buddy.c	/^const int FreeAreaSize[MAX_ORDER] = {1,2,4,8,16,32,64,128,256,512,1024};$/;"	v
Header	umalloc.c	/^typedef union header Header;$/;"	t	typeref:union:header	file:
IBLOCK	fs.h	41;"	d
ICRHI	lapic.c	25;"	d	file:
ICRLO	lapic.c	18;"	d	file:
ID	lapic.c	11;"	d	file:
IDE_BSY	ide.c	13;"	d	file:
IDE_CMD_READ	ide.c	18;"	d	file:
IDE_CMD_WRITE	ide.c	19;"	d	file:
IDE_DF	ide.c	15;"	d	file:
IDE_DRDY	ide.c	14;"	d	file:
IDE_ERR	ide.c	16;"	d	file:
INDIRECT	fs.h	19;"	d
INIT	lapic.c	19;"	d	file:
INPUT_BUF	console.c	185;"	d	file:
INT_ACTIVELOW	ioapic.c	22;"	d	file:
INT_DISABLED	ioapic.c	20;"	d	file:
INT_LEVEL	ioapic.c	21;"	d	file:
INT_LOGICAL	ioapic.c	23;"	d	file:
IOAPIC	ioapic.c	9;"	d	file:
IO_PIC1	picirq.c	8;"	d	file:
IO_PIC2	picirq.c	9;"	d	file:
IO_RTC	lapic.c	133;"	d	file:
IO_TIMER1	timer.c	10;"	d	file:
IPB	fs.h	38;"	d
IRQ_ERROR	traps.h	35;"	d
IRQ_IDE	traps.h	34;"	d
IRQ_KBD	traps.h	33;"	d
IRQ_OFFSET	traps.h	30;"	d
IRQ_SLAVE	picirq.c	11;"	d	file:
IRQ_SPURIOUS	traps.h	36;"	d
IRQ_TIMER	traps.h	32;"	d
I_BUSY	fsvar.h	17;"	d
I_VALID	fsvar.h	18;"	d
JOS_INC_QUEUE_H	queue.h	36;"	d
KBDATAP	kbd.h	5;"	d
KBSTATP	kbd.h	3;"	d
KBS_DIB	kbd.h	4;"	d
KERNTOP	memlayout.h	3;"	d
KEY_DEL	kbd.h	29;"	d
KEY_DN	kbd.h	23;"	d
KEY_END	kbd.h	21;"	d
KEY_HOME	kbd.h	20;"	d
KEY_INS	kbd.h	28;"	d
KEY_LF	kbd.h	24;"	d
KEY_PGDN	kbd.h	27;"	d
KEY_PGUP	kbd.h	26;"	d
KEY_RT	kbd.h	25;"	d
KEY_UP	kbd.h	22;"	d
KSTACKSIZE	param.h	5;"	d
LD	Makefile	/^LD = $(TOOLPREFIX)ld$/;"	m
LEVEL	lapic.c	23;"	d	file:
LINT0	lapic.c	30;"	d	file:
LINT1	lapic.c	31;"	d	file:
LIST	sh.c	11;"	d	file:
LIST_EMPTY	queue.h	142;"	d
LIST_ENTRY	queue.h	129;"	d
LIST_FIRST	queue.h	147;"	d
LIST_FOREACH	queue.h	160;"	d
LIST_HEAD	queue.h	109;"	d
LIST_HEAD_INITIALIZER	queue.h	118;"	d
LIST_INIT	queue.h	168;"	d
LIST_INSERT_AFTER	queue.h	177;"	d
LIST_INSERT_BEFORE	queue.h	190;"	d
LIST_INSERT_HEAD	queue.h	201;"	d
LIST_NEXT	queue.h	153;"	d
LIST_REMOVE	queue.h	212;"	d
LPTPORT	console.c	16;"	d	file:
MASKED	lapic.c	33;"	d	file:
MAXARGS	sh.c	14;"	d	file:
MAXFILE	fs.h	21;"	d
MAX_ORDER	buddy.h	5;"	d
MPBOOT	mp.h	34;"	d
MPBUS	mp.h	50;"	d
MPIOAPIC	mp.h	51;"	d
MPIOINTR	mp.h	52;"	d
MPLINTR	mp.h	53;"	d
MPPROC	mp.h	49;"	d
NADDRS	fs.h	17;"	d
NBUF	param.h	9;"	d
NCPU	param.h	6;"	d
NDEV	param.h	11;"	d
NDIRECT	fs.h	18;"	d
NELEM	defs.h	150;"	d
NFILE	param.h	8;"	d
NINDIRECT	fs.h	20;"	d
NINODE	param.h	10;"	d
NO	kbd.h	7;"	d
NOFILE	param.h	7;"	d
NPROC	param.h	3;"	d
NSEGS	proc.h	10;"	d
NULL	pmap.h	7;"	d
NUMLOCK	kbd.h	14;"	d
OBJCOPY	Makefile	/^OBJCOPY = $(TOOLPREFIX)objcopy$/;"	m
OBJDUMP	Makefile	/^OBJDUMP = $(TOOLPREFIX)objdump$/;"	m
OBJS	Makefile	/^OBJS = \\$/;"	m
O_CREATE	fcntl.h	4;"	d
O_RDONLY	fcntl.h	1;"	d
O_RDWR	fcntl.h	3;"	d
O_WRONLY	fcntl.h	2;"	d
PAGE	param.h	4;"	d
PCINT	lapic.c	29;"	d	file:
PDX	mmu.h	52;"	d
PDXSHIFT	mmu.h	67;"	d
PERIODIC	lapic.c	28;"	d	file:
PGOFF	mmu.h	61;"	d
PG_dirty	pmap.h	18;"	d
PG_locked	pmap.h	17;"	d
PG_property	pmap.h	16;"	d
PG_reserved	pmap.h	15;"	d
PIPE	sh.c	10;"	d	file:
PIPESIZE	pipe.c	9;"	d	file:
PPN	mmu.h	55;"	d
PRINT	Makefile	/^PRINT = runoff.list $(FILES)$/;"	m
PTENTRY	mmu.h	69;"	d
PTE_A	mmu.h	12;"	d
PTE_ADDR	mmu.h	64;"	d
PTE_D	mmu.h	13;"	d
PTE_MBZ	mmu.h	15;"	d
PTE_P	mmu.h	7;"	d
PTE_PCD	mmu.h	11;"	d
PTE_PS	mmu.h	14;"	d
PTE_PWT	mmu.h	10;"	d
PTE_U	mmu.h	9;"	d
PTE_W	mmu.h	8;"	d
PTSIZE	mmu.h	70;"	d
PTX	mmu.h	58;"	d
PTXSHIFT	mmu.h	68;"	d
Page	pmap.h	/^struct Page {$/;"	s
REDIR	sh.c	9;"	d	file:
REG_ID	ioapic.c	11;"	d	file:
REG_TABLE	ioapic.c	13;"	d	file:
REG_VER	ioapic.c	12;"	d	file:
ROOTDEV	param.h	12;"	d
ROUNDDOWN	types.h	14;"	d
ROUNDUP	types.h	21;"	d
RUNNABLE	proc.h	/^enum proc_state { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:proc_state
RUNNING	proc.h	/^enum proc_state { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:proc_state
SCROLLLOCK	kbd.h	15;"	d
SECTSIZE	bootmain.c	12;"	d	file:
SEG	mmu.h	116;"	d
SEG16	mmu.h	121;"	d
SEG_ASM	asm.h	9;"	d
SEG_KCODE	proc.h	5;"	d
SEG_KDATA	proc.h	6;"	d
SEG_NULL	mmu.h	113;"	d
SEG_NULLASM	asm.h	5;"	d
SEG_TSS	proc.h	9;"	d
SEG_UCODE	proc.h	7;"	d
SEG_UDATA	proc.h	8;"	d
SETGATE	mmu.h	212;"	d
SET_PAGE_RESERVED	pmap.h	55;"	d
SHIFT	kbd.h	9;"	d
SLEEPING	proc.h	/^enum proc_state { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:proc_state
STARTUP	lapic.c	20;"	d	file:
STA_A	asm.h	19;"	d
STA_A	mmu.h	134;"	d
STA_C	asm.h	16;"	d
STA_C	mmu.h	131;"	d
STA_E	asm.h	15;"	d
STA_E	mmu.h	130;"	d
STA_R	asm.h	18;"	d
STA_R	mmu.h	133;"	d
STA_W	asm.h	17;"	d
STA_W	mmu.h	132;"	d
STA_X	asm.h	14;"	d
STA_X	mmu.h	129;"	d
STS_CG16	mmu.h	140;"	d
STS_CG32	mmu.h	146;"	d
STS_IG16	mmu.h	142;"	d
STS_IG32	mmu.h	147;"	d
STS_LDT	mmu.h	138;"	d
STS_T16A	mmu.h	137;"	d
STS_T16B	mmu.h	139;"	d
STS_T32A	mmu.h	144;"	d
STS_T32B	mmu.h	145;"	d
STS_TG	mmu.h	141;"	d
STS_TG16	mmu.h	143;"	d
STS_TG32	mmu.h	148;"	d
STUB	usys.S	/^#define STUB(name) \\$/;"	d
SVR	lapic.c	15;"	d	file:
SYS_chdir	syscall.h	17;"	d
SYS_close	syscall.h	8;"	d
SYS_dup	syscall.h	18;"	d
SYS_exec	syscall.h	10;"	d
SYS_exit	syscall.h	3;"	d
SYS_fork	syscall.h	2;"	d
SYS_fstat	syscall.h	14;"	d
SYS_getpid	syscall.h	19;"	d
SYS_kill	syscall.h	9;"	d
SYS_link	syscall.h	15;"	d
SYS_mkdir	syscall.h	16;"	d
SYS_mknod	syscall.h	12;"	d
SYS_open	syscall.h	11;"	d
SYS_pipe	syscall.h	5;"	d
SYS_read	syscall.h	7;"	d
SYS_sbrk	syscall.h	20;"	d
SYS_sleep	syscall.h	21;"	d
SYS_unlink	syscall.h	13;"	d
SYS_wait	syscall.h	4;"	d
SYS_write	syscall.h	6;"	d
TCCR	lapic.c	35;"	d	file:
TDCR	lapic.c	36;"	d	file:
TICR	lapic.c	34;"	d	file:
TIMER	lapic.c	26;"	d	file:
TIMER_16BIT	kernel.asm	/^#define TIMER_16BIT     0x30    \/\/ r\/w counter 16 bits, LSB first$/;"	d
TIMER_16BIT	timer.c	22;"	d	file:
TIMER_DIV	timer.c	17;"	d	file:
TIMER_FREQ	timer.c	16;"	d	file:
TIMER_MODE	timer.c	19;"	d	file:
TIMER_RATEGEN	kernel.asm	/^#define TIMER_RATEGEN   0x04    \/\/ mode 2, rate generator$/;"	d
TIMER_RATEGEN	timer.c	21;"	d	file:
TIMER_SEL0	timer.c	20;"	d	file:
TOOLPREFIX	Makefile	/^TOOLPREFIX = $/;"	m
TPR	lapic.c	13;"	d	file:
T_ALIGN	traps.h	21;"	d
T_BOUND	traps.h	9;"	d
T_BRKPT	traps.h	7;"	d
T_DBLFLT	traps.h	12;"	d
T_DEBUG	traps.h	5;"	d
T_DEFAULT	traps.h	28;"	d
T_DEV	fs.h	35;"	d
T_DEVICE	traps.h	11;"	d
T_DIR	fs.h	33;"	d
T_DIVIDE	traps.h	4;"	d
T_FILE	fs.h	34;"	d
T_FPERR	traps.h	20;"	d
T_GPFLT	traps.h	17;"	d
T_ILLOP	traps.h	10;"	d
T_MCHK	traps.h	22;"	d
T_NMI	traps.h	6;"	d
T_OFLOW	traps.h	8;"	d
T_PGFLT	traps.h	18;"	d
T_SEGNP	traps.h	15;"	d
T_SIMDERR	traps.h	23;"	d
T_STACK	traps.h	16;"	d
T_SYSCALL	traps.h	27;"	d
T_TSS	traps.h	14;"	d
ULIB	Makefile	/^ULIB = ulib.o usys.o printf.o umalloc.o$/;"	m
UNUSED	proc.h	/^enum proc_state { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:proc_state
UPROGS	Makefile	/^UPROGS=\\$/;"	m
UVPT	memlayout.h	9;"	d
VER	lapic.c	12;"	d	file:
VPT	memlayout.h	8;"	d
X1	lapic.c	27;"	d	file:
ZOMBIE	proc.h	/^enum proc_state { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:proc_state
_ASSERT_H_	assert.h	2;"	d
_ATOMIC_H_	atomic.h	2;"	d
_BUDDY_H_	buddy.h	2;"	d
_DEFS_H_	defs.h	2;"	d
_ERRORNO_H_	errorno.h	2;"	d
_MEMLAYOUT_H_	memlayout.h	2;"	d
_MMU_H_	mmu.h	2;"	d
_PARAM_H_	param.h	2;"	d
_PMAP_H_	pmap.h	2;"	d
_SPINLOCK_H_	spinlock.h	2;"	d
_TYPES_H_	types.h	2;"	d
_cat	cat.asm	/^_cat:     file format elf32-i386$/;"	l
_echo	echo.asm	/^_echo:     file format elf32-i386$/;"	l
_forktest	forktest.asm	/^_forktest:     file format elf32-i386$/;"	l
_getmeminfo	meminfo.S	/^_getmeminfo:$/;"	l
_grep	grep.asm	/^_grep:     file format elf32-i386$/;"	l
_init	init.asm	/^_init:     file format elf32-i386$/;"	l
_kill	kill.asm	/^_kill:     file format elf32-i386$/;"	l
_ln	ln.asm	/^_ln:     file format elf32-i386$/;"	l
_ls	ls.asm	/^_ls:     file format elf32-i386$/;"	l
_mkdir	mkdir.asm	/^_mkdir:     file format elf32-i386$/;"	l
_namei	fs.c	/^_namei(char *path, int parent, char *name)$/;"	f	file:
_rm	rm.asm	/^_rm:     file format elf32-i386$/;"	l
_sh	sh.asm	/^_sh:     file format elf32-i386$/;"	l
_usertests	usertests.asm	/^_usertests:     file format elf32-i386$/;"	l
_wc	wc.asm	/^_wc:     file format elf32-i386$/;"	l
_zombie	zombie.asm	/^_zombie:     file format elf32-i386$/;"	l
a	cat.asm	/^   a:	eb 1c                	jmp    28 <cat+0x28>$/;"	l
a	echo.asm	/^   a:	53                   	push   %ebx$/;"	l
a	forktest.asm	/^   a:	89 1c 24             	mov    %ebx,(%esp)$/;"	l
a	init.asm	/^   a:	83 ec 10             	sub    $0x10,%esp$/;"	l
a	kernel.asm	/^    a = (uint*)bp->data;$/;"	d
a	ln.asm	/^   a:	83 e4 f0             	and    $0xfffffff0,%esp$/;"	l
a0	grep.asm	/^  a0:	84 d2                	test   %dl,%dl$/;"	l
a0	ls.asm	/^  a0:	55                   	push   %ebp$/;"	l
a0	mkdir.asm	/^  a0:	55                   	push   %ebp$/;"	l
a0	rm.asm	/^  a0:	55                   	push   %ebp$/;"	l
a0	zombie.asm	/^  a0:	55                   	push   %ebp$/;"	l
a00	sh.asm	/^     a00:	89 74 24 04          	mov    %esi,0x4(%esp)$/;"	l
a00	usertests.asm	/^     a00:	eb 09                	jmp    a0b <sharedfd+0x6b>$/;"	l
a02	usertests.asm	/^     a02:	43                   	inc    %ebx$/;"	l
a03	usertests.asm	/^     a03:	81 fb e7 03 00 00    	cmp    $0x3e7,%ebx$/;"	l
a04	sh.asm	/^     a04:	89 3c 24             	mov    %edi,(%esp)$/;"	l
a07	sh.asm	/^     a07:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)$/;"	l
a09	usertests.asm	/^     a09:	7f 30                	jg     a3b <sharedfd+0x9b>$/;"	l
a0b	usertests.asm	/^     a0b:	8d 45 d8             	lea    -0x28(%ebp),%eax$/;"	l
a0e	sh.asm	/^     a0e:	00 $/;"	l
a0e	usertests.asm	/^     a0e:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)$/;"	l
a0f	sh.asm	/^     a0f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)$/;"	l
a1	cat.asm	/^  a1:	e8 8a 02 00 00       	call   330 <open>$/;"	l
a1	echo.asm	/^  a1:	0f b6 13             	movzbl (%ebx),%edx$/;"	l
a1	forktest.asm	/^  a1:	e8 5a ff ff ff       	call   0 <printf>$/;"	l
a1	init.asm	/^  a1:	c7 44 24 04 44 07 00 	movl   $0x744,0x4(%esp)$/;"	l
a1	kernel.asm	/^  a1 = alloc_pages_bulk(8);$/;"	d
a1	kill.asm	/^  a1:	0f b6 13             	movzbl (%ebx),%edx$/;"	l
a1	ln.asm	/^  a1:	0f b6 13             	movzbl (%ebx),%edx$/;"	l
a1	ls.asm	/^  a1:	89 e5                	mov    %esp,%ebp$/;"	l
a1	mkdir.asm	/^  a1:	89 e5                	mov    %esp,%ebp$/;"	l
a1	rm.asm	/^  a1:	89 e5                	mov    %esp,%ebp$/;"	l
a1	sh.asm	/^      a1:	74 0d                	je     b0 <fork1+0x20>$/;"	l
a1	zombie.asm	/^  a1:	89 e5                	mov    %esp,%ebp$/;"	l
a15	usertests.asm	/^     a15:	00 $/;"	l
a16	sh.asm	/^     a16:	00 $/;"	l
a16	usertests.asm	/^     a16:	89 3c 24             	mov    %edi,(%esp)$/;"	l
a17	sh.asm	/^     a17:	e8 04 fa ff ff       	call   420 <gettoken>$/;"	l
a19	usertests.asm	/^     a19:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
a1c	sh.asm	/^     a1c:	89 74 24 04          	mov    %esi,0x4(%esp)$/;"	l
a1d	usertests.asm	/^     a1d:	e8 fe 1c 00 00       	call   2720 <write>$/;"	l
a2	grep.asm	/^  a2:	75 cd                	jne    71 <matchhere+0x21>$/;"	l
a2	kernel.asm	/^  a2 = alloc_pages_bulk(8);$/;"	d
a20	sh.asm	/^     a20:	89 3c 24             	mov    %edi,(%esp)$/;"	l
a22	usertests.asm	/^     a22:	83 f8 0a             	cmp    $0xa,%eax$/;"	l
a23	sh.asm	/^     a23:	e8 58 ff ff ff       	call   980 <parseline>$/;"	l
a25	usertests.asm	/^     a25:	74 db                	je     a02 <sharedfd+0x62>$/;"	l
a27	usertests.asm	/^     a27:	c7 44 24 04 9c 38 00 	movl   $0x389c,0x4(%esp)$/;"	l
a28	sh.asm	/^     a28:	89 1c 24             	mov    %ebx,(%esp)$/;"	l
a2b	sh.asm	/^     a2b:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
a2e	usertests.asm	/^     a2e:	00 $/;"	l
a2f	sh.asm	/^     a2f:	e8 4c f9 ff ff       	call   380 <listcmd>$/;"	l
a2f	usertests.asm	/^     a2f:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)$/;"	l
a3	ls.asm	/^  a3:	81 ec 58 02 00 00    	sub    $0x258,%esp$/;"	l
a3	mkdir.asm	/^  a3:	53                   	push   %ebx$/;"	l
a3	rm.asm	/^  a3:	53                   	push   %ebx$/;"	l
a3	sh.asm	/^      a3:	89 d8                	mov    %ebx,%eax$/;"	l
a3	zombie.asm	/^  a3:	53                   	push   %ebx$/;"	l
a34	sh.asm	/^     a34:	89 c3                	mov    %eax,%ebx$/;"	l
a36	sh.asm	/^     a36:	83 c4 1c             	add    $0x1c,%esp$/;"	l
a36	usertests.asm	/^     a36:	e8 15 1e 00 00       	call   2850 <printf>$/;"	l
a39	sh.asm	/^     a39:	89 d8                	mov    %ebx,%eax$/;"	l
a3b	sh.asm	/^     a3b:	5b                   	pop    %ebx$/;"	l
a3b	usertests.asm	/^     a3b:	85 f6                	test   %esi,%esi$/;"	l
a3c	sh.asm	/^     a3c:	5e                   	pop    %esi$/;"	l
a3d	sh.asm	/^     a3d:	5f                   	pop    %edi$/;"	l
a3d	usertests.asm	/^     a3d:	0f 84 ff 00 00 00    	je     b42 <sharedfd+0x1a2>$/;"	l
a3e	sh.asm	/^     a3e:	c9                   	leave  $/;"	l
a3f	sh.asm	/^     a3f:	c3                   	ret    $/;"	l
a4	echo.asm	/^  a4:	5b                   	pop    %ebx$/;"	l
a4	grep.asm	/^  a4:	31 c0                	xor    %eax,%eax$/;"	l
a4	kill.asm	/^  a4:	5b                   	pop    %ebx$/;"	l
a4	ln.asm	/^  a4:	38 d0                	cmp    %dl,%al$/;"	l
a4	mkdir.asm	/^  a4:	8b 4d 08             	mov    0x8(%ebp),%ecx$/;"	l
a4	rm.asm	/^  a4:	8b 4d 08             	mov    0x8(%ebp),%ecx$/;"	l
a4	usertests.asm	/^      a4:	00 $/;"	l
a4	wc.asm	/^  a4:	89 44 24 14          	mov    %eax,0x14(%esp)$/;"	l
a4	zombie.asm	/^  a4:	8b 5d 08             	mov    0x8(%ebp),%ebx$/;"	l
a40	sh.asm	/^     a40:	55                   	push   %ebp$/;"	l
a41	sh.asm	/^     a41:	89 e5                	mov    %esp,%ebp$/;"	l
a43	sh.asm	/^     a43:	56                   	push   %esi$/;"	l
a43	usertests.asm	/^     a43:	e8 c0 1c 00 00       	call   2708 <wait>$/;"	l
a44	sh.asm	/^     a44:	53                   	push   %ebx$/;"	l
a45	sh.asm	/^     a45:	83 ec 10             	sub    $0x10,%esp$/;"	l
a48	sh.asm	/^     a48:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
a48	usertests.asm	/^     a48:	89 3c 24             	mov    %edi,(%esp)$/;"	l
a4b	sh.asm	/^     a4b:	89 04 24             	mov    %eax,(%esp)$/;"	l
a4b	usertests.asm	/^     a4b:	31 f6                	xor    %esi,%esi$/;"	l
a4d	usertests.asm	/^     a4d:	e8 d6 1c 00 00       	call   2728 <close>$/;"	l
a4e	sh.asm	/^     a4e:	e8 cd 01 00 00       	call   c20 <strlen>$/;"	l
a5	echo.asm	/^  a5:	c9                   	leave  $/;"	l
a5	kill.asm	/^  a5:	c9                   	leave  $/;"	l
a5	sh.asm	/^      a5:	83 c4 04             	add    $0x4,%esp$/;"	l
a5	usertests.asm	/^      a5:	89 04 24             	mov    %eax,(%esp)$/;"	l
a52	usertests.asm	/^     a52:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)$/;"	l
a53	sh.asm	/^     a53:	89 c3                	mov    %eax,%ebx$/;"	l
a55	sh.asm	/^     a55:	03 5d 08             	add    0x8(%ebp),%ebx$/;"	l
a58	sh.asm	/^     a58:	8d 45 08             	lea    0x8(%ebp),%eax$/;"	l
a59	usertests.asm	/^     a59:	00 $/;"	l
a5a	usertests.asm	/^     a5a:	c7 04 24 6c 2e 00 00 	movl   $0x2e6c,(%esp)$/;"	l
a5b	sh.asm	/^     a5b:	89 04 24             	mov    %eax,(%esp)$/;"	l
a5e	sh.asm	/^     a5e:	89 5c 24 04          	mov    %ebx,0x4(%esp)$/;"	l
a6	cat.asm	/^  a6:	85 c0                	test   %eax,%eax$/;"	l
a6	echo.asm	/^  a6:	0f b6 c0             	movzbl %al,%eax$/;"	l
a6	forktest.asm	/^  a6:	83 c4 14             	add    $0x14,%esp$/;"	l
a6	grep.asm	/^  a6:	80 3b 00             	cmpb   $0x0,(%ebx)$/;"	l
a6	kill.asm	/^  a6:	0f b6 c0             	movzbl %al,%eax$/;"	l
a6	ln.asm	/^  a6:	75 0c                	jne    b4 <strcmp+0x24>$/;"	l
a61	usertests.asm	/^     a61:	e8 da 1c 00 00       	call   2740 <open>$/;"	l
a62	sh.asm	/^     a62:	e8 19 ff ff ff       	call   980 <parseline>$/;"	l
a66	usertests.asm	/^     a66:	85 c0                	test   %eax,%eax$/;"	l
a67	sh.asm	/^     a67:	89 c6                	mov    %eax,%esi$/;"	l
a68	usertests.asm	/^     a68:	89 c7                	mov    %eax,%edi$/;"	l
a69	sh.asm	/^     a69:	8d 45 08             	lea    0x8(%ebp),%eax$/;"	l
a6a	usertests.asm	/^     a6a:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)$/;"	l
a6c	sh.asm	/^     a6c:	c7 44 24 08 da 11 00 	movl   $0x11da,0x8(%esp)$/;"	l
a7	mkdir.asm	/^  a7:	8b 5d 0c             	mov    0xc(%ebp),%ebx$/;"	l
a7	rm.asm	/^  a7:	8b 5d 0c             	mov    0xc(%ebp),%ebx$/;"	l
a7	zombie.asm	/^  a7:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
a71	usertests.asm	/^     a71:	0f 88 c1 00 00 00    	js     b38 <sharedfd+0x198>$/;"	l
a73	sh.asm	/^     a73:	00 $/;"	l
a74	sh.asm	/^     a74:	89 5c 24 04          	mov    %ebx,0x4(%esp)$/;"	l
a77	usertests.asm	/^     a77:	8d 45 d8             	lea    -0x28(%ebp),%eax$/;"	l
a78	sh.asm	/^     a78:	89 04 24             	mov    %eax,(%esp)$/;"	l
a7a	usertests.asm	/^     a7a:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)$/;"	l
a7b	sh.asm	/^     a7b:	e8 a0 fa ff ff       	call   520 <peek>$/;"	l
a8	cat.asm	/^  a8:	89 c3                	mov    %eax,%ebx$/;"	l
a8	init.asm	/^  a8:	00 $/;"	l
a8	ln.asm	/^  a8:	41                   	inc    %ecx$/;"	l
a8	sh.asm	/^      a8:	5b                   	pop    %ebx$/;"	l
a8	usertests.asm	/^      a8:	e8 a3 27 00 00       	call   2850 <printf>$/;"	l
a8	wc.asm	/^  a8:	8b 45 ec             	mov    -0x14(%ebp),%eax$/;"	l
a80	sh.asm	/^     a80:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
a81	usertests.asm	/^     a81:	00 $/;"	l
a82	usertests.asm	/^     a82:	89 3c 24             	mov    %edi,(%esp)$/;"	l
a83	sh.asm	/^     a83:	39 d8                	cmp    %ebx,%eax$/;"	l
a85	sh.asm	/^     a85:	74 24                	je     aab <parsecmd+0x6b>$/;"	l
a85	usertests.asm	/^     a85:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
a87	sh.asm	/^     a87:	89 44 24 08          	mov    %eax,0x8(%esp)$/;"	l
a89	usertests.asm	/^     a89:	e8 8a 1c 00 00       	call   2718 <read>$/;"	l
a8b	sh.asm	/^     a8b:	c7 44 24 04 4e 12 00 	movl   $0x124e,0x4(%esp)$/;"	l
a8e	usertests.asm	/^     a8e:	85 c0                	test   %eax,%eax$/;"	l
a9	echo.asm	/^  a9:	0f b6 d2             	movzbl %dl,%edx$/;"	l
a9	forktest.asm	/^  a9:	5b                   	pop    %ebx$/;"	l
a9	grep.asm	/^  a9:	0f 94 c0             	sete   %al$/;"	l
a9	init.asm	/^  a9:	c7 04 24 ec 06 00 00 	movl   $0x6ec,(%esp)$/;"	l
a9	kill.asm	/^  a9:	0f b6 d2             	movzbl %dl,%edx$/;"	l
a9	ln.asm	/^  a9:	43                   	inc    %ebx$/;"	l
a9	ls.asm	/^  a9:	89 5d f4             	mov    %ebx,-0xc(%ebp)$/;"	l
a9	sh.asm	/^      a9:	c9                   	leave  $/;"	l
a90	usertests.asm	/^     a90:	7e 48                	jle    ada <sharedfd+0x13a>$/;"	l
a92	sh.asm	/^     a92:	00 $/;"	l
a92	usertests.asm	/^     a92:	31 db                	xor    %ebx,%ebx$/;"	l
a93	sh.asm	/^     a93:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)$/;"	l
a94	usertests.asm	/^     a94:	eb 10                	jmp    aa6 <sharedfd+0x106>$/;"	l
a96	usertests.asm	/^     a96:	3c 70                	cmp    $0x70,%al$/;"	l
a98	usertests.asm	/^     a98:	0f 94 c0             	sete   %al$/;"	l
a9a	sh.asm	/^     a9a:	e8 71 04 00 00       	call   f10 <printf>$/;"	l
a9b	usertests.asm	/^     a9b:	0f b6 c0             	movzbl %al,%eax$/;"	l
a9e	usertests.asm	/^     a9e:	01 c6                	add    %eax,%esi$/;"	l
a9f	sh.asm	/^     a9f:	c7 04 24 35 12 00 00 	movl   $0x1235,(%esp)$/;"	l
aa	cat.asm	/^  aa:	78 1a                	js     c6 <main+0x56>$/;"	l
aa	forktest.asm	/^  aa:	c9                   	leave  $/;"	l
aa	ln.asm	/^  aa:	0f b6 01             	movzbl (%ecx),%eax$/;"	l
aa	mkdir.asm	/^  aa:	0f b6 01             	movzbl (%ecx),%eax$/;"	l
aa	rm.asm	/^  aa:	0f b6 01             	movzbl (%ecx),%eax$/;"	l
aa	sh.asm	/^      aa:	c3                   	ret    $/;"	l
aa	zombie.asm	/^  aa:	8b 55 10             	mov    0x10(%ebp),%edx$/;"	l
aa0	usertests.asm	/^     aa0:	43                   	inc    %ebx$/;"	l
aa1	usertests.asm	/^     aa1:	83 fb 09             	cmp    $0x9,%ebx$/;"	l
aa4	usertests.asm	/^     aa4:	77 d1                	ja     a77 <sharedfd+0xd7>$/;"	l
aa6	sh.asm	/^     aa6:	e8 55 f5 ff ff       	call   0 <panic>$/;"	l
aa6	usertests.asm	/^     aa6:	0f b6 44 1d d8       	movzbl -0x28(%ebp,%ebx,1),%eax$/;"	l
aab	sh.asm	/^     aab:	89 34 24             	mov    %esi,(%esp)$/;"	l
aab	usertests.asm	/^     aab:	3c 63                	cmp    $0x63,%al$/;"	l
aad	usertests.asm	/^     aad:	75 e7                	jne    a96 <sharedfd+0xf6>$/;"	l
aae	sh.asm	/^     aae:	e8 dd fa ff ff       	call   590 <nulterminate>$/;"	l
aaf	usertests.asm	/^     aaf:	ff 45 d4             	incl   -0x2c(%ebp)$/;"	l
ab	forktest.asm	/^  ab:	c3                   	ret    $/;"	l
ab	sh.asm	/^      ab:	90                   	nop    $/;"	l
ab	wc.asm	/^  ab:	89 44 24 10          	mov    %eax,0x10(%esp)$/;"	l
ab2	usertests.asm	/^     ab2:	eb ec                	jmp    aa0 <sharedfd+0x100>$/;"	l
ab3	sh.asm	/^     ab3:	83 c4 10             	add    $0x10,%esp$/;"	l
ab4	usertests.asm	/^     ab4:	b8 70 00 00 00       	mov    $0x70,%eax$/;"	l
ab6	sh.asm	/^     ab6:	89 f0                	mov    %esi,%eax$/;"	l
ab8	sh.asm	/^     ab8:	5b                   	pop    %ebx$/;"	l
ab9	sh.asm	/^     ab9:	5e                   	pop    %esi$/;"	l
ab9	usertests.asm	/^     ab9:	e9 31 ff ff ff       	jmp    9ef <sharedfd+0x4f>$/;"	l
aba	sh.asm	/^     aba:	c9                   	leave  $/;"	l
abb	sh.asm	/^     abb:	c3                   	ret    $/;"	l
abc	sh.asm	/^     abc:	8d 74 26 00          	lea    0x0(%esi),%esi$/;"	l
abe	usertests.asm	/^     abe:	c7 44 24 04 bc 38 00 	movl   $0x38bc,0x4(%esp)$/;"	l
ac	cat.asm	/^  ac:	46                   	inc    %esi$/;"	l
ac	echo.asm	/^  ac:	29 d0                	sub    %edx,%eax$/;"	l
ac	forktest.asm	/^  ac:	c7 44 24 04 a1 03 00 	movl   $0x3a1,0x4(%esp)$/;"	l
ac	grep.asm	/^  ac:	eb ea                	jmp    98 <matchhere+0x48>$/;"	l
ac	kill.asm	/^  ac:	29 d0                	sub    %edx,%eax$/;"	l
ac	ls.asm	/^  ac:	8b 5d 08             	mov    0x8(%ebp),%ebx$/;"	l
ac	sh.asm	/^      ac:	8d 74 26 00          	lea    0x0(%esi),%esi$/;"	l
ac0	sh.asm	/^     ac0:	55                   	push   %ebp$/;"	l
ac1	sh.asm	/^     ac1:	89 e5                	mov    %esp,%ebp$/;"	l
ac3	sh.asm	/^     ac3:	83 ec 18             	sub    $0x18,%esp$/;"	l
ac5	usertests.asm	/^     ac5:	00 $/;"	l
ac6	sh.asm	/^     ac6:	83 e4 f0             	and    $0xfffffff0,%esp$/;"	l
ac6	usertests.asm	/^     ac6:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)$/;"	l
ac9	sh.asm	/^     ac9:	83 ec 10             	sub    $0x10,%esp$/;"	l
acc	sh.asm	/^     acc:	8d 74 26 00          	lea    0x0(%esi),%esi$/;"	l
acd	usertests.asm	/^     acd:	e8 7e 1d 00 00       	call   2850 <printf>$/;"	l
acquire	spinlock.c	/^acquire(struct spinlock *lock)$/;"	f
ad	cat.asm	/^  ad:	89 04 24             	mov    %eax,(%esp)$/;"	l
ad	ln.asm	/^  ad:	84 c0                	test   %al,%al$/;"	l
ad	mkdir.asm	/^  ad:	84 c0                	test   %al,%al$/;"	l
ad	rm.asm	/^  ad:	84 c0                	test   %al,%al$/;"	l
ad	usertests.asm	/^      ad:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)$/;"	l
ad	zombie.asm	/^  ad:	89 d9                	mov    %ebx,%ecx$/;"	l
ad0	sh.asm	/^     ad0:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)$/;"	l
ad2	usertests.asm	/^     ad2:	83 c4 3c             	add    $0x3c,%esp$/;"	l
ad5	usertests.asm	/^     ad5:	5b                   	pop    %ebx$/;"	l
ad6	usertests.asm	/^     ad6:	5e                   	pop    %esi$/;"	l
ad7	sh.asm	/^     ad7:	00 $/;"	l
ad7	usertests.asm	/^     ad7:	5f                   	pop    %edi$/;"	l
ad8	sh.asm	/^     ad8:	c7 04 24 5d 12 00 00 	movl   $0x125d,(%esp)$/;"	l
ad8	usertests.asm	/^     ad8:	c9                   	leave  $/;"	l
ad9	usertests.asm	/^     ad9:	c3                   	ret    $/;"	l
ada	usertests.asm	/^     ada:	89 3c 24             	mov    %edi,(%esp)$/;"	l
add	usertests.asm	/^     add:	e8 46 1c 00 00       	call   2728 <close>$/;"	l
addr	mp.h	/^  uint *addr;                  \/\/ I\/O APIC address$/;"	m	struct:mpioapic
addr	pmap.h	/^		long long addr;$/;"	m	struct:e820map::__anon2
addrs	fs.h	/^  uint addrs[NADDRS];   \/\/ Data block addresses$/;"	m	struct:dinode
addrs	fsvar.h	/^  uint addrs[NADDRS];$/;"	m	struct:inode
adf	sh.asm	/^     adf:	e8 1c 03 00 00       	call   e00 <open>$/;"	l
ae	echo.asm	/^  ae:	c3                   	ret    $/;"	l
ae	grep.asm	/^  ae:	8d 41 02             	lea    0x2(%ecx),%eax$/;"	l
ae	kill.asm	/^  ae:	c3                   	ret    $/;"	l
ae2	usertests.asm	/^     ae2:	c7 04 24 6c 2e 00 00 	movl   $0x2e6c,(%esp)$/;"	l
ae4	sh.asm	/^     ae4:	85 c0                	test   %eax,%eax$/;"	l
ae6	sh.asm	/^     ae6:	78 0d                	js     af5 <main+0x35>$/;"	l
ae8	sh.asm	/^     ae8:	83 f8 02             	cmp    $0x2,%eax$/;"	l
ae9	usertests.asm	/^     ae9:	e8 62 1c 00 00       	call   2750 <unlink>$/;"	l
aeb	sh.asm	/^     aeb:	7e e3                	jle    ad0 <main+0x10>$/;"	l
aed	sh.asm	/^     aed:	89 04 24             	mov    %eax,(%esp)$/;"	l
aee	usertests.asm	/^     aee:	81 7d d4 10 27 00 00 	cmpl   $0x2710,-0x2c(%ebp)$/;"	l
af	echo.asm	/^  af:	90                   	nop    $/;"	l
af	kill.asm	/^  af:	90                   	nop    $/;"	l
af	ln.asm	/^  af:	75 f0                	jne    a1 <strcmp+0x11>$/;"	l
af	ls.asm	/^  af:	89 75 f8             	mov    %esi,-0x8(%ebp)$/;"	l
af	mkdir.asm	/^  af:	74 10                	je     c1 <strcmp+0x21>$/;"	l
af	rm.asm	/^  af:	74 10                	je     c1 <strcmp+0x21>$/;"	l
af	wc.asm	/^  af:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
af	zombie.asm	/^  af:	eb 03                	jmp    b4 <memset+0x14>$/;"	l
af0	sh.asm	/^     af0:	e8 f3 02 00 00       	call   de8 <close>$/;"	l
af5	sh.asm	/^     af5:	c7 44 24 04 64 00 00 	movl   $0x64,0x4(%esp)$/;"	l
af5	usertests.asm	/^     af5:	0f 94 c2             	sete   %dl$/;"	l
af8	usertests.asm	/^     af8:	31 c0                	xor    %eax,%eax$/;"	l
afa	usertests.asm	/^     afa:	81 fe 10 27 00 00    	cmp    $0x2710,%esi$/;"	l
afc	sh.asm	/^     afc:	00 $/;"	l
afd	sh.asm	/^     afd:	c7 04 24 e0 12 00 00 	movl   $0x12e0,(%esp)$/;"	l
align	elf.h	/^  uint align;$/;"	m	struct:proghdr
alloc_page	pmap.c	/^alloc_page()$/;"	f
alloc_pages_bulk	buddy.c	/^alloc_pages_bulk(int order)$/;"	f
allocproc	proc.c	/^allocproc(void)$/;"	f	file:
alltraps	trapasm.S	/^alltraps:$/;"	l
ap	cat.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	echo.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	grep.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	init.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	kill.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	ln.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	ls.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	mkdir.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	rm.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	sh.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	usertests.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	wc.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	zombie.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
apicid	mp.h	/^  uchar apicid;                 \/\/ local APIC id$/;"	m	struct:mpproc
apicid	proc.h	/^  uchar apicid;               \/\/ Local APIC ID$/;"	m	struct:cpu
apicno	mp.h	/^  uchar apicno;                 \/\/ I\/O APIC id$/;"	m	struct:mpioapic
argc	sh.asm	/^  argc = 0;$/;"	d
argfd	sysfile.c	/^argfd(int n, int *pfd, struct file **pf)$/;"	f	file:
argint	syscall.c	/^argint(int n, int *ip)$/;"	f
arglen	kernel.asm	/^  arglen = (arglen+3) & ~3;$/;"	d
arglen	kernel.asm	/^  arglen = 0;$/;"	d
argp	kernel.asm	/^  argp = (uint*)(void*)&fmt + 1;$/;"	d
argp	kernel.asm	/^  argp = sz - arglen - 4*(argc+1);$/;"	d
argptr	syscall.c	/^argptr(int n, char **pp, int size)$/;"	f
args	mmu.h	/^  uint args : 5;        \/\/ # args, 0 for interrupt\/trap gates$/;"	m	struct:gatedesc
argstr	syscall.c	/^argstr(int n, char **pp)$/;"	f
argv	initcode.S	/^argv:$/;"	l
argv	sh.c	/^  char *argv[MAXARGS];$/;"	m	struct:execcmd	file:
assert	assert.h	4;"	d
atoi	ulib.c	/^atoi(const char *s)$/;"	f
atomic_t	atomic.h	/^} atomic_t;$/;"	t	typeref:struct:__anon3
avl	mmu.h	/^  uint avl : 1;        \/\/ Unused (available for software use)$/;"	m	struct:segdesc
b	echo.asm	/^   b:	83 ec 1c             	sub    $0x1c,%esp$/;"	l
b	kernel.asm	/^  b = bget(dev, sector);$/;"	d
b	ls.asm	/^   b:	89 1c 24             	mov    %ebx,(%esp)$/;"	l
b	usertests.asm	/^       b:	c7 44 24 04 1d 2b 00 	movl   $0x2b1d,0x4(%esp)$/;"	l
b	wc.asm	/^   b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)$/;"	l
b0	cat.asm	/^  b0:	e8 4b ff ff ff       	call   0 <cat>$/;"	l
b0	echo.asm	/^  b0:	55                   	push   %ebp$/;"	l
b0	init.asm	/^  b0:	e8 73 02 00 00       	call   328 <exec>$/;"	l
b0	kill.asm	/^  b0:	55                   	push   %ebp$/;"	l
b0	sh.asm	/^      b0:	c7 04 24 bf 11 00 00 	movl   $0x11bf,(%esp)$/;"	l
b00	usertests.asm	/^     b00:	0f 94 c0             	sete   %al$/;"	l
b03	usertests.asm	/^     b03:	85 d0                	test   %edx,%eax$/;"	l
b04	sh.asm	/^     b04:	e8 27 f5 ff ff       	call   30 <getcmd>$/;"	l
b05	usertests.asm	/^     b05:	74 0a                	je     b11 <sharedfd+0x171>$/;"	l
b07	usertests.asm	/^     b07:	c7 44 24 04 75 2e 00 	movl   $0x2e75,0x4(%esp)$/;"	l
b09	sh.asm	/^     b09:	85 c0                	test   %eax,%eax$/;"	l
b0b	sh.asm	/^     b0b:	78 40                	js     b4d <main+0x8d>$/;"	l
b0d	sh.asm	/^     b0d:	8d 76 00             	lea    0x0(%esi),%esi$/;"	l
b0e	usertests.asm	/^     b0e:	00 $/;"	l
b0f	usertests.asm	/^     b0f:	eb b5                	jmp    ac6 <sharedfd+0x126>$/;"	l
b1	echo.asm	/^  b1:	31 c0                	xor    %eax,%eax$/;"	l
b1	grep.asm	/^  b1:	89 5c 24 08          	mov    %ebx,0x8(%esp)$/;"	l
b1	kill.asm	/^  b1:	31 c0                	xor    %eax,%eax$/;"	l
b1	ln.asm	/^  b1:	0f b6 13             	movzbl (%ebx),%edx$/;"	l
b1	mkdir.asm	/^  b1:	0f b6 13             	movzbl (%ebx),%edx$/;"	l
b1	rm.asm	/^  b1:	0f b6 13             	movzbl (%ebx),%edx$/;"	l
b1	zombie.asm	/^  b1:	88 01                	mov    %al,(%ecx)$/;"	l
b10	sh.asm	/^     b10:	80 3d e0 12 00 00 63 	cmpb   $0x63,0x12e0$/;"	l
b11	usertests.asm	/^     b11:	89 74 24 0c          	mov    %esi,0xc(%esp)$/;"	l
b15	usertests.asm	/^     b15:	8b 45 d4             	mov    -0x2c(%ebp),%eax$/;"	l
b17	sh.asm	/^     b17:	75 09                	jne    b22 <main+0x62>$/;"	l
b18	usertests.asm	/^     b18:	c7 44 24 04 82 2e 00 	movl   $0x2e82,0x4(%esp)$/;"	l
b19	sh.asm	/^     b19:	80 3d e1 12 00 00 64 	cmpb   $0x64,0x12e1$/;"	l
b1f	usertests.asm	/^     b1f:	00 $/;"	l
b2	ls.asm	/^  b2:	89 7d fc             	mov    %edi,-0x4(%ebp)$/;"	l
b2	wc.asm	/^  b2:	89 44 24 0c          	mov    %eax,0xc(%esp)$/;"	l
b20	sh.asm	/^     b20:	74 4e                	je     b70 <main+0xb0>$/;"	l
b20	usertests.asm	/^     b20:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)$/;"	l
b22	sh.asm	/^     b22:	e8 69 f5 ff ff       	call   90 <fork1>$/;"	l
b27	sh.asm	/^     b27:	85 c0                	test   %eax,%eax$/;"	l
b27	usertests.asm	/^     b27:	89 44 24 08          	mov    %eax,0x8(%esp)$/;"	l
b29	sh.asm	/^     b29:	74 27                	je     b52 <main+0x92>$/;"	l
b2b	sh.asm	/^     b2b:	90                   	nop    $/;"	l
b2b	usertests.asm	/^     b2b:	e8 20 1d 00 00       	call   2850 <printf>$/;"	l
b2c	sh.asm	/^     b2c:	8d 74 26 00          	lea    0x0(%esi),%esi$/;"	l
b3	echo.asm	/^  b3:	89 e5                	mov    %esp,%ebp$/;"	l
b3	forktest.asm	/^  b3:	00 $/;"	l
b3	kill.asm	/^  b3:	89 e5                	mov    %esp,%ebp$/;"	l
b3	zombie.asm	/^  b3:	41                   	inc    %ecx$/;"	l
b30	sh.asm	/^     b30:	e8 93 02 00 00       	call   dc8 <wait>$/;"	l
b30	usertests.asm	/^     b30:	83 c4 3c             	add    $0x3c,%esp$/;"	l
b33	usertests.asm	/^     b33:	5b                   	pop    %ebx$/;"	l
b34	usertests.asm	/^     b34:	5e                   	pop    %esi$/;"	l
b35	sh.asm	/^     b35:	c7 44 24 04 64 00 00 	movl   $0x64,0x4(%esp)$/;"	l
b35	usertests.asm	/^     b35:	5f                   	pop    %edi$/;"	l
b36	usertests.asm	/^     b36:	c9                   	leave  $/;"	l
b37	usertests.asm	/^     b37:	c3                   	ret    $/;"	l
b38	usertests.asm	/^     b38:	c7 44 24 04 e8 38 00 	movl   $0x38e8,0x4(%esp)$/;"	l
b3c	sh.asm	/^     b3c:	00 $/;"	l
b3d	sh.asm	/^     b3d:	c7 04 24 e0 12 00 00 	movl   $0x12e0,(%esp)$/;"	l
b3f	usertests.asm	/^     b3f:	00 $/;"	l
b4	forktest.asm	/^  b4:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)$/;"	l
b4	ln.asm	/^  b4:	5b                   	pop    %ebx$/;"	l
b4	mkdir.asm	/^  b4:	38 d0                	cmp    %dl,%al$/;"	l
b4	rm.asm	/^  b4:	38 d0                	cmp    %dl,%al$/;"	l
b4	usertests.asm	/^      b4:	00 $/;"	l
b4	zombie.asm	/^  b4:	4a                   	dec    %edx$/;"	l
b40	usertests.asm	/^     b40:	eb 84                	jmp    ac6 <sharedfd+0x126>$/;"	l
b42	usertests.asm	/^     b42:	e8 b9 1b 00 00       	call   2700 <exit>$/;"	l
b44	sh.asm	/^     b44:	e8 e7 f4 ff ff       	call   30 <getcmd>$/;"	l
b47	usertests.asm	/^     b47:	89 f6                	mov    %esi,%esi$/;"	l
b49	sh.asm	/^     b49:	85 c0                	test   %eax,%eax$/;"	l
b49	usertests.asm	/^     b49:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi$/;"	l
b4b	sh.asm	/^     b4b:	79 c3                	jns    b10 <main+0x50>$/;"	l
b4d	sh.asm	/^     b4d:	e8 6e 02 00 00       	call   dc0 <exit>$/;"	l
b5	cat.asm	/^  b5:	89 1c 24             	mov    %ebx,(%esp)$/;"	l
b5	echo.asm	/^  b5:	8b 55 08             	mov    0x8(%ebp),%edx$/;"	l
b5	grep.asm	/^  b5:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
b5	init.asm	/^  b5:	c7 44 24 04 26 07 00 	movl   $0x726,0x4(%esp)$/;"	l
b5	kill.asm	/^  b5:	8b 55 08             	mov    0x8(%ebp),%edx$/;"	l
b5	ln.asm	/^  b5:	c9                   	leave  $/;"	l
b5	ls.asm	/^  b5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)$/;"	l
b5	usertests.asm	/^      b5:	c7 04 24 85 2b 00 00 	movl   $0x2b85,(%esp)$/;"	l
b5	zombie.asm	/^  b5:	83 fa ff             	cmp    $0xffffffff,%edx$/;"	l
b50	usertests.asm	/^     b50:	55                   	push   %ebp$/;"	l
b51	usertests.asm	/^     b51:	89 e5                	mov    %esp,%ebp$/;"	l
b52	sh.asm	/^     b52:	c7 04 24 e0 12 00 00 	movl   $0x12e0,(%esp)$/;"	l
b53	usertests.asm	/^     b53:	57                   	push   %edi$/;"	l
b54	usertests.asm	/^     b54:	56                   	push   %esi$/;"	l
b55	usertests.asm	/^     b55:	53                   	push   %ebx$/;"	l
b56	usertests.asm	/^     b56:	83 ec 0c             	sub    $0xc,%esp$/;"	l
b59	sh.asm	/^     b59:	e8 e2 fe ff ff       	call   a40 <parsecmd>$/;"	l
b59	usertests.asm	/^     b59:	c7 44 24 04 97 2e 00 	movl   $0x2e97,0x4(%esp)$/;"	l
b5e	sh.asm	/^     b5e:	89 04 24             	mov    %eax,(%esp)$/;"	l
b6	ln.asm	/^  b6:	0f b6 c0             	movzbl %al,%eax$/;"	l
b6	mkdir.asm	/^  b6:	75 0c                	jne    c4 <strcmp+0x24>$/;"	l
b6	rm.asm	/^  b6:	75 0c                	jne    c4 <strcmp+0x24>$/;"	l
b6	wc.asm	/^  b6:	e8 05 04 00 00       	call   4c0 <printf>$/;"	l
b60	usertests.asm	/^     b60:	00 $/;"	l
b61	sh.asm	/^     b61:	e8 6a f5 ff ff       	call   d0 <runcmd>$/;"	l
b61	usertests.asm	/^     b61:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)$/;"	l
b66	sh.asm	/^     b66:	e8 5d 02 00 00       	call   dc8 <wait>$/;"	l
b68	usertests.asm	/^     b68:	e8 e3 1c 00 00       	call   2850 <printf>$/;"	l
b6b	sh.asm	/^     b6b:	eb c8                	jmp    b35 <main+0x75>$/;"	l
b6d	sh.asm	/^     b6d:	8d 76 00             	lea    0x0(%esi),%esi$/;"	l
b6d	usertests.asm	/^     b6d:	c7 04 24 e7 2f 00 00 	movl   $0x2fe7,(%esp)$/;"	l
b7	sh.asm	/^      b7:	e8 44 ff ff ff       	call   0 <panic>$/;"	l
b70	sh.asm	/^     b70:	80 3d e2 12 00 00 20 	cmpb   $0x20,0x12e2$/;"	l
b74	usertests.asm	/^     b74:	e8 d7 1b 00 00       	call   2750 <unlink>$/;"	l
b77	sh.asm	/^     b77:	75 a9                	jne    b22 <main+0x62>$/;"	l
b79	sh.asm	/^     b79:	c7 04 24 e0 12 00 00 	movl   $0x12e0,(%esp)$/;"	l
b79	usertests.asm	/^     b79:	c7 04 24 eb 2f 00 00 	movl   $0x2feb,(%esp)$/;"	l
b8	cat.asm	/^  b8:	e8 5b 02 00 00       	call   318 <close>$/;"	l
b8	echo.asm	/^  b8:	80 3a 00             	cmpb   $0x0,(%edx)$/;"	l
b8	kill.asm	/^  b8:	80 3a 00             	cmpb   $0x0,(%edx)$/;"	l
b8	mkdir.asm	/^  b8:	41                   	inc    %ecx$/;"	l
b8	rm.asm	/^  b8:	41                   	inc    %ecx$/;"	l
b8	zombie.asm	/^  b8:	75 f7                	jne    b1 <memset+0x11>$/;"	l
b80	sh.asm	/^     b80:	e8 9b 00 00 00       	call   c20 <strlen>$/;"	l
b80	usertests.asm	/^     b80:	e8 cb 1b 00 00       	call   2750 <unlink>$/;"	l
b85	sh.asm	/^     b85:	c7 04 24 e3 12 00 00 	movl   $0x12e3,(%esp)$/;"	l
b85	usertests.asm	/^     b85:	e8 6e 1b 00 00       	call   26f8 <fork>$/;"	l
b8a	usertests.asm	/^     b8a:	85 c0                	test   %eax,%eax$/;"	l
b8c	sh.asm	/^     b8c:	c6 80 df 12 00 00 00 	movb   $0x0,0x12df(%eax)$/;"	l
b8c	usertests.asm	/^     b8c:	89 c7                	mov    %eax,%edi$/;"	l
b8e	usertests.asm	/^     b8e:	0f 8c 91 01 00 00    	jl     d25 <twofiles+0x1d5>$/;"	l
b9	grep.asm	/^  b9:	0f be 01             	movsbl (%ecx),%eax$/;"	l
b9	ln.asm	/^  b9:	0f b6 d2             	movzbl %dl,%edx$/;"	l
b9	mkdir.asm	/^  b9:	43                   	inc    %ebx$/;"	l
b9	rm.asm	/^  b9:	43                   	inc    %ebx$/;"	l
b93	sh.asm	/^     b93:	e8 98 02 00 00       	call   e30 <chdir>$/;"	l
b94	usertests.asm	/^     b94:	0f 85 11 01 00 00    	jne    cab <twofiles+0x15b>$/;"	l
b98	sh.asm	/^     b98:	85 c0                	test   %eax,%eax$/;"	l
b9a	sh.asm	/^     b9a:	0f 89 55 ff ff ff    	jns    af5 <main+0x35>$/;"	l
b9a	usertests.asm	/^     b9a:	b8 eb 2f 00 00       	mov    $0x2feb,%eax$/;"	l
b9f	usertests.asm	/^     b9f:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)$/;"	l
ba	mkdir.asm	/^  ba:	0f b6 01             	movzbl (%ecx),%eax$/;"	l
ba	rm.asm	/^  ba:	0f b6 01             	movzbl (%ecx),%eax$/;"	l
ba	zombie.asm	/^  ba:	89 d8                	mov    %ebx,%eax$/;"	l
ba0	sh.asm	/^     ba0:	c7 44 24 08 e3 12 00 	movl   $0x12e3,0x8(%esp)$/;"	l
ba6	usertests.asm	/^     ba6:	00 $/;"	l
ba7	sh.asm	/^     ba7:	00 $/;"	l
ba7	usertests.asm	/^     ba7:	89 04 24             	mov    %eax,(%esp)$/;"	l
ba8	sh.asm	/^     ba8:	c7 44 24 04 65 12 00 	movl   $0x1265,0x4(%esp)$/;"	l
baa	usertests.asm	/^     baa:	e8 91 1b 00 00       	call   2740 <open>$/;"	l
backcmd	sh.c	/^backcmd(struct cmd *subcmd)$/;"	f
backcmd	sh.c	/^struct backcmd {$/;"	s	file:
bad	bootblock.asm	/^bad:$/;"	l
bad	kernel.asm	/^ bad:$/;"	l
bad	kernel.asm	/^bad:$/;"	l
baf	sh.asm	/^     baf:	00 $/;"	l
baf	usertests.asm	/^     baf:	85 c0                	test   %eax,%eax$/;"	l
balloc	fs.c	/^balloc(uint dev)$/;"	f	file:
balloc	mkfs.c	/^balloc(int used)$/;"	f
base	kernel.asm	/^    base = (paddr_t)e820_memmap->map[i].addr;$/;"	d
base	kernel.asm	/^    base = ROUNDUP(base, PAGE);$/;"	d
base	umalloc.c	/^static Header base;$/;"	v	file:
base_15_0	mmu.h	/^  uint base_15_0 : 16; \/\/ Low bits of segment base address$/;"	m	struct:segdesc
base_23_16	mmu.h	/^  uint base_23_16 : 8; \/\/ Middle bits of segment base address$/;"	m	struct:segdesc
base_31_24	mmu.h	/^  uint base_31_24 : 8; \/\/ High bits of segment base address$/;"	m	struct:segdesc
baseaddr	kernel.asm	/^		  baseaddr = (char *)(uint)e820_memmap->map[i].addr;$/;"	d
baseaddr	kernel.asm	/^		  baseaddr = ROUNDUP(baseaddr, PAGE);$/;"	d
bb	echo.asm	/^  bb:	eb 08                	jmp    c5 <strlen+0x15>$/;"	l
bb	forktest.asm	/^  bb:	e8 40 ff ff ff       	call   0 <printf>$/;"	l
bb	kill.asm	/^  bb:	eb 08                	jmp    c5 <strlen+0x15>$/;"	l
bb	wc.asm	/^  bb:	83 c4 2c             	add    $0x2c,%esp$/;"	l
bb0	sh.asm	/^     bb0:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)$/;"	l
bb1	usertests.asm	/^     bb1:	89 c6                	mov    %eax,%esi$/;"	l
bb3	usertests.asm	/^     bb3:	0f 88 a5 01 00 00    	js     d5e <twofiles+0x20e>$/;"	l
bb7	sh.asm	/^     bb7:	e8 54 03 00 00       	call   f10 <printf>$/;"	l
bb9	usertests.asm	/^     bb9:	83 ff 01             	cmp    $0x1,%edi$/;"	l
bbc	sh.asm	/^     bbc:	e9 34 ff ff ff       	jmp    af5 <main+0x35>$/;"	l
bbc	usertests.asm	/^     bbc:	c7 44 24 08 00 02 00 	movl   $0x200,0x8(%esp)$/;"	l
bc	grep.asm	/^  bc:	89 04 24             	mov    %eax,(%esp)$/;"	l
bc	init.asm	/^  bc:	00 $/;"	l
bc	ln.asm	/^  bc:	29 d0                	sub    %edx,%eax$/;"	l
bc	ls.asm	/^  bc:	00 $/;"	l
bc	sh.asm	/^      bc:	89 d8                	mov    %ebx,%eax$/;"	l
bc	usertests.asm	/^      bc:	e8 7f 26 00 00       	call   2740 <open>$/;"	l
bc	zombie.asm	/^  bc:	5b                   	pop    %ebx$/;"	l
bc1	sh.asm	/^     bc1:	90                   	nop    $/;"	l
bc2	sh.asm	/^     bc2:	90                   	nop    $/;"	l
bc3	sh.asm	/^     bc3:	90                   	nop    $/;"	l
bc3	usertests.asm	/^     bc3:	00 $/;"	l
bc4	sh.asm	/^     bc4:	90                   	nop    $/;"	l
bc4	usertests.asm	/^     bc4:	c7 04 24 a0 3d 00 00 	movl   $0x3da0,(%esp)$/;"	l
bc5	sh.asm	/^     bc5:	90                   	nop    $/;"	l
bc6	sh.asm	/^     bc6:	90                   	nop    $/;"	l
bc7	sh.asm	/^     bc7:	90                   	nop    $/;"	l
bc8	sh.asm	/^     bc8:	90                   	nop    $/;"	l
bc9	sh.asm	/^     bc9:	90                   	nop    $/;"	l
bca	sh.asm	/^     bca:	90                   	nop    $/;"	l
bcb	sh.asm	/^     bcb:	90                   	nop    $/;"	l
bcb	usertests.asm	/^     bcb:	19 c0                	sbb    %eax,%eax$/;"	l
bcc	sh.asm	/^     bcc:	90                   	nop    $/;"	l
bcd	sh.asm	/^     bcd:	90                   	nop    $/;"	l
bcd	usertests.asm	/^     bcd:	bb 0b 00 00 00       	mov    $0xb,%ebx$/;"	l
bce	sh.asm	/^     bce:	90                   	nop    $/;"	l
bcf	sh.asm	/^     bcf:	90                   	nop    $/;"	l
bcmd	sh.asm	/^    bcmd = (struct backcmd*)cmd;$/;"	d
bcpu	kernel.asm	/^        bcpu = &cpus[ncpu];$/;"	d
bcpu	kernel.asm	/^  bcpu = &cpus[ncpu];$/;"	d
bcpu	mp.c	/^static struct cpu *bcpu;$/;"	v	typeref:struct:cpu	file:
bd	cat.asm	/^  bd:	39 fe                	cmp    %edi,%esi$/;"	l
bd	echo.asm	/^  bd:	8d 76 00             	lea    0x0(%esi),%esi$/;"	l
bd	init.asm	/^  bd:	eb d1                	jmp    90 <main+0x90>$/;"	l
bd	kill.asm	/^  bd:	8d 76 00             	lea    0x0(%esi),%esi$/;"	l
bd	ls.asm	/^  bd:	89 1c 24             	mov    %ebx,(%esp)$/;"	l
bd	mkdir.asm	/^  bd:	84 c0                	test   %al,%al$/;"	l
bd	rm.asm	/^  bd:	84 c0                	test   %al,%al$/;"	l
bd	zombie.asm	/^  bd:	c9                   	leave  $/;"	l
bd0	sh.asm	/^     bd0:	55                   	push   %ebp$/;"	l
bd1	sh.asm	/^     bd1:	89 e5                	mov    %esp,%ebp$/;"	l
bd2	usertests.asm	/^     bd2:	83 e0 f3             	and    $0xfffffff3,%eax$/;"	l
bd3	sh.asm	/^     bd3:	53                   	push   %ebx$/;"	l
bd4	sh.asm	/^     bd4:	8b 4d 08             	mov    0x8(%ebp),%ecx$/;"	l
bd5	usertests.asm	/^     bd5:	83 c0 70             	add    $0x70,%eax$/;"	l
bd7	sh.asm	/^     bd7:	8b 55 0c             	mov    0xc(%ebp),%edx$/;"	l
bd8	usertests.asm	/^     bd8:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
bda	kernel.asm	/^  bda = (uchar*)0x400;$/;"	d
bda	sh.asm	/^     bda:	89 cb                	mov    %ecx,%ebx$/;"	l
bdc	sh.asm	/^     bdc:	8d 74 26 00          	lea    0x0(%esi),%esi$/;"	l
bdc	usertests.asm	/^     bdc:	e8 9f 19 00 00       	call   2580 <memset>$/;"	l
be	ln.asm	/^  be:	c3                   	ret    $/;"	l
be	sh.asm	/^      be:	83 c4 04             	add    $0x4,%esp$/;"	l
be	wc.asm	/^  be:	5b                   	pop    %ebx$/;"	l
be	zombie.asm	/^  be:	c3                   	ret    $/;"	l
be0	sh.asm	/^     be0:	0f b6 02             	movzbl (%edx),%eax$/;"	l
be1	usertests.asm	/^     be1:	c7 44 24 08 f4 01 00 	movl   $0x1f4,0x8(%esp)$/;"	l
be3	sh.asm	/^     be3:	42                   	inc    %edx$/;"	l
be4	sh.asm	/^     be4:	88 01                	mov    %al,(%ecx)$/;"	l
be6	sh.asm	/^     be6:	41                   	inc    %ecx$/;"	l
be7	sh.asm	/^     be7:	84 c0                	test   %al,%al$/;"	l
be8	usertests.asm	/^     be8:	00 $/;"	l
be9	sh.asm	/^     be9:	75 f5                	jne    be0 <strcpy+0x10>$/;"	l
be9	usertests.asm	/^     be9:	c7 44 24 04 a0 3d 00 	movl   $0x3da0,0x4(%esp)$/;"	l
beb	sh.asm	/^     beb:	89 d8                	mov    %ebx,%eax$/;"	l
bed	sh.asm	/^     bed:	5b                   	pop    %ebx$/;"	l
bee	sh.asm	/^     bee:	c9                   	leave  $/;"	l
bef	sh.asm	/^     bef:	c3                   	ret    $/;"	l
bf	cat.asm	/^  bf:	7c cf                	jl     90 <main+0x20>$/;"	l
bf	grep.asm	/^  bf:	e8 3c ff ff ff       	call   0 <matchstar>$/;"	l
bf	init.asm	/^  bf:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)$/;"	l
bf	ln.asm	/^  bf:	90                   	nop    $/;"	l
bf	mkdir.asm	/^  bf:	75 f0                	jne    b1 <strcmp+0x11>$/;"	l
bf	rm.asm	/^  bf:	75 f0                	jne    b1 <strcmp+0x11>$/;"	l
bf	wc.asm	/^  bf:	5e                   	pop    %esi$/;"	l
bf	zombie.asm	/^  bf:	90                   	nop    $/;"	l
bf0	sh.asm	/^     bf0:	55                   	push   %ebp$/;"	l
bf0	usertests.asm	/^     bf0:	00 $/;"	l
bf1	sh.asm	/^     bf1:	89 e5                	mov    %esp,%ebp$/;"	l
bf1	usertests.asm	/^     bf1:	89 34 24             	mov    %esi,(%esp)$/;"	l
bf3	sh.asm	/^     bf3:	53                   	push   %ebx$/;"	l
bf4	sh.asm	/^     bf4:	8b 4d 08             	mov    0x8(%ebp),%ecx$/;"	l
bf4	usertests.asm	/^     bf4:	e8 27 1b 00 00       	call   2720 <write>$/;"	l
bf7	sh.asm	/^     bf7:	8b 5d 0c             	mov    0xc(%ebp),%ebx$/;"	l
bf9	usertests.asm	/^     bf9:	3d f4 01 00 00       	cmp    $0x1f4,%eax$/;"	l
bfa	sh.asm	/^     bfa:	0f b6 01             	movzbl (%ecx),%eax$/;"	l
bfd	sh.asm	/^     bfd:	84 c0                	test   %al,%al$/;"	l
bfe	usertests.asm	/^     bfe:	0f 85 3d 01 00 00    	jne    d41 <twofiles+0x1f1>$/;"	l
bff	sh.asm	/^     bff:	74 10                	je     c11 <strcmp+0x21>$/;"	l
bfree	fs.c	/^bfree(int dev, uint b)$/;"	f	file:
bget	bio.c	/^bget(uint dev, uint sector)$/;"	f	file:
bi	kernel.asm	/^  bi = b % BPB;$/;"	d
bigdir	usertests.c	/^bigdir(void)$/;"	f
bigfile	usertests.c	/^bigfile(void)$/;"	f
binit	bio.c	/^binit(void)$/;"	f
bitblocks	mkfs.c	/^uint bitblocks;$/;"	v
bmap	fs.c	/^bmap(struct inode *ip, uint bn, int alloc)$/;"	f	file:
boot_cr3	kernel.asm	/^	boot_cr3 = (uint)pgdir;$/;"	d
boot_cr3	pmap.c	/^paddr_t boot_cr3;    \/\/ physical address of boot time page directory$/;"	v
boot_map_segment	pmap.c	/^boot_map_segment(pde_t * pgdir, paddr_t pa, vaddr_t la, uint size, uint perm)$/;"	f	file:
boot_pgdir	kernel.asm	/^	boot_pgdir = pgdir;$/;"	d
boot_pgdir	pmap.c	/^pde_t * boot_pgdir;    \/\/ virtual address of boot time page directory$/;"	v
booted	proc.h	/^  volatile uint booted;        \/\/ Has the CPU started?$/;"	m	struct:cpu
bootmain	bootmain.c	/^bootmain(void)$/;"	f
bootothers	main.c	/^bootothers(void)$/;"	f	file:
bp	cat.asm	/^  bp = (Header*) ap - 1;$/;"	d
bp	echo.asm	/^  bp = (Header*) ap - 1;$/;"	d
bp	grep.asm	/^  bp = (Header*) ap - 1;$/;"	d
bp	init.asm	/^  bp = (Header*) ap - 1;$/;"	d
bp	kernel.asm	/^    bp = bread(dev, BBLOCK(b, sb.ninodes));$/;"	d
bp	kernel.asm	/^    bp = bread(dev, IBLOCK(inum));$/;"	d
bp	kernel.asm	/^    bp = bread(dp->dev, bmap(dp, off \/ BSIZE, 0));$/;"	d
bp	kernel.asm	/^    bp = bread(ip->dev, IBLOCK(ip->inum));$/;"	d
bp	kernel.asm	/^    bp = bread(ip->dev, addr);$/;"	d
bp	kernel.asm	/^    bp = bread(ip->dev, bmap(ip, off\/BSIZE, 0));$/;"	d
bp	kernel.asm	/^    bp = bread(ip->dev, bmap(ip, off\/BSIZE, 1));$/;"	d
bp	kernel.asm	/^    bp = bread(ip->dev, ip->addrs[INDIRECT]);$/;"	d
bp	kernel.asm	/^  bp = 0;$/;"	d
bp	kernel.asm	/^  bp = bread(dev, 1);$/;"	d
bp	kernel.asm	/^  bp = bread(dev, BBLOCK(b, sb.ninodes));$/;"	d
bp	kernel.asm	/^  bp = bread(dev, bno);$/;"	d
bp	kernel.asm	/^  bp = bread(ip->dev, IBLOCK(ip->inum));$/;"	d
bp	kill.asm	/^  bp = (Header*) ap - 1;$/;"	d
bp	ln.asm	/^  bp = (Header*) ap - 1;$/;"	d
bp	ls.asm	/^  bp = (Header*) ap - 1;$/;"	d
bp	mkdir.asm	/^  bp = (Header*) ap - 1;$/;"	d
bp	rm.asm	/^  bp = (Header*) ap - 1;$/;"	d
bp	sh.asm	/^  bp = (Header*) ap - 1;$/;"	d
bp	usertests.asm	/^  bp = (Header*) ap - 1;$/;"	d
bp	wc.asm	/^  bp = (Header*) ap - 1;$/;"	d
bp	zombie.asm	/^  bp = (Header*) ap - 1;$/;"	d
bread	bio.c	/^bread(uint dev, uint sector)$/;"	f
brelse	bio.c	/^brelse(struct buf *b)$/;"	f
buddy	kernel.asm	/^    buddy = &mem_map[buddy_idx];$/;"	d
buddy	kernel.asm	/^    buddy = page + size;$/;"	d
buddy_idx	kernel.asm	/^    buddy_idx = page_idx ^ size;$/;"	d
buf	bio.c	/^struct buf buf[NBUF];$/;"	v	typeref:struct:buf
buf	buf.h	/^struct buf {$/;"	s
buf	cat.c	/^char buf[512];$/;"	v
buf	console.c	/^  char buf[INPUT_BUF];$/;"	m	struct:__anon1	file:
buf	grep.c	/^char buf[1024];$/;"	v
buf	usertests.c	/^char buf[2048];$/;"	v
buf	wc.c	/^char buf[512];$/;"	v
buf_table_lock	bio.c	/^struct spinlock buf_table_lock;$/;"	v	typeref:struct:spinlock
bufhead	bio.c	/^struct buf bufhead;$/;"	v	typeref:struct:buf
bwrite	bio.c	/^bwrite(struct buf *b)$/;"	f
bzero	fs.c	/^bzero(int dev, int bno)$/;"	f	file:
c	cat.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	cat.asm	/^   c:	8d 74 26 00          	lea    0x0(%esi),%esi$/;"	l
c	echo.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	grep.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	grep.asm	/^   c:	8b 7d 0c             	mov    0xc(%ebp),%edi$/;"	l
c	init.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	kernel.asm	/^    c = '\\b';$/;"	d
c	kernel.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	kernel.asm	/^    c = input.buf[input.r++ % INPUT_BUF];$/;"	d
c	kernel.asm	/^  c = &cpus[cpu()];$/;"	d
c	kernel.asm	/^  c = charcode[shift & (CTL | SHIFT)][data];$/;"	d
c	kill.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	kill.asm	/^   c:	83 e4 f0             	and    $0xfffffff0,%esp$/;"	l
c	ln.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	ls.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	mkdir.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	mkdir.asm	/^   c:	83 e4 f0             	and    $0xfffffff0,%esp$/;"	l
c	rm.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	rm.asm	/^   c:	83 e4 f0             	and    $0xfffffff0,%esp$/;"	l
c	sh.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	usertests.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	wc.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	zombie.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	zombie.asm	/^   c:	e8 07 02 00 00       	call   218 <fork>$/;"	l
c0	echo.asm	/^  c0:	40                   	inc    %eax$/;"	l
c0	forktest.asm	/^  c0:	e8 2b 02 00 00       	call   2f0 <exit>$/;"	l
c0	kill.asm	/^  c0:	40                   	inc    %eax$/;"	l
c0	ln.asm	/^  c0:	55                   	push   %ebp$/;"	l
c0	ls.asm	/^  c0:	e8 7b 04 00 00       	call   540 <open>$/;"	l
c0	wc.asm	/^  c0:	5f                   	pop    %edi$/;"	l
c0	zombie.asm	/^  c0:	55                   	push   %ebp$/;"	l
c01	sh.asm	/^     c01:	0f b6 13             	movzbl (%ebx),%edx$/;"	l
c04	sh.asm	/^     c04:	38 d0                	cmp    %dl,%al$/;"	l
c04	usertests.asm	/^     c04:	4b                   	dec    %ebx$/;"	l
c05	usertests.asm	/^     c05:	79 da                	jns    be1 <twofiles+0x91>$/;"	l
c06	sh.asm	/^     c06:	75 0c                	jne    c14 <strcmp+0x24>$/;"	l
c07	usertests.asm	/^     c07:	89 34 24             	mov    %esi,(%esp)$/;"	l
c08	sh.asm	/^     c08:	41                   	inc    %ecx$/;"	l
c09	sh.asm	/^     c09:	43                   	inc    %ebx$/;"	l
c0a	sh.asm	/^     c0a:	0f b6 01             	movzbl (%ecx),%eax$/;"	l
c0a	usertests.asm	/^     c0a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi$/;"	l
c0d	sh.asm	/^     c0d:	84 c0                	test   %al,%al$/;"	l
c0f	sh.asm	/^     c0f:	75 f0                	jne    c01 <strcmp+0x11>$/;"	l
c1	cat.asm	/^  c1:	e8 2a 02 00 00       	call   2f0 <exit>$/;"	l
c1	echo.asm	/^  c1:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)$/;"	l
c1	kill.asm	/^  c1:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)$/;"	l
c1	ln.asm	/^  c1:	31 c0                	xor    %eax,%eax$/;"	l
c1	mkdir.asm	/^  c1:	0f b6 13             	movzbl (%ebx),%edx$/;"	l
c1	rm.asm	/^  c1:	0f b6 13             	movzbl (%ebx),%edx$/;"	l
c1	sh.asm	/^      c1:	5b                   	pop    %ebx$/;"	l
c1	usertests.asm	/^      c1:	85 c0                	test   %eax,%eax$/;"	l
c1	wc.asm	/^  c1:	c9                   	leave  $/;"	l
c1	zombie.asm	/^  c1:	89 e5                	mov    %esp,%ebp$/;"	l
c10	usertests.asm	/^     c10:	e8 13 1b 00 00       	call   2728 <close>$/;"	l
c11	sh.asm	/^     c11:	0f b6 13             	movzbl (%ebx),%edx$/;"	l
c14	sh.asm	/^     c14:	5b                   	pop    %ebx$/;"	l
c15	sh.asm	/^     c15:	c9                   	leave  $/;"	l
c15	usertests.asm	/^     c15:	85 ff                	test   %edi,%edi$/;"	l
c16	sh.asm	/^     c16:	0f b6 c0             	movzbl %al,%eax$/;"	l
c17	usertests.asm	/^     c17:	0f 84 89 00 00 00    	je     ca6 <twofiles+0x156>$/;"	l
c19	sh.asm	/^     c19:	0f b6 d2             	movzbl %dl,%edx$/;"	l
c1c	sh.asm	/^     c1c:	29 d0                	sub    %edx,%eax$/;"	l
c1d	usertests.asm	/^     c1d:	31 db                	xor    %ebx,%ebx$/;"	l
c1e	sh.asm	/^     c1e:	c3                   	ret    $/;"	l
c1f	sh.asm	/^     c1f:	90                   	nop    $/;"	l
c1f	usertests.asm	/^     c1f:	e8 e4 1a 00 00       	call   2708 <wait>$/;"	l
c2	sh.asm	/^      c2:	c9                   	leave  $/;"	l
c2	wc.asm	/^  c2:	c3                   	ret    $/;"	l
c20	sh.asm	/^     c20:	55                   	push   %ebp$/;"	l
c21	sh.asm	/^     c21:	31 c0                	xor    %eax,%eax$/;"	l
c23	sh.asm	/^     c23:	89 e5                	mov    %esp,%ebp$/;"	l
c24	usertests.asm	/^     c24:	83 fb 01             	cmp    $0x1,%ebx$/;"	l
c25	sh.asm	/^     c25:	8b 55 08             	mov    0x8(%ebp),%edx$/;"	l
c27	usertests.asm	/^     c27:	0f 8f c4 00 00 00    	jg     cf1 <twofiles+0x1a1>$/;"	l
c28	sh.asm	/^     c28:	80 3a 00             	cmpb   $0x0,(%edx)$/;"	l
c2b	sh.asm	/^     c2b:	eb 08                	jmp    c35 <strlen+0x15>$/;"	l
c2d	sh.asm	/^     c2d:	8d 76 00             	lea    0x0(%esi),%esi$/;"	l
c2d	usertests.asm	/^     c2d:	85 db                	test   %ebx,%ebx$/;"	l
c2f	usertests.asm	/^     c2f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)$/;"	l
c3	ln.asm	/^  c3:	89 e5                	mov    %esp,%ebp$/;"	l
c3	sh.asm	/^      c3:	c3                   	ret    $/;"	l
c3	usertests.asm	/^      c3:	89 c6                	mov    %eax,%esi$/;"	l
c3	wc.asm	/^  c3:	c7 44 24 04 7f 07 00 	movl   $0x77f,0x4(%esp)$/;"	l
c3	zombie.asm	/^  c3:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx$/;"	l
c30	sh.asm	/^     c30:	40                   	inc    %eax$/;"	l
c31	sh.asm	/^     c31:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)$/;"	l
c35	sh.asm	/^     c35:	75 f9                	jne    c30 <strlen+0x10>$/;"	l
c36	usertests.asm	/^     c36:	00 $/;"	l
c37	sh.asm	/^     c37:	c9                   	leave  $/;"	l
c37	usertests.asm	/^     c37:	b8 e7 2f 00 00       	mov    $0x2fe7,%eax$/;"	l
c38	sh.asm	/^     c38:	c3                   	ret    $/;"	l
c39	sh.asm	/^     c39:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi$/;"	l
c3c	usertests.asm	/^     c3c:	75 05                	jne    c43 <twofiles+0xf3>$/;"	l
c3e	usertests.asm	/^     c3e:	b8 eb 2f 00 00       	mov    $0x2feb,%eax$/;"	l
c4	grep.asm	/^  c4:	83 c4 14             	add    $0x14,%esp$/;"	l
c4	mkdir.asm	/^  c4:	5b                   	pop    %ebx$/;"	l
c4	rm.asm	/^  c4:	5b                   	pop    %ebx$/;"	l
c4	sh.asm	/^      c4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi$/;"	l
c40	sh.asm	/^     c40:	55                   	push   %ebp$/;"	l
c41	sh.asm	/^     c41:	89 e5                	mov    %esp,%ebp$/;"	l
c43	sh.asm	/^     c43:	53                   	push   %ebx$/;"	l
c43	usertests.asm	/^     c43:	89 04 24             	mov    %eax,(%esp)$/;"	l
c44	sh.asm	/^     c44:	8b 5d 08             	mov    0x8(%ebp),%ebx$/;"	l
c46	usertests.asm	/^     c46:	31 ff                	xor    %edi,%edi$/;"	l
c47	sh.asm	/^     c47:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
c48	usertests.asm	/^     c48:	e8 f3 1a 00 00       	call   2740 <open>$/;"	l
c4a	sh.asm	/^     c4a:	8b 55 10             	mov    0x10(%ebp),%edx$/;"	l
c4d	sh.asm	/^     c4d:	89 d9                	mov    %ebx,%ecx$/;"	l
c4d	usertests.asm	/^     c4d:	89 c6                	mov    %eax,%esi$/;"	l
c4f	sh.asm	/^     c4f:	eb 03                	jmp    c54 <memset+0x14>$/;"	l
c4f	usertests.asm	/^     c4f:	c7 44 24 08 00 08 00 	movl   $0x800,0x8(%esp)$/;"	l
c5	echo.asm	/^  c5:	75 f9                	jne    c0 <strlen+0x10>$/;"	l
c5	forktest.asm	/^  c5:	c7 44 24 04 b5 03 00 	movl   $0x3b5,0x4(%esp)$/;"	l
c5	kill.asm	/^  c5:	75 f9                	jne    c0 <strlen+0x10>$/;"	l
c5	ln.asm	/^  c5:	8b 55 08             	mov    0x8(%ebp),%edx$/;"	l
c5	ls.asm	/^  c5:	85 c0                	test   %eax,%eax$/;"	l
c5	mkdir.asm	/^  c5:	c9                   	leave  $/;"	l
c5	rm.asm	/^  c5:	c9                   	leave  $/;"	l
c5	usertests.asm	/^      c5:	0f 88 49 01 00 00    	js     214 <writetest+0x184>$/;"	l
c51	sh.asm	/^     c51:	88 01                	mov    %al,(%ecx)$/;"	l
c53	sh.asm	/^     c53:	41                   	inc    %ecx$/;"	l
c54	sh.asm	/^     c54:	4a                   	dec    %edx$/;"	l
c55	sh.asm	/^     c55:	83 fa ff             	cmp    $0xffffffff,%edx$/;"	l
c56	usertests.asm	/^     c56:	00 $/;"	l
c57	usertests.asm	/^     c57:	c7 44 24 04 a0 3d 00 	movl   $0x3da0,0x4(%esp)$/;"	l
c58	sh.asm	/^     c58:	75 f7                	jne    c51 <memset+0x11>$/;"	l
c5a	sh.asm	/^     c5a:	89 d8                	mov    %ebx,%eax$/;"	l
c5c	sh.asm	/^     c5c:	5b                   	pop    %ebx$/;"	l
c5d	sh.asm	/^     c5d:	c9                   	leave  $/;"	l
c5e	sh.asm	/^     c5e:	c3                   	ret    $/;"	l
c5e	usertests.asm	/^     c5e:	00 $/;"	l
c5f	sh.asm	/^     c5f:	90                   	nop    $/;"	l
c5f	usertests.asm	/^     c5f:	89 34 24             	mov    %esi,(%esp)$/;"	l
c6	cat.asm	/^  c6:	8b 55 0c             	mov    0xc(%ebp),%edx$/;"	l
c6	init.asm	/^  c6:	00 $/;"	l
c6	mkdir.asm	/^  c6:	0f b6 c0             	movzbl %al,%eax$/;"	l
c6	rm.asm	/^  c6:	0f b6 c0             	movzbl %al,%eax$/;"	l
c60	sh.asm	/^     c60:	55                   	push   %ebp$/;"	l
c61	sh.asm	/^     c61:	89 e5                	mov    %esp,%ebp$/;"	l
c62	usertests.asm	/^     c62:	e8 b1 1a 00 00       	call   2718 <read>$/;"	l
c63	sh.asm	/^     c63:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx$/;"	l
c67	sh.asm	/^     c67:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
c67	usertests.asm	/^     c67:	85 c0                	test   %eax,%eax$/;"	l
c69	usertests.asm	/^     c69:	7e 68                	jle    cd3 <twofiles+0x183>$/;"	l
c6a	sh.asm	/^     c6a:	eb 09                	jmp    c75 <strchr+0x15>$/;"	l
c6b	usertests.asm	/^     c6b:	90                   	nop    $/;"	l
c6c	sh.asm	/^     c6c:	8d 74 26 00          	lea    0x0(%esi),%esi$/;"	l
c6c	usertests.asm	/^     c6c:	8d 74 26 00          	lea    0x0(%esi),%esi$/;"	l
c7	echo.asm	/^  c7:	c9                   	leave  $/;"	l
c7	grep.asm	/^  c7:	5b                   	pop    %ebx$/;"	l
c7	init.asm	/^  c7:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)$/;"	l
c7	kill.asm	/^  c7:	c9                   	leave  $/;"	l
c7	ls.asm	/^  c7:	89 c6                	mov    %eax,%esi$/;"	l
c7	zombie.asm	/^  c7:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
c70	sh.asm	/^     c70:	38 ca                	cmp    %cl,%dl$/;"	l
c70	usertests.asm	/^     c70:	31 c9                	xor    %ecx,%ecx$/;"	l
c72	sh.asm	/^     c72:	74 0a                	je     c7e <strchr+0x1e>$/;"	l
c72	usertests.asm	/^     c72:	eb 06                	jmp    c7a <twofiles+0x12a>$/;"	l
c74	sh.asm	/^     c74:	40                   	inc    %eax$/;"	l
c74	usertests.asm	/^     c74:	83 fa 70             	cmp    $0x70,%edx$/;"	l
c75	sh.asm	/^     c75:	0f b6 10             	movzbl (%eax),%edx$/;"	l
c77	usertests.asm	/^     c77:	75 19                	jne    c92 <twofiles+0x142>$/;"	l
c78	sh.asm	/^     c78:	84 d2                	test   %dl,%dl$/;"	l
c79	usertests.asm	/^     c79:	41                   	inc    %ecx$/;"	l
c7a	sh.asm	/^     c7a:	75 f4                	jne    c70 <strchr+0x10>$/;"	l
c7a	usertests.asm	/^     c7a:	39 c1                	cmp    %eax,%ecx$/;"	l
c7c	sh.asm	/^     c7c:	31 c0                	xor    %eax,%eax$/;"	l
c7c	usertests.asm	/^     c7c:	8d 74 26 00          	lea    0x0(%esi),%esi$/;"	l
c7e	sh.asm	/^     c7e:	c9                   	leave  $/;"	l
c7f	sh.asm	/^     c7f:	90                   	nop    $/;"	l
c8	echo.asm	/^  c8:	c3                   	ret    $/;"	l
c8	grep.asm	/^  c8:	c9                   	leave  $/;"	l
c8	kill.asm	/^  c8:	c3                   	ret    $/;"	l
c8	ln.asm	/^  c8:	80 3a 00             	cmpb   $0x0,(%edx)$/;"	l
c80	sh.asm	/^     c80:	c3                   	ret    $/;"	l
c80	usertests.asm	/^     c80:	7d 33                	jge    cb5 <twofiles+0x165>$/;"	l
c81	sh.asm	/^     c81:	eb 0d                	jmp    c90 <gets>$/;"	l
c82	usertests.asm	/^     c82:	85 db                	test   %ebx,%ebx$/;"	l
c83	sh.asm	/^     c83:	90                   	nop    $/;"	l
c84	sh.asm	/^     c84:	90                   	nop    $/;"	l
c84	usertests.asm	/^     c84:	0f be 91 a0 3d 00 00 	movsbl 0x3da0(%ecx),%edx$/;"	l
c85	sh.asm	/^     c85:	90                   	nop    $/;"	l
c86	sh.asm	/^     c86:	90                   	nop    $/;"	l
c87	sh.asm	/^     c87:	90                   	nop    $/;"	l
c88	sh.asm	/^     c88:	90                   	nop    $/;"	l
c89	sh.asm	/^     c89:	90                   	nop    $/;"	l
c8a	sh.asm	/^     c8a:	90                   	nop    $/;"	l
c8b	sh.asm	/^     c8b:	90                   	nop    $/;"	l
c8b	usertests.asm	/^     c8b:	75 e7                	jne    c74 <twofiles+0x124>$/;"	l
c8c	sh.asm	/^     c8c:	90                   	nop    $/;"	l
c8d	sh.asm	/^     c8d:	90                   	nop    $/;"	l
c8d	usertests.asm	/^     c8d:	83 fa 63             	cmp    $0x63,%edx$/;"	l
c8e	sh.asm	/^     c8e:	90                   	nop    $/;"	l
c8f	sh.asm	/^     c8f:	90                   	nop    $/;"	l
c9	cat.asm	/^  c9:	8b 04 b2             	mov    (%edx,%esi,4),%eax$/;"	l
c9	echo.asm	/^  c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi$/;"	l
c9	grep.asm	/^  c9:	c3                   	ret    $/;"	l
c9	kill.asm	/^  c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi$/;"	l
c9	ls.asm	/^  c9:	78 45                	js     110 <ls+0x70>$/;"	l
c9	mkdir.asm	/^  c9:	0f b6 d2             	movzbl %dl,%edx$/;"	l
c9	rm.asm	/^  c9:	0f b6 d2             	movzbl %dl,%edx$/;"	l
c90	sh.asm	/^     c90:	55                   	push   %ebp$/;"	l
c90	usertests.asm	/^     c90:	74 e7                	je     c79 <twofiles+0x129>$/;"	l
c91	sh.asm	/^     c91:	89 e5                	mov    %esp,%ebp$/;"	l
c92	usertests.asm	/^     c92:	c7 44 24 04 a6 2e 00 	movl   $0x2ea6,0x4(%esp)$/;"	l
c93	sh.asm	/^     c93:	57                   	push   %edi$/;"	l
c94	sh.asm	/^     c94:	56                   	push   %esi$/;"	l
c95	sh.asm	/^     c95:	53                   	push   %ebx$/;"	l
c96	sh.asm	/^     c96:	31 db                	xor    %ebx,%ebx$/;"	l
c98	sh.asm	/^     c98:	83 ec 1c             	sub    $0x1c,%esp$/;"	l
c99	usertests.asm	/^     c99:	00 $/;"	l
c9a	usertests.asm	/^     c9a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)$/;"	l
c9b	sh.asm	/^     c9b:	8b 7d 0c             	mov    0xc(%ebp),%edi$/;"	l
c9e	sh.asm	/^     c9e:	8b 75 08             	mov    0x8(%ebp),%esi$/;"	l
ca	grep.asm	/^  ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi$/;"	l
ca	sh.asm	/^      ca:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi$/;"	l
ca	wc.asm	/^  ca:	00 $/;"	l
ca	zombie.asm	/^  ca:	eb 09                	jmp    d5 <strchr+0x15>$/;"	l
ca1	sh.asm	/^     ca1:	83 ff 01             	cmp    $0x1,%edi$/;"	l
ca1	usertests.asm	/^     ca1:	e8 aa 1b 00 00       	call   2850 <printf>$/;"	l
ca4	sh.asm	/^     ca4:	7e 3e                	jle    ce4 <gets+0x54>$/;"	l
ca6	sh.asm	/^     ca6:	8d 45 f3             	lea    -0xd(%ebp),%eax$/;"	l
ca6	usertests.asm	/^     ca6:	e8 55 1a 00 00       	call   2700 <exit>$/;"	l
ca9	sh.asm	/^     ca9:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)$/;"	l
cab	usertests.asm	/^     cab:	b8 e7 2f 00 00       	mov    $0x2fe7,%eax$/;"	l
cat	cat.c	/^cat(int fd)$/;"	f
cat_args	usertests.c	/^char *cat_args[] = { "cat", "README", 0 };$/;"	v
cb	ln.asm	/^  cb:	eb 08                	jmp    d5 <strlen+0x15>$/;"	l
cb	ls.asm	/^  cb:	8d bd c8 fd ff ff    	lea    -0x238(%ebp),%edi$/;"	l
cb	usertests.asm	/^      cb:	a1 44 3d 00 00       	mov    0x3d44,%eax$/;"	l
cb	wc.asm	/^  cb:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)$/;"	l
cb0	sh.asm	/^     cb0:	00 $/;"	l
cb0	usertests.asm	/^     cb0:	e9 ea fe ff ff       	jmp    b9f <twofiles+0x4f>$/;"	l
cb1	sh.asm	/^     cb1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)$/;"	l
cb5	usertests.asm	/^     cb5:	c7 44 24 08 00 08 00 	movl   $0x800,0x8(%esp)$/;"	l
cb8	sh.asm	/^     cb8:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
cbc	sh.asm	/^     cbc:	e8 17 01 00 00       	call   dd8 <read>$/;"	l
cbc	usertests.asm	/^     cbc:	00 $/;"	l
cbd	usertests.asm	/^     cbd:	c7 44 24 04 a0 3d 00 	movl   $0x3da0,0x4(%esp)$/;"	l
cc	cat.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	cat.asm	/^  cc:	c7 44 24 04 fd 06 00 	movl   $0x6fd,0x4(%esp)$/;"	l
cc	echo.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	forktest.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	forktest.asm	/^  cc:	00 $/;"	l
cc	grep.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	init.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	kill.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	ln.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	ls.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	mkdir.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	mkdir.asm	/^  cc:	29 d0                	sub    %edx,%eax$/;"	l
cc	rm.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	rm.asm	/^  cc:	29 d0                	sub    %edx,%eax$/;"	l
cc	sh.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	usertests.asm	/^        cc = sizeof(buf);$/;"	d
cc	usertests.asm	/^      cc = cc * 2;$/;"	d
cc	usertests.asm	/^    cc = 1;$/;"	d
cc	usertests.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	usertests.asm	/^    cc = read(fd, buf, 300);$/;"	d
cc	usertests.asm	/^  cc = read(fd, buf, sizeof(buf));$/;"	d
cc	wc.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	zombie.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	zombie.asm	/^  cc:	8d 74 26 00          	lea    0x0(%esi),%esi$/;"	l
cc1	sh.asm	/^     cc1:	85 c0                	test   %eax,%eax$/;"	l
cc3	sh.asm	/^     cc3:	7e 1f                	jle    ce4 <gets+0x54>$/;"	l
cc4	usertests.asm	/^     cc4:	00 $/;"	l
cc5	sh.asm	/^     cc5:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax$/;"	l
cc5	usertests.asm	/^     cc5:	01 c7                	add    %eax,%edi$/;"	l
cc7	usertests.asm	/^     cc7:	89 34 24             	mov    %esi,(%esp)$/;"	l
cc9	sh.asm	/^     cc9:	88 04 33             	mov    %al,(%ebx,%esi,1)$/;"	l
cca	usertests.asm	/^     cca:	e8 49 1a 00 00       	call   2718 <read>$/;"	l
ccc	sh.asm	/^     ccc:	43                   	inc    %ebx$/;"	l
ccd	sh.asm	/^     ccd:	3c 0a                	cmp    $0xa,%al$/;"	l
ccf	sh.asm	/^     ccf:	0f 94 c2             	sete   %dl$/;"	l
ccf	usertests.asm	/^     ccf:	85 c0                	test   %eax,%eax$/;"	l
cd	forktest.asm	/^  cd:	eb e5                	jmp    b4 <forktest+0x84>$/;"	l
cd	ln.asm	/^  cd:	8d 76 00             	lea    0x0(%esi),%esi$/;"	l
cd1	usertests.asm	/^     cd1:	7f 9d                	jg     c70 <twofiles+0x120>$/;"	l
cd2	sh.asm	/^     cd2:	3c 0d                	cmp    $0xd,%al$/;"	l
cd3	usertests.asm	/^     cd3:	89 34 24             	mov    %esi,(%esp)$/;"	l
cd4	sh.asm	/^     cd4:	0f 94 c0             	sete   %al$/;"	l
cd6	usertests.asm	/^     cd6:	e8 4d 1a 00 00       	call   2728 <close>$/;"	l
cd7	sh.asm	/^     cd7:	09 d0                	or     %edx,%eax$/;"	l
cd9	sh.asm	/^     cd9:	a8 01                	test   $0x1,%al$/;"	l
cdb	sh.asm	/^     cdb:	75 07                	jne    ce4 <gets+0x54>$/;"	l
cdb	usertests.asm	/^     cdb:	81 ff 70 17 00 00    	cmp    $0x1770,%edi$/;"	l
cdd	sh.asm	/^     cdd:	8d 43 01             	lea    0x1(%ebx),%eax$/;"	l
ce	init.asm	/^  ce:	00 $/;"	l
ce	mkdir.asm	/^  ce:	c3                   	ret    $/;"	l
ce	rm.asm	/^  ce:	c3                   	ret    $/;"	l
ce0	sh.asm	/^     ce0:	39 f8                	cmp    %edi,%eax$/;"	l
ce1	usertests.asm	/^     ce1:	0f 85 84 00 00 00    	jne    d6b <twofiles+0x21b>$/;"	l
ce2	sh.asm	/^     ce2:	7c c2                	jl     ca6 <gets+0x16>$/;"	l
ce4	sh.asm	/^     ce4:	c6 04 1e 00          	movb   $0x0,(%esi,%ebx,1)$/;"	l
ce7	usertests.asm	/^     ce7:	43                   	inc    %ebx$/;"	l
ce8	sh.asm	/^     ce8:	83 c4 1c             	add    $0x1c,%esp$/;"	l
ce8	usertests.asm	/^     ce8:	83 fb 01             	cmp    $0x1,%ebx$/;"	l
ceb	sh.asm	/^     ceb:	89 f0                	mov    %esi,%eax$/;"	l
ceb	usertests.asm	/^     ceb:	0f 8e 3c ff ff ff    	jle    c2d <twofiles+0xdd>$/;"	l
ced	sh.asm	/^     ced:	5b                   	pop    %ebx$/;"	l
cee	sh.asm	/^     cee:	5e                   	pop    %esi$/;"	l
cef	sh.asm	/^     cef:	5f                   	pop    %edi$/;"	l
cf	forktest.asm	/^  cf:	c7 44 24 04 c8 03 00 	movl   $0x3c8,0x4(%esp)$/;"	l
cf	init.asm	/^  cf:	c7 04 24 ef 06 00 00 	movl   $0x6ef,(%esp)$/;"	l
cf	mkdir.asm	/^  cf:	90                   	nop    $/;"	l
cf	rm.asm	/^  cf:	90                   	nop    $/;"	l
cf0	sh.asm	/^     cf0:	c9                   	leave  $/;"	l
cf1	sh.asm	/^     cf1:	c3                   	ret    $/;"	l
cf1	usertests.asm	/^     cf1:	c7 04 24 e7 2f 00 00 	movl   $0x2fe7,(%esp)$/;"	l
cf2	sh.asm	/^     cf2:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi$/;"	l
cf8	usertests.asm	/^     cf8:	e8 53 1a 00 00       	call   2750 <unlink>$/;"	l
cf9	sh.asm	/^     cf9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi$/;"	l
cfd	usertests.asm	/^     cfd:	c7 04 24 eb 2f 00 00 	movl   $0x2feb,(%esp)$/;"	l
cga_putc	console.c	/^cga_putc(int c)$/;"	f	file:
chan	proc.h	/^  void *chan;               \/\/ If non-zero, sleeping on chan$/;"	m	struct:proc
char	cat.asm	/^char buf[512];$/;"	l
char	grep.asm	/^char buf[1024];$/;"	l
char	init.asm	/^char *sh_args[] = { "sh", 0 };$/;"	l
char	kernel.asm	/^char * start;  \/\/ start address after kernel$/;"	l
char	kernel.asm	/^char *$/;"	l
char	sh.asm	/^char symbols[] = "<|>&;()";$/;"	l
char	sh.asm	/^char whitespace[] = " \\t\\r\\n\\v";$/;"	l
char	wc.asm	/^char buf[512];$/;"	l
check_boot_pgdir	pmap.c	/^check_boot_pgdir()$/;"	f	file:
check_va2pa	pmap.c	/^check_va2pa(vaddr_t va)$/;"	f	file:
checksum	mp.h	/^  uchar checksum;               \/\/ all bytes must add up to 0$/;"	m	struct:mp
checksum	mp.h	/^  uchar checksum;               \/\/ all bytes must add up to 0$/;"	m	struct:mpconf
cli	x86.h	/^cli(void)$/;"	f
cmd	sh.asm	/^      cmd = redircmd(cmd, q, eq, O_RDONLY, 0);$/;"	d
cmd	sh.asm	/^      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);$/;"	d
cmd	sh.asm	/^    cmd = backcmd(cmd);$/;"	d
cmd	sh.asm	/^    cmd = listcmd(cmd, parseline(ps, es));$/;"	d
cmd	sh.asm	/^    cmd = pipecmd(cmd, parsepipe(ps, es));$/;"	d
cmd	sh.asm	/^  cmd = (struct execcmd*)ret;$/;"	d
cmd	sh.asm	/^  cmd = malloc(sizeof(*cmd));$/;"	d
cmd	sh.asm	/^  cmd = parseexec(ps, es);$/;"	d
cmd	sh.asm	/^  cmd = parseline(&s, es);$/;"	d
cmd	sh.asm	/^  cmd = parseline(ps, es);$/;"	d
cmd	sh.asm	/^  cmd = parsepipe(ps, es);$/;"	d
cmd	sh.asm	/^  cmd = parseredirs(cmd, ps, es);$/;"	d
cmd	sh.c	/^  struct cmd *cmd;$/;"	m	struct:backcmd	typeref:struct:backcmd::cmd	file:
cmd	sh.c	/^  struct cmd *cmd;$/;"	m	struct:redircmd	typeref:struct:redircmd::cmd	file:
cmd	sh.c	/^struct cmd {$/;"	s	file:
coalesced	kernel.asm	/^  coalesced = &mem_map[page_idx];$/;"	d
code	kernel.asm	/^  code = (uchar*)0x7000;$/;"	d
concreate	usertests.c	/^concreate(void)$/;"	f
conf	kernel.asm	/^  conf = (struct mpconf*)mp->physaddr;$/;"	d
cons_putc	console.c	/^cons_putc(int c)$/;"	f
console_init	console.c	/^console_init(void)$/;"	f
console_intr	console.c	/^console_intr(int (*getc)(void))$/;"	f
console_lock	console.c	/^static struct spinlock console_lock;$/;"	v	typeref:struct:spinlock	file:
console_read	console.c	/^console_read(struct inode *ip, char *dst, int n)$/;"	f
console_write	console.c	/^console_write(struct inode *ip, char *buf, int n)$/;"	f
cont	bootasm.S	/^cont:$/;"	l
cont	bootblock.asm	/^cont:$/;"	l
context	proc.h	/^  struct context context;     \/\/ Switch here to enter scheduler$/;"	m	struct:cpu	typeref:struct:cpu::context
context	proc.h	/^  struct context context;   \/\/ Switch here to run process$/;"	m	struct:proc	typeref:struct:proc::context
context	proc.h	/^struct context {$/;"	s
copyproc	proc.c	/^copyproc(struct proc *p)$/;"	f
count	atomic.h	/^	int count;$/;"	m	struct:__anon3
cp	proc.h	84;"	d
cprintf	console.c	/^cprintf(char *fmt, ...)$/;"	f
cpu	lapic.c	/^cpu(void)$/;"	f
cpu	proc.h	/^struct cpu {$/;"	s
cpu	spinlock.h	/^  int  cpu;      \/\/ The number of the cpu holding the lock.$/;"	m	struct:spinlock
cpus	mp.c	/^struct cpu cpus[NCPU];$/;"	v	typeref:struct:cpu
cr0	kernel.asm	/^	cr0 = rcr0();$/;"	d
cr3	mmu.h	/^  void *cr3;         \/\/ Page directory base$/;"	m	struct:taskstate
cr3	proc.h	/^  paddr_t cr3;                \/\/ cr3 register$/;"	m	struct:cpu
create	sysfile.c	/^create(char *path, int canexist, short type, short major, short minor)$/;"	f	file:
createdelete	usertests.c	/^createdelete(void)$/;"	f
createtest	usertests.c	/^createtest(void)$/;"	f
crt	console.c	/^static ushort *crt = (ushort*)0xb8000;  \/\/ CGA memory$/;"	v	file:
cs	mmu.h	/^  uint cs : 16;         \/\/ code segment selector$/;"	m	struct:gatedesc
cs	mmu.h	/^  ushort cs;$/;"	m	struct:taskstate
cs	x86.h	/^  ushort cs;$/;"	m	struct:trapframe
ctlmap	kbd.h	/^static uchar ctlmap[256] =$/;"	v
curproc	proc.c	/^curproc(void)$/;"	f
curproc	proc.h	/^  struct proc *curproc;       \/\/ Process currently running.$/;"	m	struct:cpu	typeref:struct:cpu::proc
cwd	proc.h	/^  struct inode *cwd;        \/\/ Current directory$/;"	m	struct:proc	typeref:struct:proc::inode
d	cat.asm	/^  d = dst;$/;"	d
d	echo.asm	/^  d = dst;$/;"	d
d	forktest.asm	/^   d:	e8 3e 01 00 00       	call   150 <strlen>$/;"	l
d	forktest.asm	/^  d = dst;$/;"	d
d	grep.asm	/^  d = dst;$/;"	d
d	init.asm	/^   d:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)$/;"	l
d	init.asm	/^  d = dst;$/;"	d
d	kernel.asm	/^  d = (char*)dst;$/;"	d
d	kernel.asm	/^  d = dst;$/;"	d
d	kill.asm	/^  d = dst;$/;"	d
d	ln.asm	/^   d:	83 ec 10             	sub    $0x10,%esp$/;"	l
d	ln.asm	/^  d = dst;$/;"	d
d	ls.asm	/^  d = dst;$/;"	d
d	mkdir.asm	/^  d = dst;$/;"	d
d	rm.asm	/^  d = dst;$/;"	d
d	sh.asm	/^  d = dst;$/;"	d
d	usertests.asm	/^  d = dst;$/;"	d
d	wc.asm	/^  d = dst;$/;"	d
d	zombie.asm	/^  d = dst;$/;"	d
d0	echo.asm	/^  d0:	55                   	push   %ebp$/;"	l
d0	grep.asm	/^  d0:	55                   	push   %ebp$/;"	l
d0	kill.asm	/^  d0:	55                   	push   %ebp$/;"	l
d0	ln.asm	/^  d0:	40                   	inc    %eax$/;"	l
d0	mkdir.asm	/^  d0:	55                   	push   %ebp$/;"	l
d0	rm.asm	/^  d0:	55                   	push   %ebp$/;"	l
d0	sh.asm	/^      d0:	55                   	push   %ebp$/;"	l
d0	usertests.asm	/^      d0:	31 db                	xor    %ebx,%ebx$/;"	l
d0	zombie.asm	/^  d0:	38 ca                	cmp    %cl,%dl$/;"	l
d00	sh.asm	/^     d00:	55                   	push   %ebp$/;"	l
d01	sh.asm	/^     d01:	89 e5                	mov    %esp,%ebp$/;"	l
d03	sh.asm	/^     d03:	83 ec 18             	sub    $0x18,%esp$/;"	l
d04	usertests.asm	/^     d04:	e8 47 1a 00 00       	call   2750 <unlink>$/;"	l
d06	sh.asm	/^     d06:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
d09	sh.asm	/^     d09:	89 75 fc             	mov    %esi,-0x4(%ebp)$/;"	l
d09	usertests.asm	/^     d09:	c7 44 24 04 b2 2e 00 	movl   $0x2eb2,0x4(%esp)$/;"	l
d0c	sh.asm	/^     d0c:	89 5d f8             	mov    %ebx,-0x8(%ebp)$/;"	l
d0f	sh.asm	/^     d0f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)$/;"	l
d1	echo.asm	/^  d1:	89 e5                	mov    %esp,%ebp$/;"	l
d1	grep.asm	/^  d1:	89 e5                	mov    %esp,%ebp$/;"	l
d1	kill.asm	/^  d1:	89 e5                	mov    %esp,%ebp$/;"	l
d1	ln.asm	/^  d1:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)$/;"	l
d1	ls.asm	/^  d1:	89 04 24             	mov    %eax,(%esp)$/;"	l
d1	mkdir.asm	/^  d1:	31 c0                	xor    %eax,%eax$/;"	l
d1	rm.asm	/^  d1:	31 c0                	xor    %eax,%eax$/;"	l
d1	sh.asm	/^      d1:	89 e5                	mov    %esp,%ebp$/;"	l
d10	usertests.asm	/^     d10:	00 $/;"	l
d11	usertests.asm	/^     d11:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)$/;"	l
d16	sh.asm	/^     d16:	00 $/;"	l
d17	sh.asm	/^     d17:	89 04 24             	mov    %eax,(%esp)$/;"	l
d18	usertests.asm	/^     d18:	e8 33 1b 00 00       	call   2850 <printf>$/;"	l
d1a	sh.asm	/^     d1a:	e8 e1 00 00 00       	call   e00 <open>$/;"	l
d1d	usertests.asm	/^     d1d:	83 c4 0c             	add    $0xc,%esp$/;"	l
d1f	sh.asm	/^     d1f:	89 c6                	mov    %eax,%esi$/;"	l
d2	usertests.asm	/^      d2:	c7 44 24 04 8b 2b 00 	movl   $0x2b8b,0x4(%esp)$/;"	l
d2	wc.asm	/^  d2:	e8 e9 03 00 00       	call   4c0 <printf>$/;"	l
d2	zombie.asm	/^  d2:	74 0a                	je     de <strchr+0x1e>$/;"	l
d20	usertests.asm	/^     d20:	5b                   	pop    %ebx$/;"	l
d21	sh.asm	/^     d21:	b8 ff ff ff ff       	mov    $0xffffffff,%eax$/;"	l
d21	usertests.asm	/^     d21:	5e                   	pop    %esi$/;"	l
d22	usertests.asm	/^     d22:	5f                   	pop    %edi$/;"	l
d23	usertests.asm	/^     d23:	c9                   	leave  $/;"	l
d24	usertests.asm	/^     d24:	c3                   	ret    $/;"	l
d25	usertests.asm	/^     d25:	c7 44 24 04 20 2e 00 	movl   $0x2e20,0x4(%esp)$/;"	l
d26	sh.asm	/^     d26:	85 f6                	test   %esi,%esi$/;"	l
d28	sh.asm	/^     d28:	78 1b                	js     d45 <stat+0x45>$/;"	l
d2a	sh.asm	/^     d2a:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
d2c	usertests.asm	/^     d2c:	00 $/;"	l
d2d	sh.asm	/^     d2d:	89 34 24             	mov    %esi,(%esp)$/;"	l
d2d	usertests.asm	/^     d2d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)$/;"	l
d3	cat.asm	/^  d3:	00 $/;"	l
d3	echo.asm	/^  d3:	53                   	push   %ebx$/;"	l
d3	grep.asm	/^  d3:	56                   	push   %esi$/;"	l
d3	kill.asm	/^  d3:	53                   	push   %ebx$/;"	l
d3	mkdir.asm	/^  d3:	89 e5                	mov    %esp,%ebp$/;"	l
d3	rm.asm	/^  d3:	89 e5                	mov    %esp,%ebp$/;"	l
d3	sh.asm	/^      d3:	53                   	push   %ebx$/;"	l
d30	sh.asm	/^     d30:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
d34	sh.asm	/^     d34:	e8 df 00 00 00       	call   e18 <fstat>$/;"	l
d34	usertests.asm	/^     d34:	e8 17 1b 00 00       	call   2850 <printf>$/;"	l
d39	sh.asm	/^     d39:	89 c3                	mov    %eax,%ebx$/;"	l
d39	usertests.asm	/^     d39:	83 c4 0c             	add    $0xc,%esp$/;"	l
d3b	sh.asm	/^     d3b:	89 34 24             	mov    %esi,(%esp)$/;"	l
d3c	usertests.asm	/^     d3c:	5b                   	pop    %ebx$/;"	l
d3d	usertests.asm	/^     d3d:	5e                   	pop    %esi$/;"	l
d3e	sh.asm	/^     d3e:	e8 a5 00 00 00       	call   de8 <close>$/;"	l
d3e	usertests.asm	/^     d3e:	5f                   	pop    %edi$/;"	l
d3f	usertests.asm	/^     d3f:	c9                   	leave  $/;"	l
d4	cat.asm	/^  d4:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)$/;"	l
d4	echo.asm	/^  d4:	8b 5d 08             	mov    0x8(%ebp),%ebx$/;"	l
d4	grep.asm	/^  d4:	53                   	push   %ebx$/;"	l
d4	kill.asm	/^  d4:	8b 5d 08             	mov    0x8(%ebp),%ebx$/;"	l
d4	ls.asm	/^  d4:	89 7c 24 04          	mov    %edi,0x4(%esp)$/;"	l
d4	sh.asm	/^      d4:	83 ec 24             	sub    $0x24,%esp$/;"	l
d4	zombie.asm	/^  d4:	40                   	inc    %eax$/;"	l
d40	usertests.asm	/^     d40:	c3                   	ret    $/;"	l
d41	usertests.asm	/^     d41:	89 44 24 08          	mov    %eax,0x8(%esp)$/;"	l
d43	sh.asm	/^     d43:	89 d8                	mov    %ebx,%eax$/;"	l
d45	sh.asm	/^     d45:	8b 5d f8             	mov    -0x8(%ebp),%ebx$/;"	l
d45	usertests.asm	/^     d45:	c7 44 24 04 bf 2e 00 	movl   $0x2ebf,0x4(%esp)$/;"	l
d48	sh.asm	/^     d48:	8b 75 fc             	mov    -0x4(%ebp),%esi$/;"	l
d4b	sh.asm	/^     d4b:	c9                   	leave  $/;"	l
d4c	sh.asm	/^     d4c:	c3                   	ret    $/;"	l
d4c	usertests.asm	/^     d4c:	00 $/;"	l
d4d	sh.asm	/^     d4d:	8d 76 00             	lea    0x0(%esi),%esi$/;"	l
d4d	usertests.asm	/^     d4d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)$/;"	l
d5	grep.asm	/^  d5:	83 ec 10             	sub    $0x10,%esp$/;"	l
d5	ln.asm	/^  d5:	75 f9                	jne    d0 <strlen+0x10>$/;"	l
d5	mkdir.asm	/^  d5:	8b 55 08             	mov    0x8(%ebp),%edx$/;"	l
d5	rm.asm	/^  d5:	8b 55 08             	mov    0x8(%ebp),%edx$/;"	l
d5	zombie.asm	/^  d5:	0f b6 10             	movzbl (%eax),%edx$/;"	l
d50	sh.asm	/^     d50:	55                   	push   %ebp$/;"	l
d51	sh.asm	/^     d51:	89 e5                	mov    %esp,%ebp$/;"	l
d53	sh.asm	/^     d53:	53                   	push   %ebx$/;"	l
d54	sh.asm	/^     d54:	31 db                	xor    %ebx,%ebx$/;"	l
d54	usertests.asm	/^     d54:	e8 f7 1a 00 00       	call   2850 <printf>$/;"	l
d56	sh.asm	/^     d56:	8b 4d 08             	mov    0x8(%ebp),%ecx$/;"	l
d59	sh.asm	/^     d59:	eb 17                	jmp    d72 <atoi+0x22>$/;"	l
d59	usertests.asm	/^     d59:	e8 a2 19 00 00       	call   2700 <exit>$/;"	l
d5b	sh.asm	/^     d5b:	90                   	nop    $/;"	l
d5c	sh.asm	/^     d5c:	8d 74 26 00          	lea    0x0(%esi),%esi$/;"	l
d5e	usertests.asm	/^     d5e:	c7 44 24 04 4f 31 00 	movl   $0x314f,0x4(%esp)$/;"	l
d6	forktest.asm	/^  d6:	00 $/;"	l
d6	init.asm	/^  d6:	e8 5d 02 00 00       	call   338 <mknod>$/;"	l
d60	sh.asm	/^     d60:	89 d8                	mov    %ebx,%eax$/;"	l
d62	sh.asm	/^     d62:	bb 0a 00 00 00       	mov    $0xa,%ebx$/;"	l
d65	usertests.asm	/^     d65:	00 $/;"	l
d66	usertests.asm	/^     d66:	e9 2f ff ff ff       	jmp    c9a <twofiles+0x14a>$/;"	l
d67	sh.asm	/^     d67:	0f be d2             	movsbl %dl,%edx$/;"	l
d6a	sh.asm	/^     d6a:	0f af c3             	imul   %ebx,%eax$/;"	l
d6b	usertests.asm	/^     d6b:	89 7c 24 08          	mov    %edi,0x8(%esp)$/;"	l
d6d	sh.asm	/^     d6d:	41                   	inc    %ecx$/;"	l
d6e	sh.asm	/^     d6e:	8d 5c 10 d0          	lea    -0x30(%eax,%edx,1),%ebx$/;"	l
d6f	usertests.asm	/^     d6f:	c7 44 24 04 d0 2e 00 	movl   $0x2ed0,0x4(%esp)$/;"	l
d7	echo.asm	/^  d7:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
d7	forktest.asm	/^  d7:	eb db                	jmp    b4 <forktest+0x84>$/;"	l
d7	kill.asm	/^  d7:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
d7	ln.asm	/^  d7:	c9                   	leave  $/;"	l
d7	sh.asm	/^      d7:	8b 5d 08             	mov    0x8(%ebp),%ebx$/;"	l
d7	wc.asm	/^  d7:	e8 94 02 00 00       	call   370 <exit>$/;"	l
d72	sh.asm	/^     d72:	0f b6 11             	movzbl (%ecx),%edx$/;"	l
d75	sh.asm	/^     d75:	8d 42 d0             	lea    -0x30(%edx),%eax$/;"	l
d76	usertests.asm	/^     d76:	00 $/;"	l
d77	usertests.asm	/^     d77:	eb d4                	jmp    d4d <twofiles+0x1fd>$/;"	l
d78	sh.asm	/^     d78:	3c 09                	cmp    $0x9,%al$/;"	l
d79	usertests.asm	/^     d79:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi$/;"	l
d7a	sh.asm	/^     d7a:	76 e4                	jbe    d60 <atoi+0x10>$/;"	l
d7c	sh.asm	/^     d7c:	89 d8                	mov    %ebx,%eax$/;"	l
d7e	sh.asm	/^     d7e:	5b                   	pop    %ebx$/;"	l
d7f	sh.asm	/^     d7f:	c9                   	leave  $/;"	l
d8	grep.asm	/^  d8:	8b 75 08             	mov    0x8(%ebp),%esi$/;"	l
d8	ln.asm	/^  d8:	c3                   	ret    $/;"	l
d8	ls.asm	/^  d8:	e8 7b 04 00 00       	call   558 <fstat>$/;"	l
d8	mkdir.asm	/^  d8:	80 3a 00             	cmpb   $0x0,(%edx)$/;"	l
d8	rm.asm	/^  d8:	80 3a 00             	cmpb   $0x0,(%edx)$/;"	l
d8	zombie.asm	/^  d8:	84 d2                	test   %dl,%dl$/;"	l
d80	sh.asm	/^     d80:	c3                   	ret    $/;"	l
d80	usertests.asm	/^     d80:	55                   	push   %ebp$/;"	l
d81	sh.asm	/^     d81:	eb 0d                	jmp    d90 <memmove>$/;"	l
d81	usertests.asm	/^     d81:	89 e5                	mov    %esp,%ebp$/;"	l
d83	sh.asm	/^     d83:	90                   	nop    $/;"	l
d83	usertests.asm	/^     d83:	57                   	push   %edi$/;"	l
d84	sh.asm	/^     d84:	90                   	nop    $/;"	l
d84	usertests.asm	/^     d84:	56                   	push   %esi$/;"	l
d85	sh.asm	/^     d85:	90                   	nop    $/;"	l
d85	usertests.asm	/^     d85:	53                   	push   %ebx$/;"	l
d86	sh.asm	/^     d86:	90                   	nop    $/;"	l
d86	usertests.asm	/^     d86:	83 ec 3c             	sub    $0x3c,%esp$/;"	l
d87	sh.asm	/^     d87:	90                   	nop    $/;"	l
d88	sh.asm	/^     d88:	90                   	nop    $/;"	l
d89	sh.asm	/^     d89:	90                   	nop    $/;"	l
d89	usertests.asm	/^     d89:	c7 44 24 04 e1 2e 00 	movl   $0x2ee1,0x4(%esp)$/;"	l
d8a	sh.asm	/^     d8a:	90                   	nop    $/;"	l
d8b	sh.asm	/^     d8b:	90                   	nop    $/;"	l
d8c	sh.asm	/^     d8c:	90                   	nop    $/;"	l
d8d	sh.asm	/^     d8d:	90                   	nop    $/;"	l
d8e	sh.asm	/^     d8e:	90                   	nop    $/;"	l
d8f	sh.asm	/^     d8f:	90                   	nop    $/;"	l
d9	forktest.asm	/^  d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi$/;"	l
d9	ln.asm	/^  d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi$/;"	l
d9	usertests.asm	/^      d9:	00 $/;"	l
d90	sh.asm	/^     d90:	55                   	push   %ebp$/;"	l
d90	usertests.asm	/^     d90:	00 $/;"	l
d91	sh.asm	/^     d91:	89 e5                	mov    %esp,%ebp$/;"	l
d91	usertests.asm	/^     d91:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)$/;"	l
d93	sh.asm	/^     d93:	56                   	push   %esi$/;"	l
d94	sh.asm	/^     d94:	8b 75 08             	mov    0x8(%ebp),%esi$/;"	l
d97	sh.asm	/^     d97:	8b 55 0c             	mov    0xc(%ebp),%edx$/;"	l
d98	usertests.asm	/^     d98:	e8 b3 1a 00 00       	call   2850 <printf>$/;"	l
d9a	sh.asm	/^     d9a:	53                   	push   %ebx$/;"	l
d9b	sh.asm	/^     d9b:	8b 5d 10             	mov    0x10(%ebp),%ebx$/;"	l
d9d	usertests.asm	/^     d9d:	e8 56 19 00 00       	call   26f8 <fork>$/;"	l
d9e	sh.asm	/^     d9e:	89 f1                	mov    %esi,%ecx$/;"	l
da	echo.asm	/^  da:	8b 55 10             	mov    0x10(%ebp),%edx$/;"	l
da	kill.asm	/^  da:	8b 55 10             	mov    0x10(%ebp),%edx$/;"	l
da	sh.asm	/^      da:	85 db                	test   %ebx,%ebx$/;"	l
da	usertests.asm	/^      da:	89 04 24             	mov    %eax,(%esp)$/;"	l
da	zombie.asm	/^  da:	75 f4                	jne    d0 <strchr+0x10>$/;"	l
da0	sh.asm	/^     da0:	eb 07                	jmp    da9 <memmove+0x19>$/;"	l
da2	sh.asm	/^     da2:	0f b6 02             	movzbl (%edx),%eax$/;"	l
da2	usertests.asm	/^     da2:	85 c0                	test   %eax,%eax$/;"	l
da4	usertests.asm	/^     da4:	89 c6                	mov    %eax,%esi$/;"	l
da5	sh.asm	/^     da5:	42                   	inc    %edx$/;"	l
da6	sh.asm	/^     da6:	88 01                	mov    %al,(%ecx)$/;"	l
da6	usertests.asm	/^     da6:	0f 8c c8 01 00 00    	jl     f74 <createdelete+0x1f4>$/;"	l
da8	sh.asm	/^     da8:	41                   	inc    %ecx$/;"	l
da9	sh.asm	/^     da9:	89 d8                	mov    %ebx,%eax$/;"	l
dab	sh.asm	/^     dab:	4b                   	dec    %ebx$/;"	l
dac	sh.asm	/^     dac:	85 c0                	test   %eax,%eax$/;"	l
dac	usertests.asm	/^     dac:	83 f8 01             	cmp    $0x1,%eax$/;"	l
dae	sh.asm	/^     dae:	7f f2                	jg     da2 <memmove+0x12>$/;"	l
daf	usertests.asm	/^     daf:	8d 7d c8             	lea    -0x38(%ebp),%edi$/;"	l
data	buf.h	/^  uchar data[512];$/;"	m	struct:buf
data	ioapic.c	/^  uint data;$/;"	m	struct:ioapic	file:
data	kernel.asm	/^    data = (shift & E0ESC ? data : data & 0x7F);$/;"	d
data	kernel.asm	/^  data = inb(KBDATAP);$/;"	d
data	pipe.c	/^  char data[PIPESIZE];$/;"	m	struct:pipe	file:
db	cat.asm	/^  db:	89 44 24 08          	mov    %eax,0x8(%esp)$/;"	l
db	grep.asm	/^  db:	8b 5d 0c             	mov    0xc(%ebp),%ebx$/;"	l
db	init.asm	/^  db:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)$/;"	l
db	mkdir.asm	/^  db:	eb 08                	jmp    e5 <strlen+0x15>$/;"	l
db	mmu.h	/^  uint db : 1;         \/\/ 0 = 16-bit segment, 1 = 32-bit segment$/;"	m	struct:segdesc
db	rm.asm	/^  db:	eb 08                	jmp    e5 <strlen+0x15>$/;"	l
db0	sh.asm	/^     db0:	5b                   	pop    %ebx$/;"	l
db1	sh.asm	/^     db1:	89 f0                	mov    %esi,%eax$/;"	l
db2	usertests.asm	/^     db2:	c6 45 ca 00          	movb   $0x0,-0x36(%ebp)$/;"	l
db3	sh.asm	/^     db3:	5e                   	pop    %esi$/;"	l
db4	sh.asm	/^     db4:	c9                   	leave  $/;"	l
db5	sh.asm	/^     db5:	c3                   	ret    $/;"	l
db6	sh.asm	/^     db6:	90                   	nop    $/;"	l
db6	usertests.asm	/^     db6:	19 c0                	sbb    %eax,%eax$/;"	l
db7	sh.asm	/^     db7:	90                   	nop    $/;"	l
db8	sh.asm	/^     db8:	b8 01 00 00 00       	mov    $0x1,%eax$/;"	l
db8	usertests.asm	/^     db8:	31 db                	xor    %ebx,%ebx$/;"	l
dba	usertests.asm	/^     dba:	83 e0 f3             	and    $0xfffffff3,%eax$/;"	l
dbd	sh.asm	/^     dbd:	cd 30                	int    $0x30$/;"	l
dbd	usertests.asm	/^     dbd:	83 c0 70             	add    $0x70,%eax$/;"	l
dbf	sh.asm	/^     dbf:	c3                   	ret    $/;"	l
dbg	kalloc.c	/^uint dbg = 0;$/;"	v
dc	sh.asm	/^      dc:	74 4f                	je     12d <runcmd+0x5d>$/;"	l
dc	wc.asm	/^  dc:	8d 74 26 00          	lea    0x0(%esi),%esi$/;"	l
dc	zombie.asm	/^  dc:	31 c0                	xor    %eax,%eax$/;"	l
dc0	sh.asm	/^     dc0:	b8 02 00 00 00       	mov    $0x2,%eax$/;"	l
dc0	usertests.asm	/^     dc0:	88 45 c8             	mov    %al,-0x38(%ebp)$/;"	l
dc3	usertests.asm	/^     dc3:	eb 06                	jmp    dcb <createdelete+0x4b>$/;"	l
dc5	sh.asm	/^     dc5:	cd 30                	int    $0x30$/;"	l
dc5	usertests.asm	/^     dc5:	43                   	inc    %ebx$/;"	l
dc6	usertests.asm	/^     dc6:	83 fb 13             	cmp    $0x13,%ebx$/;"	l
dc7	sh.asm	/^     dc7:	c3                   	ret    $/;"	l
dc8	sh.asm	/^     dc8:	b8 03 00 00 00       	mov    $0x3,%eax$/;"	l
dc9	usertests.asm	/^     dc9:	7f 58                	jg     e23 <createdelete+0xa3>$/;"	l
dcb	usertests.asm	/^     dcb:	8d 43 30             	lea    0x30(%ebx),%eax$/;"	l
dcd	sh.asm	/^     dcd:	cd 30                	int    $0x30$/;"	l
dce	usertests.asm	/^     dce:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)$/;"	l
dcf	sh.asm	/^     dcf:	c3                   	ret    $/;"	l
dd	echo.asm	/^  dd:	89 d9                	mov    %ebx,%ecx$/;"	l
dd	kill.asm	/^  dd:	89 d9                	mov    %ebx,%ecx$/;"	l
dd	ls.asm	/^  dd:	85 c0                	test   %eax,%eax$/;"	l
dd	mkdir.asm	/^  dd:	8d 76 00             	lea    0x0(%esi),%esi$/;"	l
dd	rm.asm	/^  dd:	8d 76 00             	lea    0x0(%esi),%esi$/;"	l
dd	usertests.asm	/^      dd:	e8 6e 27 00 00       	call   2850 <printf>$/;"	l
dd0	sh.asm	/^     dd0:	b8 04 00 00 00       	mov    $0x4,%eax$/;"	l
dd5	sh.asm	/^     dd5:	cd 30                	int    $0x30$/;"	l
dd5	usertests.asm	/^     dd5:	00 $/;"	l
dd6	usertests.asm	/^     dd6:	89 3c 24             	mov    %edi,(%esp)$/;"	l
dd7	sh.asm	/^     dd7:	c3                   	ret    $/;"	l
dd8	sh.asm	/^     dd8:	b8 06 00 00 00       	mov    $0x6,%eax$/;"	l
dd9	usertests.asm	/^     dd9:	88 45 c9             	mov    %al,-0x37(%ebp)$/;"	l
ddc	usertests.asm	/^     ddc:	e8 5f 19 00 00       	call   2740 <open>$/;"	l
ddd	sh.asm	/^     ddd:	cd 30                	int    $0x30$/;"	l
ddf	sh.asm	/^     ddf:	c3                   	ret    $/;"	l
de	grep.asm	/^  de:	80 3e 5e             	cmpb   $0x5e,(%esi)$/;"	l
de	sh.asm	/^      de:	8b 03                	mov    (%ebx),%eax$/;"	l
de	zombie.asm	/^  de:	c9                   	leave  $/;"	l
de0	sh.asm	/^     de0:	b8 05 00 00 00       	mov    $0x5,%eax$/;"	l
de1	usertests.asm	/^     de1:	85 c0                	test   %eax,%eax$/;"	l
de3	usertests.asm	/^     de3:	0f 88 47 01 00 00    	js     f30 <createdelete+0x1b0>$/;"	l
de5	sh.asm	/^     de5:	cd 30                	int    $0x30$/;"	l
de7	sh.asm	/^     de7:	c3                   	ret    $/;"	l
de8	sh.asm	/^     de8:	b8 07 00 00 00       	mov    $0x7,%eax$/;"	l
de9	usertests.asm	/^     de9:	89 04 24             	mov    %eax,(%esp)$/;"	l
dec	usertests.asm	/^     dec:	e8 37 19 00 00       	call   2728 <close>$/;"	l
ded	sh.asm	/^     ded:	cd 30                	int    $0x30$/;"	l
def	sh.asm	/^     def:	c3                   	ret    $/;"	l
default	kernel.asm	/^      default:$/;"	l
default	kernel.asm	/^    default:$/;"	l
default	kernel.asm	/^  default:$/;"	l
default	sh.asm	/^  default:$/;"	l
dev	buf.h	/^  uint dev;$/;"	m	struct:buf
dev	fsvar.h	/^  uint dev;           \/\/ Device number$/;"	m	struct:inode
dev	stat.h	/^  int dev;     \/\/ Device number$/;"	m	struct:stat
devsw	dev.h	/^struct devsw {$/;"	s
devsw	file.c	/^struct devsw devsw[NDEV];$/;"	v	typeref:struct:devsw
df	cat.asm	/^  df:	e8 5c 03 00 00       	call   440 <printf>$/;"	l
df	echo.asm	/^  df:	eb 03                	jmp    e4 <memset+0x14>$/;"	l
df	kill.asm	/^  df:	eb 03                	jmp    e4 <memset+0x14>$/;"	l
df	ls.asm	/^  df:	0f 88 ba 00 00 00    	js     19f <ls+0xff>$/;"	l
df	zombie.asm	/^  df:	90                   	nop    $/;"	l
df0	sh.asm	/^     df0:	b8 08 00 00 00       	mov    $0x8,%eax$/;"	l
df1	usertests.asm	/^     df1:	85 db                	test   %ebx,%ebx$/;"	l
df3	usertests.asm	/^     df3:	7e d0                	jle    dc5 <createdelete+0x45>$/;"	l
df5	sh.asm	/^     df5:	cd 30                	int    $0x30$/;"	l
df5	usertests.asm	/^     df5:	f6 c3 01             	test   $0x1,%bl$/;"	l
df7	sh.asm	/^     df7:	c3                   	ret    $/;"	l
df8	sh.asm	/^     df8:	b8 09 00 00 00       	mov    $0x9,%eax$/;"	l
df8	usertests.asm	/^     df8:	75 cb                	jne    dc5 <createdelete+0x45>$/;"	l
dfa	usertests.asm	/^     dfa:	89 d8                	mov    %ebx,%eax$/;"	l
dfc	usertests.asm	/^     dfc:	89 3c 24             	mov    %edi,(%esp)$/;"	l
dfd	sh.asm	/^     dfd:	cd 30                	int    $0x30$/;"	l
dff	sh.asm	/^     dff:	c3                   	ret    $/;"	l
dff	usertests.asm	/^     dff:	c1 e8 1f             	shr    $0x1f,%eax$/;"	l
dinode	fs.h	/^struct dinode {$/;"	s
dip	kernel.asm	/^    dip = (struct dinode*)bp->data + inum%IPB;$/;"	d
dip	kernel.asm	/^    dip = (struct dinode*)bp->data + ip->inum%IPB;$/;"	d
dip	kernel.asm	/^  dip = (struct dinode*)bp->data + ip->inum%IPB;$/;"	d
dirent	fs.h	/^struct dirent {$/;"	s
dirfile	usertests.c	/^dirfile(void)$/;"	f
dirlink	fs.c	/^dirlink(struct inode *dp, char *name, uint ino)$/;"	f
dirlookup	fs.c	/^dirlookup(struct inode *dp, char *name, uint *poff)$/;"	f
dirtest	usertests.c	/^void dirtest(void)$/;"	f
disk_1_present	ide.c	/^static int disk_1_present;$/;"	v	file:
disk_1_present	kernel.asm	/^      disk_1_present = 1;$/;"	d
dpl	mmu.h	/^  uint dpl : 2;         \/\/ descriptor(meaning new) privilege level$/;"	m	struct:gatedesc
dpl	mmu.h	/^  uint dpl : 2;        \/\/ Descriptor Privilege Level$/;"	m	struct:segdesc
ds	mmu.h	/^  ushort ds;$/;"	m	struct:taskstate
ds	x86.h	/^  ushort ds;$/;"	m	struct:trapframe
dst	cat.asm	/^  dst = vdst;$/;"	d
dst	echo.asm	/^  dst = vdst;$/;"	d
dst	forktest.asm	/^  dst = vdst;$/;"	d
dst	grep.asm	/^  dst = vdst;$/;"	d
dst	init.asm	/^  dst = vdst;$/;"	d
dst	kill.asm	/^  dst = vdst;$/;"	d
dst	ln.asm	/^  dst = vdst;$/;"	d
dst	ls.asm	/^  dst = vdst;$/;"	d
dst	mkdir.asm	/^  dst = vdst;$/;"	d
dst	rm.asm	/^  dst = vdst;$/;"	d
dst	sh.asm	/^  dst = vdst;$/;"	d
dst	usertests.asm	/^  dst = vdst;$/;"	d
dst	wc.asm	/^  dst = vdst;$/;"	d
dst	zombie.asm	/^  dst = vdst;$/;"	d
e	console.c	/^  uint e;  \/\/ Edit index$/;"	m	struct:__anon1	file:
e	echo.asm	/^   e:	8b 75 08             	mov    0x8(%ebp),%esi$/;"	l
e	kernel.asm	/^  e = addr+len;$/;"	d
e	ls.asm	/^   e:	e8 4d 03 00 00       	call   360 <strlen>$/;"	l
e0	forktest.asm	/^  e0:	55                   	push   %ebp$/;"	l
e0	ln.asm	/^  e0:	55                   	push   %ebp$/;"	l
e0	mkdir.asm	/^  e0:	40                   	inc    %eax$/;"	l
e0	rm.asm	/^  e0:	40                   	inc    %eax$/;"	l
e0	sh.asm	/^      e0:	83 f8 05             	cmp    $0x5,%eax$/;"	l
e0	wc.asm	/^  e0:	55                   	push   %ebp$/;"	l
e0	zombie.asm	/^  e0:	c3                   	ret    $/;"	l
e00	sh.asm	/^     e00:	b8 0a 00 00 00       	mov    $0xa,%eax$/;"	l
e02	usertests.asm	/^     e02:	8d 04 03             	lea    (%ebx,%eax,1),%eax$/;"	l
e05	sh.asm	/^     e05:	cd 30                	int    $0x30$/;"	l
e05	usertests.asm	/^     e05:	d1 f8                	sar    %eax$/;"	d
e07	sh.asm	/^     e07:	c3                   	ret    $/;"	l
e07	usertests.asm	/^     e07:	83 c0 30             	add    $0x30,%eax$/;"	l
e08	sh.asm	/^     e08:	b8 0b 00 00 00       	mov    $0xb,%eax$/;"	l
e0a	usertests.asm	/^     e0a:	88 45 c9             	mov    %al,-0x37(%ebp)$/;"	l
e0d	sh.asm	/^     e0d:	cd 30                	int    $0x30$/;"	l
e0d	usertests.asm	/^     e0d:	e8 3e 19 00 00       	call   2750 <unlink>$/;"	l
e0f	sh.asm	/^     e0f:	c3                   	ret    $/;"	l
e1	echo.asm	/^  e1:	88 01                	mov    %al,(%ecx)$/;"	l
e1	forktest.asm	/^  e1:	89 e5                	mov    %esp,%ebp$/;"	l
e1	grep.asm	/^  e1:	74 21                	je     104 <match+0x34>$/;"	l
e1	kill.asm	/^  e1:	88 01                	mov    %al,(%ecx)$/;"	l
e1	ln.asm	/^  e1:	89 e5                	mov    %esp,%ebp$/;"	l
e1	mkdir.asm	/^  e1:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)$/;"	l
e1	rm.asm	/^  e1:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)$/;"	l
e1	wc.asm	/^  e1:	89 e5                	mov    %esp,%ebp$/;"	l
e1	zombie.asm	/^  e1:	eb 0d                	jmp    f0 <gets>$/;"	l
e10	sh.asm	/^     e10:	b8 0c 00 00 00       	mov    $0xc,%eax$/;"	l
e12	usertests.asm	/^     e12:	85 c0                	test   %eax,%eax$/;"	l
e14	usertests.asm	/^     e14:	79 af                	jns    dc5 <createdelete+0x45>$/;"	l
e15	sh.asm	/^     e15:	cd 30                	int    $0x30$/;"	l
e16	usertests.asm	/^     e16:	c7 44 24 04 f4 2e 00 	movl   $0x2ef4,0x4(%esp)$/;"	l
e17	sh.asm	/^     e17:	c3                   	ret    $/;"	l
e18	sh.asm	/^     e18:	b8 0d 00 00 00       	mov    $0xd,%eax$/;"	l
e1d	sh.asm	/^     e1d:	cd 30                	int    $0x30$/;"	l
e1d	usertests.asm	/^     e1d:	00 $/;"	l
e1e	usertests.asm	/^     e1e:	e9 15 01 00 00       	jmp    f38 <createdelete+0x1b8>$/;"	l
e1f	sh.asm	/^     e1f:	c3                   	ret    $/;"	l
e2	init.asm	/^  e2:	00 $/;"	l
e2	usertests.asm	/^      e2:	eb 43                	jmp    127 <writetest+0x97>$/;"	l
e20	sh.asm	/^     e20:	b8 0e 00 00 00       	mov    $0xe,%eax$/;"	l
e23	usertests.asm	/^     e23:	85 f6                	test   %esi,%esi$/;"	l
e25	sh.asm	/^     e25:	cd 30                	int    $0x30$/;"	l
e25	usertests.asm	/^     e25:	0f 84 19 01 00 00    	je     f44 <createdelete+0x1c4>$/;"	l
e27	sh.asm	/^     e27:	c3                   	ret    $/;"	l
e28	sh.asm	/^     e28:	b8 0f 00 00 00       	mov    $0xf,%eax$/;"	l
e2b	usertests.asm	/^     e2b:	31 db                	xor    %ebx,%ebx$/;"	l
e2d	sh.asm	/^     e2d:	cd 30                	int    $0x30$/;"	l
e2d	usertests.asm	/^     e2d:	e8 d6 18 00 00       	call   2708 <wait>$/;"	l
e2f	sh.asm	/^     e2f:	c3                   	ret    $/;"	l
e3	echo.asm	/^  e3:	41                   	inc    %ecx$/;"	l
e3	forktest.asm	/^  e3:	83 ec 08             	sub    $0x8,%esp$/;"	l
e3	grep.asm	/^  e3:	89 5c 24 04          	mov    %ebx,0x4(%esp)$/;"	l
e3	init.asm	/^  e3:	c7 04 24 ef 06 00 00 	movl   $0x6ef,(%esp)$/;"	l
e3	kill.asm	/^  e3:	41                   	inc    %ecx$/;"	l
e3	ln.asm	/^  e3:	53                   	push   %ebx$/;"	l
e3	sh.asm	/^      e3:	77 0b                	ja     f0 <runcmd+0x20>$/;"	l
e3	wc.asm	/^  e3:	57                   	push   %edi$/;"	l
e3	zombie.asm	/^  e3:	90                   	nop    $/;"	l
e30	sh.asm	/^     e30:	b8 10 00 00 00       	mov    $0x10,%eax$/;"	l
e32	usertests.asm	/^     e32:	8d 43 30             	lea    0x30(%ebx),%eax$/;"	l
e35	sh.asm	/^     e35:	cd 30                	int    $0x30$/;"	l
e35	usertests.asm	/^     e35:	c6 45 c8 70          	movb   $0x70,-0x38(%ebp)$/;"	l
e37	sh.asm	/^     e37:	c3                   	ret    $/;"	l
e38	sh.asm	/^     e38:	b8 11 00 00 00       	mov    $0x11,%eax$/;"	l
e39	usertests.asm	/^     e39:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)$/;"	l
e3d	sh.asm	/^     e3d:	cd 30                	int    $0x30$/;"	l
e3f	sh.asm	/^     e3f:	c3                   	ret    $/;"	l
e4	cat.asm	/^  e4:	e8 07 02 00 00       	call   2f0 <exit>$/;"	l
e4	echo.asm	/^  e4:	4a                   	dec    %edx$/;"	l
e4	kill.asm	/^  e4:	4a                   	dec    %edx$/;"	l
e4	ln.asm	/^  e4:	8b 5d 08             	mov    0x8(%ebp),%ebx$/;"	l
e4	usertests.asm	/^      e4:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)$/;"	l
e4	wc.asm	/^  e4:	56                   	push   %esi$/;"	l
e4	zombie.asm	/^  e4:	90                   	nop    $/;"	l
e40	sh.asm	/^     e40:	b8 12 00 00 00       	mov    $0x12,%eax$/;"	l
e40	usertests.asm	/^     e40:	00 $/;"	l
e41	usertests.asm	/^     e41:	89 3c 24             	mov    %edi,(%esp)$/;"	l
e44	usertests.asm	/^     e44:	88 45 c9             	mov    %al,-0x37(%ebp)$/;"	l
e45	sh.asm	/^     e45:	cd 30                	int    $0x30$/;"	l
e47	sh.asm	/^     e47:	c3                   	ret    $/;"	l
e47	usertests.asm	/^     e47:	e8 f4 18 00 00       	call   2740 <open>$/;"	l
e48	sh.asm	/^     e48:	b8 13 00 00 00       	mov    $0x13,%eax$/;"	l
e4c	usertests.asm	/^     e4c:	85 db                	test   %ebx,%ebx$/;"	l
e4d	sh.asm	/^     e4d:	cd 30                	int    $0x30$/;"	l
e4e	usertests.asm	/^     e4e:	89 c1                	mov    %eax,%ecx$/;"	l
e4f	sh.asm	/^     e4f:	c3                   	ret    $/;"	l
e5	echo.asm	/^  e5:	83 fa ff             	cmp    $0xffffffff,%edx$/;"	l
e5	kill.asm	/^  e5:	83 fa ff             	cmp    $0xffffffff,%edx$/;"	l
e5	ls.asm	/^  e5:	0f bf 85 d0 fd ff ff 	movswl -0x230(%ebp),%eax$/;"	l
e5	mkdir.asm	/^  e5:	75 f9                	jne    e0 <strlen+0x10>$/;"	l
e5	rm.asm	/^  e5:	75 f9                	jne    e0 <strlen+0x10>$/;"	l
e5	sh.asm	/^      e5:	ff 24 85 74 12 00 00 	jmp    *0x1274(,%eax,4)$/;"	l
e5	wc.asm	/^  e5:	be 01 00 00 00       	mov    $0x1,%esi$/;"	l
e5	zombie.asm	/^  e5:	90                   	nop    $/;"	l
e50	sh.asm	/^     e50:	b8 14 00 00 00       	mov    $0x14,%eax$/;"	l
e50	usertests.asm	/^     e50:	0f 94 c2             	sete   %dl$/;"	l
e53	usertests.asm	/^     e53:	83 fb 09             	cmp    $0x9,%ebx$/;"	l
e55	sh.asm	/^     e55:	cd 30                	int    $0x30$/;"	l
e56	usertests.asm	/^     e56:	0f 9f c0             	setg   %al$/;"	l
e57	sh.asm	/^     e57:	c3                   	ret    $/;"	l
e58	sh.asm	/^     e58:	90                   	nop    $/;"	l
e59	sh.asm	/^     e59:	90                   	nop    $/;"	l
e59	usertests.asm	/^     e59:	09 d0                	or     %edx,%eax$/;"	l
e5a	sh.asm	/^     e5a:	90                   	nop    $/;"	l
e5b	sh.asm	/^     e5b:	90                   	nop    $/;"	l
e5b	usertests.asm	/^     e5b:	a8 01                	test   $0x1,%al$/;"	l
e5c	sh.asm	/^     e5c:	90                   	nop    $/;"	l
e5d	sh.asm	/^     e5d:	90                   	nop    $/;"	l
e5d	usertests.asm	/^     e5d:	74 08                	je     e67 <createdelete+0xe7>$/;"	l
e5e	sh.asm	/^     e5e:	90                   	nop    $/;"	l
e5f	sh.asm	/^     e5f:	90                   	nop    $/;"	l
e5f	usertests.asm	/^     e5f:	85 c9                	test   %ecx,%ecx$/;"	l
e6	forktest.asm	/^  e6:	83 e4 f0             	and    $0xfffffff0,%esp$/;"	l
e6	zombie.asm	/^  e6:	90                   	nop    $/;"	l
e60	sh.asm	/^     e60:	55                   	push   %ebp$/;"	l
e61	sh.asm	/^     e61:	89 e5                	mov    %esp,%ebp$/;"	l
e61	usertests.asm	/^     e61:	0f 88 ff 00 00 00    	js     f66 <createdelete+0x1e6>$/;"	l
e63	sh.asm	/^     e63:	83 ec 18             	sub    $0x18,%esp$/;"	l
e66	sh.asm	/^     e66:	88 55 ff             	mov    %dl,-0x1(%ebp)$/;"	l
e67	usertests.asm	/^     e67:	8d 73 ff             	lea    -0x1(%ebx),%esi$/;"	l
e69	sh.asm	/^     e69:	8d 55 ff             	lea    -0x1(%ebp),%edx$/;"	l
e6a	usertests.asm	/^     e6a:	89 c8                	mov    %ecx,%eax$/;"	l
e6c	sh.asm	/^     e6c:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)$/;"	l
e6c	usertests.asm	/^     e6c:	f7 d0                	not    %eax$/;"	l
e6e	usertests.asm	/^     e6e:	83 fe 08             	cmp    $0x8,%esi$/;"	l
e7	grep.asm	/^  e7:	89 34 24             	mov    %esi,(%esp)$/;"	l
e7	ln.asm	/^  e7:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
e7	mkdir.asm	/^  e7:	c9                   	leave  $/;"	l
e7	rm.asm	/^  e7:	c9                   	leave  $/;"	l
e7	zombie.asm	/^  e7:	90                   	nop    $/;"	l
e71	usertests.asm	/^     e71:	0f 96 c2             	setbe  %dl$/;"	l
e73	sh.asm	/^     e73:	00 $/;"	l
e74	sh.asm	/^     e74:	89 04 24             	mov    %eax,(%esp)$/;"	l
e74	usertests.asm	/^     e74:	c1 e8 1f             	shr    $0x1f,%eax$/;"	l
e77	sh.asm	/^     e77:	89 54 24 04          	mov    %edx,0x4(%esp)$/;"	l
e77	usertests.asm	/^     e77:	85 d0                	test   %edx,%eax$/;"	l
e79	usertests.asm	/^     e79:	0f 85 ca 00 00 00    	jne    f49 <createdelete+0x1c9>$/;"	l
e7b	sh.asm	/^     e7b:	e8 60 ff ff ff       	call   de0 <write>$/;"	l
e7f	usertests.asm	/^     e7f:	85 c9                	test   %ecx,%ecx$/;"	l
e8	echo.asm	/^  e8:	75 f7                	jne    e1 <memset+0x11>$/;"	l
e8	kill.asm	/^  e8:	75 f7                	jne    e1 <memset+0x11>$/;"	l
e8	mkdir.asm	/^  e8:	c3                   	ret    $/;"	l
e8	rm.asm	/^  e8:	c3                   	ret    $/;"	l
e8	zombie.asm	/^  e8:	90                   	nop    $/;"	l
e80	sh.asm	/^     e80:	c9                   	leave  $/;"	l
e81	sh.asm	/^     e81:	c3                   	ret    $/;"	l
e81	usertests.asm	/^     e81:	78 08                	js     e8b <createdelete+0x10b>$/;"	l
e82	sh.asm	/^     e82:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi$/;"	l
e820_memmap	kalloc.c	/^struct e820map * e820_memmap;$/;"	v	typeref:struct:e820map
e820_memmap	kernel.asm	/^  e820_memmap = (struct e820map *)(0x8000);$/;"	d
e820map	pmap.h	/^struct e820map {$/;"	s
e83	usertests.asm	/^     e83:	89 0c 24             	mov    %ecx,(%esp)$/;"	l
e86	usertests.asm	/^     e86:	e8 9d 18 00 00       	call   2728 <close>$/;"	l
e89	sh.asm	/^     e89:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi$/;"	l
e8b	usertests.asm	/^     e8b:	8d 43 30             	lea    0x30(%ebx),%eax$/;"	l
e8e	usertests.asm	/^     e8e:	c6 45 c8 63          	movb   $0x63,-0x38(%ebp)$/;"	l
e9	cat.asm	/^  e9:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)$/;"	l
e9	forktest.asm	/^  e9:	83 ec 10             	sub    $0x10,%esp$/;"	l
e9	mkdir.asm	/^  e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi$/;"	l
e9	rm.asm	/^  e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi$/;"	l
e9	zombie.asm	/^  e9:	90                   	nop    $/;"	l
e90	sh.asm	/^     e90:	55                   	push   %ebp$/;"	l
e91	sh.asm	/^     e91:	89 e5                	mov    %esp,%ebp$/;"	l
e92	usertests.asm	/^     e92:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)$/;"	l
e93	sh.asm	/^     e93:	57                   	push   %edi$/;"	l
e94	sh.asm	/^     e94:	89 c7                	mov    %eax,%edi$/;"	l
e96	sh.asm	/^     e96:	56                   	push   %esi$/;"	l
e97	sh.asm	/^     e97:	53                   	push   %ebx$/;"	l
e98	sh.asm	/^     e98:	89 d3                	mov    %edx,%ebx$/;"	l
e99	usertests.asm	/^     e99:	00 $/;"	l
e9a	sh.asm	/^     e9a:	89 d8                	mov    %ebx,%eax$/;"	l
e9a	usertests.asm	/^     e9a:	89 3c 24             	mov    %edi,(%esp)$/;"	l
e9c	sh.asm	/^     e9c:	89 d9                	mov    %ebx,%ecx$/;"	l
e9d	usertests.asm	/^     e9d:	88 45 c9             	mov    %al,-0x37(%ebp)$/;"	l
e9e	sh.asm	/^     e9e:	83 ec 2c             	sub    $0x2c,%esp$/;"	l
ea	echo.asm	/^  ea:	89 d8                	mov    %ebx,%eax$/;"	l
ea	grep.asm	/^  ea:	e8 61 ff ff ff       	call   50 <matchhere>$/;"	l
ea	init.asm	/^  ea:	e8 41 02 00 00       	call   330 <open>$/;"	l
ea	kill.asm	/^  ea:	89 d8                	mov    %ebx,%eax$/;"	l
ea	ln.asm	/^  ea:	8b 55 10             	mov    0x10(%ebp),%edx$/;"	l
ea	wc.asm	/^  ea:	53                   	push   %ebx$/;"	l
ea	zombie.asm	/^  ea:	90                   	nop    $/;"	l
ea0	usertests.asm	/^     ea0:	e8 9b 18 00 00       	call   2740 <open>$/;"	l
ea1	sh.asm	/^     ea1:	8b 55 0c             	mov    0xc(%ebp),%edx$/;"	l
ea4	sh.asm	/^     ea4:	8b 75 08             	mov    0x8(%ebp),%esi$/;"	l
ea5	usertests.asm	/^     ea5:	85 db                	test   %ebx,%ebx$/;"	l
ea7	sh.asm	/^     ea7:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)$/;"	l
ea7	usertests.asm	/^     ea7:	89 c1                	mov    %eax,%ecx$/;"	l
ea9	usertests.asm	/^     ea9:	0f 94 c2             	sete   %dl$/;"	l
eac	usertests.asm	/^     eac:	83 fb 09             	cmp    $0x9,%ebx$/;"	l
eae	sh.asm	/^     eae:	85 d2                	test   %edx,%edx$/;"	l
eaf	usertests.asm	/^     eaf:	0f 9f c0             	setg   %al$/;"	l
eargv	sh.c	/^  char *eargv[MAXARGS];$/;"	m	struct:execcmd	file:
eax	mmu.h	/^  uint eax;          \/\/ More saved state (registers)$/;"	m	struct:taskstate
eax	x86.h	/^  uint eax;$/;"	m	struct:trapframe
eb	usertests.asm	/^      eb:	00 $/;"	l
eb	wc.asm	/^  eb:	83 ec 0c             	sub    $0xc,%esp$/;"	l
eb	zombie.asm	/^  eb:	90                   	nop    $/;"	l
eb0	sh.asm	/^     eb0:	0f 95 c2             	setne  %dl$/;"	l
eb2	usertests.asm	/^     eb2:	09 d0                	or     %edx,%eax$/;"	l
eb3	sh.asm	/^     eb3:	c1 e8 1f             	shr    $0x1f,%eax$/;"	l
eb4	usertests.asm	/^     eb4:	a8 01                	test   $0x1,%al$/;"	l
eb6	sh.asm	/^     eb6:	85 d0                	test   %edx,%eax$/;"	l
eb6	usertests.asm	/^     eb6:	74 08                	je     ec0 <createdelete+0x140>$/;"	l
eb8	sh.asm	/^     eb8:	74 09                	je     ec3 <printint+0x33>$/;"	l
eb8	usertests.asm	/^     eb8:	85 c9                	test   %ecx,%ecx$/;"	l
eba	sh.asm	/^     eba:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)$/;"	l
eba	usertests.asm	/^     eba:	0f 88 a6 00 00 00    	js     f66 <createdelete+0x1e6>$/;"	l
ebp	kernel.asm	/^    ebp = (uint*)ebp[0]; \/\/ saved %ebp$/;"	d
ebp	kernel.asm	/^  ebp = (uint*)v - 2;$/;"	d
ebp	mmu.h	/^  uint *ebp;$/;"	m	struct:taskstate
ebp	proc.h	/^  int ebp;$/;"	m	struct:context
ebp	x86.h	/^  uint ebp;$/;"	m	struct:trapframe
ebx	mmu.h	/^  uint ebx;$/;"	m	struct:taskstate
ebx	proc.h	/^  int ebx;$/;"	m	struct:context
ebx	x86.h	/^  uint ebx;$/;"	m	struct:trapframe
ec	echo.asm	/^  ec:	5b                   	pop    %ebx$/;"	l
ec	forktest.asm	/^  ec:	e8 3f ff ff ff       	call   30 <forktest>$/;"	l
ec	kill.asm	/^  ec:	5b                   	pop    %ebx$/;"	l
ec	ls.asm	/^  ec:	83 f8 01             	cmp    $0x1,%eax$/;"	l
ec	sh.asm	/^      ec:	8d 74 26 00          	lea    0x0(%esi),%esi$/;"	l
ec	usertests.asm	/^      ec:	c7 44 24 04 a6 2b 00 	movl   $0x2ba6,0x4(%esp)$/;"	l
ec	zombie.asm	/^  ec:	90                   	nop    $/;"	l
ec0	usertests.asm	/^     ec0:	89 c8                	mov    %ecx,%eax$/;"	l
ec1	sh.asm	/^     ec1:	f7 d9                	neg    %ecx$/;"	l
ec2	usertests.asm	/^     ec2:	83 fe 08             	cmp    $0x8,%esi$/;"	l
ec3	sh.asm	/^     ec3:	31 db                	xor    %ebx,%ebx$/;"	l
ec5	sh.asm	/^     ec5:	89 c8                	mov    %ecx,%eax$/;"	l
ec5	usertests.asm	/^     ec5:	f7 d0                	not    %eax$/;"	l
ec7	sh.asm	/^     ec7:	31 d2                	xor    %edx,%edx$/;"	l
ec7	usertests.asm	/^     ec7:	0f 96 c2             	setbe  %dl$/;"	l
ec9	sh.asm	/^     ec9:	f7 f6                	div    %esi$/;"	l
eca	usertests.asm	/^     eca:	c1 e8 1f             	shr    $0x1f,%eax$/;"	l
ecb	sh.asm	/^     ecb:	89 c1                	mov    %eax,%ecx$/;"	l
ecd	sh.asm	/^     ecd:	0f b6 82 bc 12 00 00 	movzbl 0x12bc(%edx),%eax$/;"	l
ecd	usertests.asm	/^     ecd:	85 d0                	test   %edx,%eax$/;"	l
ecf	usertests.asm	/^     ecf:	75 78                	jne    f49 <createdelete+0x1c9>$/;"	l
echo_args	usertests.c	/^char *echo_args[] = { "echo", "ALL", "TESTS", "PASSED", 0 };$/;"	v
ecmd	sh.asm	/^    ecmd = (struct execcmd*)cmd;$/;"	d
ecx	mmu.h	/^  uint ecx;$/;"	m	struct:taskstate
ecx	proc.h	/^  int ecx;$/;"	m	struct:context
ecx	x86.h	/^  uint ecx;$/;"	m	struct:trapframe
ed	echo.asm	/^  ed:	c9                   	leave  $/;"	l
ed	kill.asm	/^  ed:	c9                   	leave  $/;"	l
ed	ln.asm	/^  ed:	89 d9                	mov    %ebx,%ecx$/;"	l
ed	zombie.asm	/^  ed:	90                   	nop    $/;"	l
ed1	usertests.asm	/^     ed1:	85 c9                	test   %ecx,%ecx$/;"	l
ed3	usertests.asm	/^     ed3:	78 08                	js     edd <createdelete+0x15d>$/;"	l
ed4	sh.asm	/^     ed4:	88 44 2b d8          	mov    %al,-0x28(%ebx,%ebp,1)$/;"	l
ed5	usertests.asm	/^     ed5:	89 0c 24             	mov    %ecx,(%esp)$/;"	l
ed8	sh.asm	/^     ed8:	43                   	inc    %ebx$/;"	l
ed8	usertests.asm	/^     ed8:	e8 4b 18 00 00       	call   2728 <close>$/;"	l
ed9	sh.asm	/^     ed9:	85 c9                	test   %ecx,%ecx$/;"	l
edb	sh.asm	/^     edb:	75 e8                	jne    ec5 <printint+0x35>$/;"	l
edd	sh.asm	/^     edd:	8b 45 d4             	mov    -0x2c(%ebp),%eax$/;"	l
edd	usertests.asm	/^     edd:	43                   	inc    %ebx$/;"	l
ede	usertests.asm	/^     ede:	83 fb 13             	cmp    $0x13,%ebx$/;"	l
edi	mmu.h	/^  uint edi;$/;"	m	struct:taskstate
edi	proc.h	/^  int edi;$/;"	m	struct:context
edi	x86.h	/^  uint edi;$/;"	m	struct:trapframe
edx	mmu.h	/^  uint edx;$/;"	m	struct:taskstate
edx	proc.h	/^  int edx;$/;"	m	struct:context
edx	x86.h	/^  uint edx;$/;"	m	struct:trapframe
ee	echo.asm	/^  ee:	c3                   	ret    $/;"	l
ee	kill.asm	/^  ee:	c3                   	ret    $/;"	l
ee	wc.asm	/^  ee:	8b 7d 0c             	mov    0xc(%ebp),%edi$/;"	l
ee	zombie.asm	/^  ee:	90                   	nop    $/;"	l
ee0	sh.asm	/^     ee0:	85 c0                	test   %eax,%eax$/;"	l
ee1	usertests.asm	/^     ee1:	0f 8e 4b ff ff ff    	jle    e32 <createdelete+0xb2>$/;"	l
ee2	sh.asm	/^     ee2:	74 18                	je     efc <printint+0x6c>$/;"	l
ee4	sh.asm	/^     ee4:	c6 44 2b d8 2d       	movb   $0x2d,-0x28(%ebx,%ebp,1)$/;"	l
ee7	usertests.asm	/^     ee7:	31 db                	xor    %ebx,%ebx$/;"	l
ee9	sh.asm	/^     ee9:	43                   	inc    %ebx$/;"	l
ee9	usertests.asm	/^     ee9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi$/;"	l
eea	sh.asm	/^     eea:	eb 10                	jmp    efc <printint+0x6c>$/;"	l
eec	sh.asm	/^     eec:	8d 74 26 00          	lea    0x0(%esi),%esi$/;"	l
ef	echo.asm	/^  ef:	90                   	nop    $/;"	l
ef	grep.asm	/^  ef:	85 c0                	test   %eax,%eax$/;"	l
ef	init.asm	/^  ef:	e9 35 ff ff ff       	jmp    29 <main+0x29>$/;"	l
ef	kill.asm	/^  ef:	90                   	nop    $/;"	l
ef	ln.asm	/^  ef:	eb 03                	jmp    f4 <memset+0x14>$/;"	l
ef	ls.asm	/^  ef:	74 42                	je     133 <ls+0x93>$/;"	l
ef	zombie.asm	/^  ef:	90                   	nop    $/;"	l
ef0	sh.asm	/^     ef0:	0f be 54 1d d8       	movsbl -0x28(%ebp,%ebx,1),%edx$/;"	l
ef0	usertests.asm	/^     ef0:	8d 43 30             	lea    0x30(%ebx),%eax$/;"	l
ef3	usertests.asm	/^     ef3:	43                   	inc    %ebx$/;"	l
ef4	usertests.asm	/^     ef4:	c6 45 c8 70          	movb   $0x70,-0x38(%ebp)$/;"	l
ef5	sh.asm	/^     ef5:	89 f8                	mov    %edi,%eax$/;"	l
ef7	sh.asm	/^     ef7:	e8 64 ff ff ff       	call   e60 <putc>$/;"	l
ef8	usertests.asm	/^     ef8:	89 3c 24             	mov    %edi,(%esp)$/;"	l
efb	usertests.asm	/^     efb:	88 45 c9             	mov    %al,-0x37(%ebp)$/;"	l
efc	sh.asm	/^     efc:	4b                   	dec    %ebx$/;"	l
efd	sh.asm	/^     efd:	79 f1                	jns    ef0 <printint+0x60>$/;"	l
efe	usertests.asm	/^     efe:	e8 4d 18 00 00       	call   2750 <unlink>$/;"	l
eff	sh.asm	/^     eff:	83 c4 2c             	add    $0x2c,%esp$/;"	l
efile	sh.c	/^  char *efile;$/;"	m	struct:redircmd	file:
eflags	kernel.asm	/^  eflags = read_eflags();$/;"	d
eflags	mmu.h	/^  uint eflags;$/;"	m	struct:taskstate
eflags	x86.h	/^  uint eflags;$/;"	m	struct:trapframe
ehsize	elf.h	/^  ushort ehsize;$/;"	m	struct:elfhdr
eip	mmu.h	/^  uint *eip;         \/\/ Saved state from last task switch$/;"	m	struct:taskstate
eip	proc.h	/^  int eip;$/;"	m	struct:context
eip	x86.h	/^  uint eip;$/;"	m	struct:trapframe
elf	bootblock.asm	/^  elf = (struct elfhdr*)0x10000;  \/\/ scratch space$/;"	d
elf	elf.h	/^  uchar elf[12];$/;"	m	struct:elfhdr
elfhdr	elf.h	/^struct elfhdr {$/;"	s
empty	kernel.asm	/^      empty = ip;$/;"	d
empty	kernel.asm	/^  empty = 0;$/;"	d
enable_paging	pmap.c	/^enable_paging(void)$/;"	f
end_code	proc.h	/^  vaddr_t end_code;         \/\/ End address of executable code$/;"	m	struct:proc_vm
end_data	proc.h	/^  vaddr_t end_data;         \/\/ End address of data$/;"	m	struct:proc_vm
endaddr	kernel.asm	/^		  endaddr = ROUNDDOWN(baseaddr + mem, PAGE);$/;"	d
entry	bootblock.asm	/^  entry = (void(*)(void))(elf->entry & 0xFFFFFF);$/;"	d
entry	elf.h	/^  uint entry;$/;"	m	struct:elfhdr
entry	mp.h	/^  ushort entry;                 \/\/ entry count$/;"	m	struct:mpconf
ep	kernel.asm	/^  ep = p->mem + p->sz;$/;"	d
eph	bootblock.asm	/^  eph = ph + elf->phnum;$/;"	d
err	x86.h	/^  uint err;$/;"	m	struct:trapframe
es	mmu.h	/^  ushort es;         \/\/ Even more saved state (segment selectors)$/;"	m	struct:taskstate
es	sh.asm	/^  es = s + strlen(s);$/;"	d
es	x86.h	/^  ushort es;$/;"	m	struct:trapframe
esi	mmu.h	/^  uint esi;$/;"	m	struct:taskstate
esi	proc.h	/^  int esi;$/;"	m	struct:context
esi	x86.h	/^  uint esi;$/;"	m	struct:trapframe
esp	mmu.h	/^  uint *esp;$/;"	m	struct:taskstate
esp	proc.h	/^  int esp;$/;"	m	struct:context
esp	x86.h	/^  uint esp;$/;"	m	struct:trapframe
esp0	mmu.h	/^  uint esp0;         \/\/ Stack pointers and segment selectors$/;"	m	struct:taskstate
esp1	mmu.h	/^  uint *esp1;$/;"	m	struct:taskstate
esp2	mmu.h	/^  uint *esp2;$/;"	m	struct:taskstate
eva	bootblock.asm	/^  eva = va + count;$/;"	d
exec	exec.c	/^exec(char *path, char **argv)$/;"	f
execcmd	sh.c	/^execcmd(void)$/;"	f
execcmd	sh.c	/^struct execcmd {$/;"	s	file:
exectest	usertests.c	/^exectest(void)$/;"	f
exit	initcode.S	/^exit:$/;"	l
exit	proc.c	/^exit(void)$/;"	f
exitwait	usertests.c	/^exitwait(void)$/;"	f
extern	kernel.asm	/^extern int use_console_lock;$/;"	l
extern	kernel.asm	/^extern void forkret(void);$/;"	l
extern	kernel.asm	/^extern void forkret1(struct trapframe*);$/;"	l
f	Makefile	/^	dd if=\/dev\/zero of=xv6.img count=10000$/;"	m
f	Makefile	/^	dd if=bootblock of=xv6.img conv=notrunc$/;"	m
f	Makefile	/^	dd if=kernel of=xv6.img seek=1 conv=notrunc$/;"	m
f	grep.asm	/^   f:	8b 5d 10             	mov    0x10(%ebp),%ebx$/;"	l
f	kill.asm	/^   f:	83 ec 10             	sub    $0x10,%esp$/;"	l
f	mkdir.asm	/^   f:	83 ec 10             	sub    $0x10,%esp$/;"	l
f	rm.asm	/^   f:	83 ec 10             	sub    $0x10,%esp$/;"	l
f0	cat.asm	/^  f0:	e8 0b ff ff ff       	call   0 <cat>$/;"	l
f0	echo.asm	/^  f0:	55                   	push   %ebp$/;"	l
f0	kill.asm	/^  f0:	55                   	push   %ebp$/;"	l
f0	mkdir.asm	/^  f0:	55                   	push   %ebp$/;"	l
f0	rm.asm	/^  f0:	55                   	push   %ebp$/;"	l
f0	sh.asm	/^      f0:	c7 04 24 c4 11 00 00 	movl   $0x11c4,(%esp)$/;"	l
f0	zombie.asm	/^  f0:	55                   	push   %ebp$/;"	l
f02	sh.asm	/^     f02:	5b                   	pop    %ebx$/;"	l
f03	sh.asm	/^     f03:	5e                   	pop    %esi$/;"	l
f03	usertests.asm	/^     f03:	c6 45 c8 63          	movb   $0x63,-0x38(%ebp)$/;"	l
f04	sh.asm	/^     f04:	5f                   	pop    %edi$/;"	l
f05	sh.asm	/^     f05:	c9                   	leave  $/;"	l
f06	sh.asm	/^     f06:	c3                   	ret    $/;"	l
f07	sh.asm	/^     f07:	89 f6                	mov    %esi,%esi$/;"	l
f07	usertests.asm	/^     f07:	89 3c 24             	mov    %edi,(%esp)$/;"	l
f09	sh.asm	/^     f09:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi$/;"	l
f0a	usertests.asm	/^     f0a:	e8 41 18 00 00       	call   2750 <unlink>$/;"	l
f0f	usertests.asm	/^     f0f:	83 fb 13             	cmp    $0x13,%ebx$/;"	l
f1	echo.asm	/^  f1:	89 e5                	mov    %esp,%ebp$/;"	l
f1	forktest.asm	/^  f1:	e8 fa 01 00 00       	call   2f0 <exit>$/;"	l
f1	grep.asm	/^  f1:	75 22                	jne    115 <match+0x45>$/;"	l
f1	kill.asm	/^  f1:	89 e5                	mov    %esp,%ebp$/;"	l
f1	ln.asm	/^  f1:	88 01                	mov    %al,(%ecx)$/;"	l
f1	ls.asm	/^  f1:	83 f8 02             	cmp    $0x2,%eax$/;"	l
f1	mkdir.asm	/^  f1:	89 e5                	mov    %esp,%ebp$/;"	l
f1	rm.asm	/^  f1:	89 e5                	mov    %esp,%ebp$/;"	l
f1	wc.asm	/^  f1:	83 e4 f0             	and    $0xfffffff0,%esp$/;"	l
f1	zombie.asm	/^  f1:	89 e5                	mov    %esp,%ebp$/;"	l
f10	sh.asm	/^     f10:	55                   	push   %ebp$/;"	l
f11	sh.asm	/^     f11:	89 e5                	mov    %esp,%ebp$/;"	l
f12	usertests.asm	/^     f12:	7e dc                	jle    ef0 <createdelete+0x170>$/;"	l
f13	sh.asm	/^     f13:	57                   	push   %edi$/;"	l
f14	sh.asm	/^     f14:	31 ff                	xor    %edi,%edi$/;"	l
f14	usertests.asm	/^     f14:	c7 44 24 04 03 2f 00 	movl   $0x2f03,0x4(%esp)$/;"	l
f16	sh.asm	/^     f16:	8d 45 10             	lea    0x10(%ebp),%eax$/;"	l
f19	sh.asm	/^     f19:	56                   	push   %esi$/;"	l
f1a	sh.asm	/^     f1a:	31 f6                	xor    %esi,%esi$/;"	l
f1b	usertests.asm	/^     f1b:	00 $/;"	l
f1c	sh.asm	/^     f1c:	53                   	push   %ebx$/;"	l
f1c	usertests.asm	/^     f1c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)$/;"	l
f1d	sh.asm	/^     f1d:	83 ec 0c             	sub    $0xc,%esp$/;"	l
f20	sh.asm	/^     f20:	8b 4d 0c             	mov    0xc(%ebp),%ecx$/;"	l
f23	sh.asm	/^     f23:	89 45 f0             	mov    %eax,-0x10(%ebp)$/;"	l
f23	usertests.asm	/^     f23:	e8 28 19 00 00       	call   2850 <printf>$/;"	l
f26	sh.asm	/^     f26:	80 39 00             	cmpb   $0x0,(%ecx)$/;"	l
f28	usertests.asm	/^     f28:	83 c4 3c             	add    $0x3c,%esp$/;"	l
f29	sh.asm	/^     f29:	74 1d                	je     f48 <printf+0x38>$/;"	l
f2b	sh.asm	/^     f2b:	90                   	nop    $/;"	l
f2b	usertests.asm	/^     f2b:	5b                   	pop    %ebx$/;"	l
f2c	sh.asm	/^     f2c:	8d 74 26 00          	lea    0x0(%esi),%esi$/;"	l
f2c	usertests.asm	/^     f2c:	5e                   	pop    %esi$/;"	l
f2d	usertests.asm	/^     f2d:	5f                   	pop    %edi$/;"	l
f2e	usertests.asm	/^     f2e:	c9                   	leave  $/;"	l
f2f	usertests.asm	/^     f2f:	c3                   	ret    $/;"	l
f3	echo.asm	/^  f3:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx$/;"	l
f3	grep.asm	/^  f3:	0f b6 03             	movzbl (%ebx),%eax$/;"	l
f3	kill.asm	/^  f3:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx$/;"	l
f3	ln.asm	/^  f3:	41                   	inc    %ecx$/;"	l
f3	mkdir.asm	/^  f3:	53                   	push   %ebx$/;"	l
f3	rm.asm	/^  f3:	53                   	push   %ebx$/;"	l
f3	usertests.asm	/^      f3:	00 $/;"	l
f3	zombie.asm	/^  f3:	57                   	push   %edi$/;"	l
f30	sh.asm	/^     f30:	85 f6                	test   %esi,%esi$/;"	l
f30	usertests.asm	/^     f30:	c7 44 24 04 4f 31 00 	movl   $0x314f,0x4(%esp)$/;"	l
f32	sh.asm	/^     f32:	0f b6 1c 39          	movzbl (%ecx,%edi,1),%ebx$/;"	l
f36	sh.asm	/^     f36:	75 18                	jne    f50 <printf+0x40>$/;"	l
f37	usertests.asm	/^     f37:	00 $/;"	l
f38	sh.asm	/^     f38:	83 fb 25             	cmp    $0x25,%ebx$/;"	l
f38	usertests.asm	/^     f38:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)$/;"	l
f3b	sh.asm	/^     f3b:	75 73                	jne    fb0 <printf+0xa0>$/;"	l
f3d	sh.asm	/^     f3d:	66 be 25 00          	mov    $0x25,%si$/;"	l
f3f	usertests.asm	/^     f3f:	e8 0c 19 00 00       	call   2850 <printf>$/;"	l
f4	init.asm	/^  f4:	90                   	nop    $/;"	l
f4	ln.asm	/^  f4:	4a                   	dec    %edx$/;"	l
f4	ls.asm	/^  f4:	74 65                	je     15b <ls+0xbb>$/;"	l
f4	mkdir.asm	/^  f4:	8b 5d 08             	mov    0x8(%ebp),%ebx$/;"	l
f4	rm.asm	/^  f4:	8b 5d 08             	mov    0x8(%ebp),%ebx$/;"	l
f4	usertests.asm	/^      f4:	89 34 24             	mov    %esi,(%esp)$/;"	l
f4	wc.asm	/^  f4:	83 ec 10             	sub    $0x10,%esp$/;"	l
f4	zombie.asm	/^  f4:	56                   	push   %esi$/;"	l
f41	sh.asm	/^     f41:	47                   	inc    %edi$/;"	l
f42	sh.asm	/^     f42:	80 3c 39 00          	cmpb   $0x0,(%ecx,%edi,1)$/;"	l
f44	usertests.asm	/^     f44:	e8 b7 17 00 00       	call   2700 <exit>$/;"	l
f46	sh.asm	/^     f46:	75 e8                	jne    f30 <printf+0x20>$/;"	l
f48	sh.asm	/^     f48:	83 c4 0c             	add    $0xc,%esp$/;"	l
f49	usertests.asm	/^     f49:	89 7c 24 08          	mov    %edi,0x8(%esp)$/;"	l
f4b	sh.asm	/^     f4b:	5b                   	pop    %ebx$/;"	l
f4c	sh.asm	/^     f4c:	5e                   	pop    %esi$/;"	l
f4d	sh.asm	/^     f4d:	5f                   	pop    %edi$/;"	l
f4d	usertests.asm	/^     f4d:	c7 44 24 04 14 39 00 	movl   $0x3914,0x4(%esp)$/;"	l
f4e	sh.asm	/^     f4e:	c9                   	leave  $/;"	l
f4f	sh.asm	/^     f4f:	c3                   	ret    $/;"	l
f5	cat.asm	/^  f5:	e8 f6 01 00 00       	call   2f0 <exit>$/;"	l
f5	init.asm	/^  f5:	90                   	nop    $/;"	l
f5	ln.asm	/^  f5:	83 fa ff             	cmp    $0xffffffff,%edx$/;"	l
f5	zombie.asm	/^  f5:	53                   	push   %ebx$/;"	l
f50	sh.asm	/^     f50:	83 fe 25             	cmp    $0x25,%esi$/;"	l
f53	sh.asm	/^     f53:	75 ec                	jne    f41 <printf+0x31>$/;"	l
f54	usertests.asm	/^     f54:	00 $/;"	l
f55	sh.asm	/^     f55:	83 fb 64             	cmp    $0x64,%ebx$/;"	l
f55	usertests.asm	/^     f55:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)$/;"	l
f58	sh.asm	/^     f58:	0f 84 ba 00 00 00    	je     1018 <printf+0x108>$/;"	l
f5c	usertests.asm	/^     f5c:	e8 ef 18 00 00       	call   2850 <printf>$/;"	l
f5e	sh.asm	/^     f5e:	83 fb 78             	cmp    $0x78,%ebx$/;"	l
f6	forktest.asm	/^  f6:	90                   	nop    $/;"	l
f6	grep.asm	/^  f6:	43                   	inc    %ebx$/;"	l
f6	init.asm	/^  f6:	90                   	nop    $/;"	l
f6	ls.asm	/^  f6:	89 34 24             	mov    %esi,(%esp)$/;"	l
f6	zombie.asm	/^  f6:	31 db                	xor    %ebx,%ebx$/;"	l
f61	sh.asm	/^     f61:	0f 94 c2             	sete   %dl$/;"	l
f61	usertests.asm	/^     f61:	e8 9a 17 00 00       	call   2700 <exit>$/;"	l
f64	sh.asm	/^     f64:	83 fb 70             	cmp    $0x70,%ebx$/;"	l
f66	usertests.asm	/^     f66:	89 7c 24 08          	mov    %edi,0x8(%esp)$/;"	l
f67	sh.asm	/^     f67:	0f 94 c0             	sete   %al$/;"	l
f6a	sh.asm	/^     f6a:	09 d0                	or     %edx,%eax$/;"	l
f6a	usertests.asm	/^     f6a:	c7 44 24 04 34 39 00 	movl   $0x3934,0x4(%esp)$/;"	l
f6c	sh.asm	/^     f6c:	a8 01                	test   $0x1,%al$/;"	l
f6e	sh.asm	/^     f6e:	75 55                	jne    fc5 <printf+0xb5>$/;"	l
f7	echo.asm	/^  f7:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
f7	forktest.asm	/^  f7:	90                   	nop    $/;"	l
f7	grep.asm	/^  f7:	84 c0                	test   %al,%al$/;"	l
f7	init.asm	/^  f7:	90                   	nop    $/;"	l
f7	kill.asm	/^  f7:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
f7	mkdir.asm	/^  f7:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
f7	rm.asm	/^  f7:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
f7	sh.asm	/^      f7:	e8 04 ff ff ff       	call   0 <panic>$/;"	l
f7	usertests.asm	/^      f7:	e8 24 26 00 00       	call   2720 <write>$/;"	l
f7	wc.asm	/^  f7:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)$/;"	l
f70	sh.asm	/^     f70:	83 fb 73             	cmp    $0x73,%ebx$/;"	l
f71	usertests.asm	/^     f71:	00 $/;"	l
f72	usertests.asm	/^     f72:	eb e1                	jmp    f55 <createdelete+0x1d5>$/;"	l
f73	sh.asm	/^     f73:	74 75                	je     fea <printf+0xda>$/;"	l
f74	usertests.asm	/^     f74:	c7 44 24 04 20 2e 00 	movl   $0x2e20,0x4(%esp)$/;"	l
f75	sh.asm	/^     f75:	83 fb 63             	cmp    $0x63,%ebx$/;"	l
f78	sh.asm	/^     f78:	0f 84 ab 00 00 00    	je     1029 <printf+0x119>$/;"	l
f7b	usertests.asm	/^     f7b:	00 $/;"	l
f7c	usertests.asm	/^     f7c:	eb ba                	jmp    f38 <createdelete+0x1b8>$/;"	l
f7e	sh.asm	/^     f7e:	83 fb 25             	cmp    $0x25,%ebx$/;"	l
f7e	usertests.asm	/^     f7e:	66 90                	xchg   %ax,%ax$/;"	l
f8	forktest.asm	/^  f8:	90                   	nop    $/;"	l
f8	init.asm	/^  f8:	90                   	nop    $/;"	l
f8	ln.asm	/^  f8:	75 f7                	jne    f1 <memset+0x11>$/;"	l
f8	zombie.asm	/^  f8:	83 ec 1c             	sub    $0x1c,%esp$/;"	l
f80	usertests.asm	/^     f80:	55                   	push   %ebp$/;"	l
f81	sh.asm	/^     f81:	ba 25 00 00 00       	mov    $0x25,%edx$/;"	l
f81	usertests.asm	/^     f81:	89 e5                	mov    %esp,%ebp$/;"	l
f83	usertests.asm	/^     f83:	56                   	push   %esi$/;"	l
f84	usertests.asm	/^     f84:	53                   	push   %ebx$/;"	l
f85	usertests.asm	/^     f85:	83 ec 10             	sub    $0x10,%esp$/;"	l
f86	sh.asm	/^     f86:	74 10                	je     f98 <printf+0x88>$/;"	l
f88	sh.asm	/^     f88:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
f88	usertests.asm	/^     f88:	c7 44 24 04 14 2f 00 	movl   $0x2f14,0x4(%esp)$/;"	l
f8b	sh.asm	/^     f8b:	ba 25 00 00 00       	mov    $0x25,%edx$/;"	l
f8f	usertests.asm	/^     f8f:	00 $/;"	l
f9	forktest.asm	/^  f9:	90                   	nop    $/;"	l
f9	grep.asm	/^  f9:	75 e8                	jne    e3 <match+0x13>$/;"	l
f9	init.asm	/^  f9:	90                   	nop    $/;"	l
f9	ls.asm	/^  f9:	e8 2a 04 00 00       	call   528 <close>$/;"	l
f90	sh.asm	/^     f90:	e8 cb fe ff ff       	call   e60 <putc>$/;"	l
f90	usertests.asm	/^     f90:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)$/;"	l
f95	sh.asm	/^     f95:	0f be d3             	movsbl %bl,%edx$/;"	l
f97	usertests.asm	/^     f97:	e8 b4 18 00 00       	call   2850 <printf>$/;"	l
f98	sh.asm	/^     f98:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
f9b	sh.asm	/^     f9b:	e8 c0 fe ff ff       	call   e60 <putc>$/;"	l
f9c	usertests.asm	/^     f9c:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)$/;"	l
fa	cat.asm	/^  fa:	90                   	nop    $/;"	l
fa	echo.asm	/^  fa:	eb 09                	jmp    105 <strchr+0x15>$/;"	l
fa	forktest.asm	/^  fa:	90                   	nop    $/;"	l
fa	init.asm	/^  fa:	90                   	nop    $/;"	l
fa	kill.asm	/^  fa:	eb 09                	jmp    105 <strchr+0x15>$/;"	l
fa	ln.asm	/^  fa:	89 d8                	mov    %ebx,%eax$/;"	l
fa	mkdir.asm	/^  fa:	8b 55 10             	mov    0x10(%ebp),%edx$/;"	l
fa	rm.asm	/^  fa:	8b 55 10             	mov    0x10(%ebp),%edx$/;"	l
fa0	sh.asm	/^     fa0:	8b 4d 0c             	mov    0xc(%ebp),%ecx$/;"	l
fa3	sh.asm	/^     fa3:	47                   	inc    %edi$/;"	l
fa3	usertests.asm	/^     fa3:	00 $/;"	l
fa4	sh.asm	/^     fa4:	31 f6                	xor    %esi,%esi$/;"	l
fa4	usertests.asm	/^     fa4:	c7 04 24 25 2f 00 00 	movl   $0x2f25,(%esp)$/;"	l
fa6	sh.asm	/^     fa6:	80 3c 39 00          	cmpb   $0x0,(%ecx,%edi,1)$/;"	l
faa	sh.asm	/^     faa:	eb 9a                	jmp    f46 <printf+0x36>$/;"	l
fab	usertests.asm	/^     fab:	e8 90 17 00 00       	call   2740 <open>$/;"	l
fac	sh.asm	/^     fac:	8d 74 26 00          	lea    0x0(%esi),%esi$/;"	l
fb	cat.asm	/^  fb:	90                   	nop    $/;"	l
fb	forktest.asm	/^  fb:	90                   	nop    $/;"	l
fb	grep.asm	/^  fb:	83 c4 10             	add    $0x10,%esp$/;"	l
fb	init.asm	/^  fb:	90                   	nop    $/;"	l
fb	wc.asm	/^  fb:	7f 34                	jg     131 <main+0x51>$/;"	l
fb	zombie.asm	/^  fb:	8b 7d 0c             	mov    0xc(%ebp),%edi$/;"	l
fb0	sh.asm	/^     fb0:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
fb0	usertests.asm	/^     fb0:	85 c0                	test   %eax,%eax$/;"	l
fb2	usertests.asm	/^     fb2:	89 c6                	mov    %eax,%esi$/;"	l
fb3	sh.asm	/^     fb3:	0f be d3             	movsbl %bl,%edx$/;"	l
fb4	usertests.asm	/^     fb4:	0f 88 02 01 00 00    	js     10bc <unlinkread+0x13c>$/;"	l
fb6	sh.asm	/^     fb6:	47                   	inc    %edi$/;"	l
fb7	sh.asm	/^     fb7:	e8 a4 fe ff ff       	call   e60 <putc>$/;"	l
fba	usertests.asm	/^     fba:	c7 44 24 08 05 00 00 	movl   $0x5,0x8(%esp)$/;"	l
fbc	sh.asm	/^     fbc:	8b 4d 0c             	mov    0xc(%ebp),%ecx$/;"	l
fbf	sh.asm	/^     fbf:	80 3c 39 00          	cmpb   $0x0,(%ecx,%edi,1)$/;"	l
fc	cat.asm	/^  fc:	90                   	nop    $/;"	l
fc	echo.asm	/^  fc:	8d 74 26 00          	lea    0x0(%esi),%esi$/;"	l
fc	forktest.asm	/^  fc:	90                   	nop    $/;"	l
fc	init.asm	/^  fc:	90                   	nop    $/;"	l
fc	kill.asm	/^  fc:	8d 74 26 00          	lea    0x0(%esi),%esi$/;"	l
fc	ln.asm	/^  fc:	5b                   	pop    %ebx$/;"	l
fc	sh.asm	/^      fc:	8b 53 04             	mov    0x4(%ebx),%edx$/;"	l
fc	usertests.asm	/^      fc:	83 f8 0a             	cmp    $0xa,%eax$/;"	l
fc1	usertests.asm	/^     fc1:	00 $/;"	l
fc2	usertests.asm	/^     fc2:	c7 44 24 04 30 2f 00 	movl   $0x2f30,0x4(%esp)$/;"	l
fc3	sh.asm	/^     fc3:	eb 81                	jmp    f46 <printf+0x36>$/;"	l
fc5	sh.asm	/^     fc5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)$/;"	l
fc9	usertests.asm	/^     fc9:	00 $/;"	l
fca	usertests.asm	/^     fca:	89 04 24             	mov    %eax,(%esp)$/;"	l
fcc	sh.asm	/^     fcc:	00 $/;"	l
fcd	sh.asm	/^     fcd:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)$/;"	l
fcd	usertests.asm	/^     fcd:	e8 4e 17 00 00       	call   2720 <write>$/;"	l
fd	cat.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	cat.asm	/^  fd:	90                   	nop    $/;"	l
fd	echo.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	forktest.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	forktest.asm	/^  fd:	90                   	nop    $/;"	l
fd	grep.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	init.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	init.asm	/^  fd:	90                   	nop    $/;"	l
fd	kill.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	ln.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	ln.asm	/^  fd:	c9                   	leave  $/;"	l
fd	ls.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	mkdir.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	mkdir.asm	/^  fd:	89 d9                	mov    %ebx,%ecx$/;"	l
fd	rm.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	rm.asm	/^  fd:	89 d9                	mov    %ebx,%ecx$/;"	l
fd	sh.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	sh.c	/^  int fd;$/;"	m	struct:redircmd	file:
fd	usertests.asm	/^      fd = open(file, 0);$/;"	d
fd	usertests.asm	/^      fd = open(file, O_CREATE | O_RDWR);$/;"	d
fd	usertests.asm	/^    fd = open("", O_CREATE);$/;"	d
fd	usertests.asm	/^    fd = open("xx", O_CREATE);$/;"	d
fd	usertests.asm	/^    fd = open(i?"f1":"f2", 0);$/;"	d
fd	usertests.asm	/^    fd = open(name, 0);$/;"	d
fd	usertests.asm	/^    fd = open(name, O_CREATE | O_RDWR);$/;"	d
fd	usertests.asm	/^    fd = open(name, O_CREATE|O_RDWR);$/;"	d
fd	usertests.asm	/^  fd = open(".", 0);$/;"	d
fd	usertests.asm	/^  fd = open(".", O_RDWR);$/;"	d
fd	usertests.asm	/^  fd = open("123456789012345\/123456789012345\/123456789012345", O_CREATE);$/;"	d
fd	usertests.asm	/^  fd = open("12345678901234\/12345678901234\/12345678901234", 0);$/;"	d
fd	usertests.asm	/^  fd = open("bd", O_CREATE);$/;"	d
fd	usertests.asm	/^  fd = open("big", O_CREATE|O_RDWR);$/;"	d
fd	usertests.asm	/^  fd = open("big", O_RDONLY);$/;"	d
fd	usertests.asm	/^  fd = open("bigfile", 0);$/;"	d
fd	usertests.asm	/^  fd = open("bigfile", O_CREATE | O_RDWR);$/;"	d
fd	usertests.asm	/^  fd = open("dd\/dd\/..\/ff", 0);$/;"	d
fd	usertests.asm	/^  fd = open("dd\/dd\/ff", O_CREATE | O_RDWR);$/;"	d
fd	usertests.asm	/^  fd = open("dd\/dd\/ffff", 0);$/;"	d
fd	usertests.asm	/^  fd = open("dd\/ff", O_CREATE | O_RDWR);$/;"	d
fd	usertests.asm	/^  fd = open("dirfile", O_CREATE);$/;"	d
fd	usertests.asm	/^  fd = open("dirfile\/xx", 0);$/;"	d
fd	usertests.asm	/^  fd = open("dirfile\/xx", O_CREATE);$/;"	d
fd	usertests.asm	/^  fd = open("doesnotexist", 0);$/;"	d
fd	usertests.asm	/^  fd = open("echo", 0);$/;"	d
fd	usertests.asm	/^  fd = open("lf1", O_CREATE|O_RDWR);$/;"	d
fd	usertests.asm	/^  fd = open("lf2", 0);$/;"	d
fd	usertests.asm	/^  fd = open("sharedfd", 0);$/;"	d
fd	usertests.asm	/^  fd = open("sharedfd", O_CREATE|O_RDWR);$/;"	d
fd	usertests.asm	/^  fd = open("small", O_CREATE|O_RDWR);$/;"	d
fd	usertests.asm	/^  fd = open("small", O_RDONLY);$/;"	d
fd	usertests.asm	/^  fd = open("unlinkread", O_CREATE | O_RDWR);$/;"	d
fd	usertests.asm	/^  fd = open("unlinkread", O_RDWR);$/;"	d
fd	usertests.asm	/^  fd = open(fname, O_CREATE | O_RDWR);$/;"	d
fd	usertests.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	wc.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	wc.asm	/^  fd:	eb 5c                	jmp    15b <main+0x7b>$/;"	l
fd	zombie.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd0	kernel.asm	/^  fd0 = -1;$/;"	d
fd1	usertests.asm	/^  fd1 = open("unlinkread", O_CREATE | O_RDWR);$/;"	d
fd2	usertests.asm	/^     fd2:	89 34 24             	mov    %esi,(%esp)$/;"	l
fd4	sh.asm	/^     fd4:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
fd5	usertests.asm	/^     fd5:	e8 4e 17 00 00       	call   2728 <close>$/;"	l
fd7	sh.asm	/^     fd7:	8b 10                	mov    (%eax),%edx$/;"	l
fd9	sh.asm	/^     fd9:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
fda	usertests.asm	/^     fda:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)$/;"	l
fdalloc	sysfile.c	/^fdalloc(struct file *f)$/;"	f	file:
fdc	sh.asm	/^     fdc:	e8 af fe ff ff       	call   e90 <printint>$/;"	l
fe	cat.asm	/^  fe:	90                   	nop    $/;"	l
fe	forktest.asm	/^  fe:	90                   	nop    $/;"	l
fe	grep.asm	/^  fe:	31 c0                	xor    %eax,%eax$/;"	l
fe	init.asm	/^  fe:	90                   	nop    $/;"	l
fe	ln.asm	/^  fe:	c3                   	ret    $/;"	l
fe	ls.asm	/^  fe:	8b 5d f4             	mov    -0xc(%ebp),%ebx$/;"	l
fe	zombie.asm	/^  fe:	8b 75 08             	mov    0x8(%ebp),%esi$/;"	l
fe1	sh.asm	/^     fe1:	83 45 f0 04          	addl   $0x4,-0x10(%ebp)$/;"	l
fe1	usertests.asm	/^     fe1:	00 $/;"	l
fe2	usertests.asm	/^     fe2:	c7 04 24 25 2f 00 00 	movl   $0x2f25,(%esp)$/;"	l
fe5	sh.asm	/^     fe5:	8b 4d 0c             	mov    0xc(%ebp),%ecx$/;"	l
fe8	sh.asm	/^     fe8:	eb b9                	jmp    fa3 <printf+0x93>$/;"	l
fe9	usertests.asm	/^     fe9:	e8 52 17 00 00       	call   2740 <open>$/;"	l
fea	sh.asm	/^     fea:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
feature	mp.h	/^  uint feature;                 \/\/ feature flags from CPUID instruction$/;"	m	struct:mpproc
fed	sh.asm	/^     fed:	8b 18                	mov    (%eax),%ebx$/;"	l
fee	usertests.asm	/^     fee:	85 c0                	test   %eax,%eax$/;"	l
fef	sh.asm	/^     fef:	83 c0 04             	add    $0x4,%eax$/;"	l
fetchint	syscall.c	/^fetchint(struct proc *p, uint addr, int *ip)$/;"	f
fetchstr	syscall.c	/^fetchstr(struct proc *p, uint addr, char **pp)$/;"	f
ff	cat.asm	/^  ff:	90                   	nop    $/;"	l
ff	forktest.asm	/^  ff:	90                   	nop    $/;"	l
ff	init.asm	/^  ff:	90                   	nop    $/;"	l
ff	kernel.asm	/^  ff = *f;$/;"	d
ff	ln.asm	/^  ff:	90                   	nop    $/;"	l
ff	mkdir.asm	/^  ff:	eb 03                	jmp    104 <memset+0x14>$/;"	l
ff	rm.asm	/^  ff:	eb 03                	jmp    104 <memset+0x14>$/;"	l
ff	sh.asm	/^      ff:	85 d2                	test   %edx,%edx$/;"	l
ff	usertests.asm	/^      ff:	0f 85 e3 00 00 00    	jne    1e8 <writetest+0x158>$/;"	l
ff	wc.asm	/^  ff:	90                   	nop    $/;"	l
ff0	usertests.asm	/^     ff0:	89 c6                	mov    %eax,%esi$/;"	l
ff2	sh.asm	/^     ff2:	89 45 f0             	mov    %eax,-0x10(%ebp)$/;"	l
ff2	usertests.asm	/^     ff2:	0f 88 dd 00 00 00    	js     10d5 <unlinkread+0x155>$/;"	l
ff5	sh.asm	/^     ff5:	85 db                	test   %ebx,%ebx$/;"	l
ff7	sh.asm	/^     ff7:	74 44                	je     103d <printf+0x12d>$/;"	l
ff8	usertests.asm	/^     ff8:	c7 04 24 25 2f 00 00 	movl   $0x2f25,(%esp)$/;"	l
ff9	sh.asm	/^     ff9:	0f b6 03             	movzbl (%ebx),%eax$/;"	l
ffc	sh.asm	/^     ffc:	84 c0                	test   %al,%al$/;"	l
ffe	sh.asm	/^     ffe:	74 a3                	je     fa3 <printf+0x93>$/;"	l
fff	usertests.asm	/^     fff:	e8 4c 17 00 00       	call   2750 <unlink>$/;"	l
file	file.c	/^struct file file[NFILE];$/;"	v	typeref:struct:file
file	file.h	/^struct file {$/;"	s
file	sh.c	/^  char *file;$/;"	m	struct:redircmd	file:
file_table_lock	file.c	/^struct spinlock file_table_lock;$/;"	v	typeref:struct:spinlock
filealloc	file.c	/^filealloc(void)$/;"	f
fileclose	file.c	/^fileclose(struct file *f)$/;"	f
filedup	file.c	/^filedup(struct file *f)$/;"	f
fileinit	file.c	/^fileinit(void)$/;"	f
fileread	file.c	/^fileread(struct file *f, char *addr, int n)$/;"	f
filestat	file.c	/^filestat(struct file *f, struct stat *st)$/;"	f
filesz	elf.h	/^  uint filesz;$/;"	m	struct:proghdr
filewrite	file.c	/^filewrite(struct file *f, char *addr, int n)$/;"	f
finish_probe	bootasm.S	/^finish_probe:$/;"	l
flags	buf.h	/^  int flags;$/;"	m	struct:buf
flags	elf.h	/^  uint flags;$/;"	m	struct:elfhdr
flags	elf.h	/^  uint flags;$/;"	m	struct:proghdr
flags	fsvar.h	/^  int flags;          \/\/ I_BUSY, I_VALID$/;"	m	struct:inode
flags	mp.h	/^  uchar flags;                  \/\/ CPU flags$/;"	m	struct:mpproc
flags	mp.h	/^  uchar flags;                  \/\/ I\/O APIC flags$/;"	m	struct:mpioapic
flags	pmap.h	/^	uint32_t flags;  \/\/ flags for page descriptors$/;"	m	struct:Page
fmtname	ls.c	/^fmtname(char *path)$/;"	f
fname	usertests.asm	/^  fname = pid ? "f1" : "f2";$/;"	d
fork1	sh.c	/^fork1(void)$/;"	f
forkret	proc.c	/^forkret(void)$/;"	f
forkret1	trapasm.S	/^forkret1:$/;"	l
forktest	forktest.c	/^forktest(void)$/;"	f
forktest	usertests.c	/^forktest(void)$/;"	f
fourteen	usertests.c	/^fourteen(void)$/;"	f
free	umalloc.c	/^free(void *ap)$/;"	f
free_area	buddy.c	/^free_area_t free_area[MAX_ORDER];$/;"	v
free_area	buddy.h	/^typedef struct free_area {$/;"	s
free_area_t	buddy.h	/^} free_area_t;$/;"	t	typeref:struct:free_area
free_list	buddy.h	/^	page_list_head_t free_list;$/;"	m	struct:free_area
free_pages_bulk	buddy.c	/^free_pages_bulk(struct Page * page, int order)$/;"	f
freeblock	mkfs.c	/^uint freeblock;$/;"	v
freeinode	mkfs.c	/^uint freeinode = 1;$/;"	v
freelist	kalloc.c	/^struct run *freelist;$/;"	v	typeref:struct:run
freep	cat.asm	/^      freep = prevp;$/;"	d
freep	cat.asm	/^  freep = p;$/;"	d
freep	echo.asm	/^      freep = prevp;$/;"	d
freep	echo.asm	/^  freep = p;$/;"	d
freep	grep.asm	/^      freep = prevp;$/;"	d
freep	grep.asm	/^  freep = p;$/;"	d
freep	init.asm	/^      freep = prevp;$/;"	d
freep	init.asm	/^  freep = p;$/;"	d
freep	kill.asm	/^      freep = prevp;$/;"	d
freep	kill.asm	/^  freep = p;$/;"	d
freep	ln.asm	/^      freep = prevp;$/;"	d
freep	ln.asm	/^  freep = p;$/;"	d
freep	ls.asm	/^      freep = prevp;$/;"	d
freep	ls.asm	/^  freep = p;$/;"	d
freep	mkdir.asm	/^      freep = prevp;$/;"	d
freep	mkdir.asm	/^  freep = p;$/;"	d
freep	rm.asm	/^      freep = prevp;$/;"	d
freep	rm.asm	/^  freep = p;$/;"	d
freep	sh.asm	/^      freep = prevp;$/;"	d
freep	sh.asm	/^  freep = p;$/;"	d
freep	umalloc.c	/^static Header *freep;$/;"	v	file:
freep	usertests.asm	/^      freep = prevp;$/;"	d
freep	usertests.asm	/^  freep = p;$/;"	d
freep	wc.asm	/^      freep = prevp;$/;"	d
freep	wc.asm	/^  freep = p;$/;"	d
freep	zombie.asm	/^      freep = prevp;$/;"	d
freep	zombie.asm	/^  freep = p;$/;"	d
fs	mmu.h	/^  ushort fs;$/;"	m	struct:taskstate
fsfd	mkfs.c	/^int fsfd;$/;"	v
g	mmu.h	/^  uint g : 1;          \/\/ Granularity: limit scaled by 4K when set$/;"	m	struct:segdesc
gatedesc	mmu.h	/^struct gatedesc {$/;"	s
gdt	bootasm.S	/^gdt:$/;"	l
gdt	bootother.S	/^gdt:$/;"	l
gdt	meminfo.S	/^gdt:$/;"	l
gdt	proc.h	/^  struct segdesc gdt[NSEGS];  \/\/ x86 global descriptor table$/;"	m	struct:cpu	typeref:struct:cpu::segdesc
gdtdesc	bootasm.S	/^gdtdesc:$/;"	l
gdtdesc	bootother.S	/^gdtdesc:$/;"	l
gdtdesc	meminfo.S	/^gdtdesc:$/;"	l
get_pte	pmap.c	/^get_pte(pde_t * pgdir, vaddr_t va, int create)$/;"	f
getcallerpcs	spinlock.c	/^getcallerpcs(void *v, uint pcs[])$/;"	f
getcmd	sh.c	/^getcmd(char *buf, int nbuf)$/;"	f
gets	ulib.c	/^gets(char *buf, int max)$/;"	f
gettoken	sh.c	/^gettoken(char **ps, char *es, char **q, char **eq)$/;"	f
grep	grep.c	/^grep(char *pattern, int fd)$/;"	f
growproc	proc.c	/^growproc(int n)$/;"	f
gs	mmu.h	/^  ushort gs;$/;"	m	struct:taskstate
havekids	kernel.asm	/^        havekids = 1;$/;"	d
havekids	kernel.asm	/^    havekids = 0;$/;"	d
header	umalloc.c	/^union header {$/;"	u	file:
holding	spinlock.c	/^holding(struct spinlock *lock)$/;"	f
hp	cat.asm	/^  hp = (Header*)p;$/;"	d
hp	echo.asm	/^  hp = (Header*)p;$/;"	d
hp	grep.asm	/^  hp = (Header*)p;$/;"	d
hp	init.asm	/^  hp = (Header*)p;$/;"	d
hp	kill.asm	/^  hp = (Header*)p;$/;"	d
hp	ln.asm	/^  hp = (Header*)p;$/;"	d
hp	ls.asm	/^  hp = (Header*)p;$/;"	d
hp	mkdir.asm	/^  hp = (Header*)p;$/;"	d
hp	rm.asm	/^  hp = (Header*)p;$/;"	d
hp	sh.asm	/^  hp = (Header*)p;$/;"	d
hp	usertests.asm	/^  hp = (Header*)p;$/;"	d
hp	wc.asm	/^  hp = (Header*)p;$/;"	d
hp	zombie.asm	/^  hp = (Header*)p;$/;"	d
i	cat.asm	/^  i = 0;$/;"	d
i	echo.asm	/^  i = 0;$/;"	d
i	grep.asm	/^  i = 0;$/;"	d
i	init.asm	/^  i = 0;$/;"	d
i	kill.asm	/^  i = 0;$/;"	d
i	ln.asm	/^  i = 0;$/;"	d
i	ls.asm	/^  i = 0;$/;"	d
i	mkdir.asm	/^  i = 0;$/;"	d
i	rm.asm	/^  i = 0;$/;"	d
i	sh.asm	/^  i = 0;$/;"	d
i	usertests.asm	/^      i = de.name[1] - '0';$/;"	d
i	usertests.asm	/^    i = read(fd, buf, 512);$/;"	d
i	usertests.asm	/^  i = 0;$/;"	d
i	usertests.asm	/^  i = read(fd, buf, 2000);$/;"	d
i	wc.asm	/^  i = 0;$/;"	d
i	zombie.asm	/^  i = 0;$/;"	d
i2b	mkfs.c	/^i2b(uint inum)$/;"	f
i386_vm_init	pmap.c	/^i386_vm_init(void)$/;"	f
ialloc	fs.c	/^ialloc(uint dev, short type)$/;"	f
ialloc	mkfs.c	/^ialloc(ushort type)$/;"	f
iappend	mkfs.c	/^iappend(uint inum, void *xp, int n)$/;"	f
icache	fs.c	/^} icache;$/;"	v	typeref:struct:__anon6
id	kernel.asm	/^  id = ioapic_read(REG_ID) >> 24;$/;"	d
ide_init	ide.c	/^ide_init(void)$/;"	f
ide_intr	ide.c	/^ide_intr(void)$/;"	f
ide_lock	ide.c	/^static struct spinlock ide_lock;$/;"	v	typeref:struct:spinlock	file:
ide_queue	ide.c	/^static struct buf *ide_queue;$/;"	v	typeref:struct:buf	file:
ide_rw	ide.c	/^ide_rw(struct buf *b)$/;"	f
ide_start_request	ide.c	/^ide_start_request(struct buf *b)$/;"	f	file:
ide_wait_ready	ide.c	/^ide_wait_ready(int check_error)$/;"	f	file:
idt	trap.c	/^struct gatedesc idt[256];$/;"	v	typeref:struct:gatedesc
idtinit	trap.c	/^idtinit(void)$/;"	f
idup	fs.c	/^idup(struct inode *ip)$/;"	f
iget	fs.c	/^iget(uint dev, uint inum)$/;"	f	file:
iinit	fs.c	/^iinit(void)$/;"	f
ilock	fs.c	/^ilock(struct inode *ip)$/;"	f
imcrp	mp.h	/^  uchar imcrp;$/;"	m	struct:mp
inb	x86.h	/^inb(ushort port)$/;"	f
index	pmap.h	/^	uint32_t index;$/;"	m	struct:Page
init	initcode.S	/^init:$/;"	l
init_memmap	buddy.c	/^init_memmap(struct Page * base, unsigned long nr)$/;"	f
init_pages_list	kalloc.c	/^init_pages_list(paddr_t start_addr, uint len, uint32_t flags)$/;"	f
init_phypages	kalloc.c	/^init_phypages(void)$/;"	f
initlock	spinlock.c	/^initlock(struct spinlock *lock, char *name)$/;"	f
initproc	kernel.asm	/^  initproc = p;$/;"	d
initproc	proc.c	/^static struct proc *initproc;$/;"	v	typeref:struct:proc	file:
ino	stat.h	/^  uint ino;    \/\/ Inode number on device$/;"	m	struct:stat
inode	fs.c	/^  struct inode inode[NINODE];$/;"	m	struct:__anon6	typeref:struct:__anon6::inode	file:
inode	fsvar.h	/^struct inode {$/;"	s
input	console.c	/^} input;$/;"	v	typeref:struct:__anon1
insert_page	pmap.c	/^insert_page(pde_t * pgdir, paddr_t pa, vaddr_t va, uint perm)$/;"	f
insl	x86.h	/^insl(int port, void *addr, int cnt)$/;"	f
int	cat.asm	/^int$/;"	l
int	echo.asm	/^int$/;"	l
int	forktest.asm	/^int$/;"	l
int	grep.asm	/^int match(char*, char*);$/;"	l
int	grep.asm	/^int matchhere(char *re, char *text)$/;"	l
int	grep.asm	/^int matchhere(char*, char*);$/;"	l
int	grep.asm	/^int matchstar(int c, char *re, char *text)$/;"	l
int	grep.asm	/^int matchstar(int, char*, char*);$/;"	l
int	grep.asm	/^int$/;"	l
int	init.asm	/^int$/;"	l
int	kernel.asm	/^int ncpu;$/;"	l
int	kernel.asm	/^int ticks;$/;"	l
int	kernel.asm	/^int$/;"	l
int	kill.asm	/^int$/;"	l
int	ln.asm	/^int$/;"	l
int	ls.asm	/^int$/;"	l
int	mkdir.asm	/^int$/;"	l
int	rm.asm	/^int$/;"	l
int	sh.asm	/^int$/;"	l
int	usertests.asm	/^int$/;"	l
int	wc.asm	/^int$/;"	l
int	zombie.asm	/^int$/;"	l
intena	proc.h	/^  int intena;                 \/\/ Were interrupts enabled before pushcli? $/;"	m	struct:cpu
inum	fs.h	/^  ushort inum;$/;"	m	struct:dirent
inum	fsvar.h	/^  uint inum;          \/\/ Inode number$/;"	m	struct:inode
inum	kernel.asm	/^        inum = de->inum;$/;"	d
inword	wc.asm	/^        inword = 0;$/;"	d
inword	wc.asm	/^        inword = 1;$/;"	d
inword	wc.asm	/^  inword = 0;$/;"	d
ioapic	ioapic.c	/^struct ioapic {$/;"	s	file:
ioapic	ioapic.c	/^volatile struct ioapic *ioapic;$/;"	v	typeref:struct:ioapic
ioapic	kernel.asm	/^      ioapic = (struct mpioapic*)p;$/;"	d
ioapic	kernel.asm	/^  ioapic = (volatile struct ioapic*)IOAPIC;$/;"	d
ioapic_enable	ioapic.c	/^ioapic_enable(int irq, int cpunum)$/;"	f
ioapic_id	kernel.asm	/^      ioapic_id = ioapic->apicno;$/;"	d
ioapic_id	mp.c	/^uchar ioapic_id;$/;"	v
ioapic_init	ioapic.c	/^ioapic_init(void)$/;"	f
ioapic_read	ioapic.c	/^ioapic_read(int reg)$/;"	f	file:
ioapic_write	ioapic.c	/^ioapic_write(int reg, uint data)$/;"	f	file:
iomb	mmu.h	/^  ushort iomb;       \/\/ I\/O map base address$/;"	m	struct:taskstate
ip	file.h	/^  struct inode *ip;$/;"	m	struct:file	typeref:struct:file::inode
ip	kernel.asm	/^    ip = idup(cp->cwd);$/;"	d
ip	kernel.asm	/^    ip = iget(ROOTDEV, 1);$/;"	d
ip	kernel.asm	/^    ip = next;$/;"	d
ip	kernel.asm	/^  ip = empty;$/;"	d
iput	fs.c	/^iput(struct inode *ip)$/;"	f
iref	usertests.c	/^iref(void)$/;"	f
irqmask	kernel.asm	/^  irqmask = mask;$/;"	d
irqmask	picirq.c	/^static ushort irqmask = 0xFFFF & ~(1<<IRQ_SLAVE);$/;"	v	file:
isdirempty	sysfile.c	/^isdirempty(struct inode *dp)$/;"	f	file:
ismp	kernel.asm	/^  ismp = 1;$/;"	d
ismp	mp.c	/^int ismp;$/;"	v
itrunc	fs.c	/^itrunc(struct inode *ip)$/;"	f	file:
iunlock	fs.c	/^iunlock(struct inode *ip)$/;"	f
iunlockput	fs.c	/^iunlockput(struct inode *ip)$/;"	f
iupdate	fs.c	/^iupdate(struct inode *ip)$/;"	f
kalloc	kalloc.c	/^kalloc(int n)$/;"	f
kalloc_lock	kalloc.c	/^struct spinlock kalloc_lock;$/;"	v	typeref:struct:spinlock
kbd_getc	kbd.c	/^kbd_getc(void)$/;"	f
kbd_intr	kbd.c	/^kbd_intr(void)$/;"	f
kernel	kernel.asm	/^kernel:     file format elf32-i386$/;"	l
kfree	kalloc.c	/^kfree(char *v, int len)$/;"	f
kill	proc.c	/^kill(int pid)$/;"	f
killed	proc.h	/^  int killed;               \/\/ If non-zero, have been killed$/;"	m	struct:proc
kinit	kalloc.c	/^kinit(void)$/;"	f
kstack	proc.h	/^  char *kstack;             \/\/ Bottom of kernel stack for this process$/;"	m	struct:proc
l	wc.asm	/^  l = w = c = 0;$/;"	d
lapic	kernel.asm	/^  lapic = (uint*)conf->lapicaddr;$/;"	d
lapic	lapic.c	/^volatile uint *lapic;  \/\/ Initialized in mp.c$/;"	v
lapic_eoi	lapic.c	/^lapic_eoi(void)$/;"	f
lapic_init	lapic.c	/^lapic_init(int c)$/;"	f
lapic_startap	lapic.c	/^lapic_startap(uchar apicid, uint addr)$/;"	f
lapicaddr	mp.h	/^  uint *lapicaddr;              \/\/ address of local APIC$/;"	m	struct:mpconf
lapicw	lapic.c	/^lapicw(int index, int value)$/;"	f	file:
last	kernel.asm	/^      last = s+1;$/;"	d
lcmd	sh.asm	/^    lcmd = (struct listcmd*)cmd;$/;"	d
lcr0	x86.h	/^lcr0(uint val)$/;"	f
lcr3	x86.h	/^lcr3(uint val)$/;"	f
ldt	mmu.h	/^  ushort ldt;$/;"	m	struct:taskstate
left	sh.c	/^  struct cmd *left;$/;"	m	struct:listcmd	typeref:struct:listcmd::cmd	file:
left	sh.c	/^  struct cmd *left;$/;"	m	struct:pipecmd	typeref:struct:pipecmd::cmd	file:
len	kalloc.c	/^  int len; \/\/ bytes$/;"	m	struct:run	file:
len	kernel.asm	/^    len = (uint)e820_memmap->map[i].size;$/;"	d
len	kernel.asm	/^    len = strlen(argv[i]) + 1;$/;"	d
len	kernel.asm	/^  len = path - s;$/;"	d
length	mp.h	/^  uchar length;                 \/\/ 1$/;"	m	struct:mp
length	mp.h	/^  ushort length;                \/\/ total table length$/;"	m	struct:mpconf
lgdt	x86.h	/^lgdt(struct segdesc *p, int size)$/;"	f
lidt	x86.h	/^lidt(struct gatedesc *p, int size)$/;"	f
lim_15_0	mmu.h	/^  uint lim_15_0 : 16;  \/\/ Low bits of segment limit$/;"	m	struct:segdesc
lim_19_16	mmu.h	/^  uint lim_19_16 : 4;  \/\/ High bits of segment limit$/;"	m	struct:segdesc
link	mmu.h	/^  uint link;         \/\/ Old ts selector$/;"	m	struct:taskstate
linktest	usertests.c	/^linktest(void)$/;"	f
listcmd	sh.c	/^listcmd(struct cmd *left, struct cmd *right)$/;"	f
listcmd	sh.c	/^struct listcmd {$/;"	s	file:
lock	console.c	/^  struct spinlock lock;$/;"	m	struct:__anon1	typeref:struct:__anon1::spinlock	file:
lock	fs.c	/^  struct spinlock lock;$/;"	m	struct:__anon6	typeref:struct:__anon6::spinlock	file:
lock	pipe.c	/^  struct spinlock lock;$/;"	m	struct:pipe	typeref:struct:pipe::spinlock	file:
locked	spinlock.h	/^  uint locked;   \/\/ Is the lock held?$/;"	m	struct:spinlock
locking	kernel.asm	/^  locking = use_console_lock;$/;"	d
loop	kernel.asm	/^ loop:$/;"	l
lpt_putc	console.c	/^lpt_putc(int c)$/;"	f	file:
lru	pmap.h	/^	page_list_entry_t lru; \/* free list link *\/$/;"	m	struct:Page
ls	ls.c	/^ls(char *path)$/;"	f
ltr	x86.h	/^ltr(ushort sel)$/;"	f
m	grep.asm	/^      m = 0;$/;"	d
m	grep.asm	/^  m = 0;$/;"	d
m	kernel.asm	/^      m = 1 << (bi % 8);$/;"	d
m	kernel.asm	/^    m = min(n - tot, BSIZE - off%BSIZE);$/;"	d
m	kernel.asm	/^  m = 1 << (bi % 8);$/;"	d
m1	usertests.asm	/^      m1 = m2;$/;"	d
m1	usertests.asm	/^    m1 = 0;$/;"	d
m1	usertests.asm	/^    m1 = malloc(1024*20);$/;"	d
m2	usertests.asm	/^      m2 = *(char**)m1;$/;"	d
machine	elf.h	/^  ushort machine;$/;"	m	struct:elfhdr
magic	elf.h	/^  uint magic;  \/\/ must equal ELF_MAGIC$/;"	m	struct:elfhdr
main	cat.c	/^main(int argc, char *argv[])$/;"	f
main	echo.c	/^main(int argc, char *argv[])$/;"	f
main	forktest.c	/^main(void)$/;"	f
main	grep.c	/^main(int argc, char *argv[])$/;"	f
main	init.c	/^main(void)$/;"	f
main	kill.c	/^main(int argc, char **argv)$/;"	f
main	ln.c	/^main(int argc, char *argv[])$/;"	f
main	ls.c	/^main(int argc, char *argv[])$/;"	f
main	main.c	/^main(void)$/;"	f
main	mkdir.c	/^main(int argc, char *argv[])$/;"	f
main	mkfs.c	/^main(int argc, char *argv[])$/;"	f
main	rm.c	/^main(int argc, char *argv[])$/;"	f
main	sh.c	/^main(void)$/;"	f
main	usertests.c	/^main(int argc, char *argv[])$/;"	f
main	wc.c	/^main(int argc, char *argv[])$/;"	f
main	zombie.c	/^main(void)$/;"	f
major	fs.h	/^  short major;          \/\/ Major device number (T_DEV only)$/;"	m	struct:dinode
major	fsvar.h	/^  short major;$/;"	m	struct:inode
malloc	umalloc.c	/^malloc(uint nbytes)$/;"	f
map	pmap.h	/^	} map[E820MAX];$/;"	m	struct:e820map	typeref:struct:e820map::__anon2
mapcount	pmap.h	/^	atomic_t mapcount;  \/\/ number of page table entries that refer to the page frame$/;"	m	struct:Page
match	grep.c	/^match(char *re, char *text)$/;"	f
matchhere	grep.c	/^int matchhere(char *re, char *text)$/;"	f
matchstar	grep.c	/^int matchstar(int c, char *re, char *text)$/;"	f
maxintr	kernel.asm	/^  maxintr = (ioapic_read(REG_VER) >> 16) & 0xFF;$/;"	d
mem	kernel.asm	/^		  mem = (uint)(endaddr - baseaddr);$/;"	d
mem	kernel.asm	/^		  mem = e820_memmap->map[i].size;$/;"	d
mem	kernel.asm	/^  mem = 0;$/;"	d
mem	kernel.asm	/^  mem = kalloc(sz);$/;"	d
mem	proc.h	/^  char *mem;                \/\/ Start of process memory (kernel address)$/;"	m	struct:proc
mem	usertests.c	/^mem(void)$/;"	f
mem_map	buddy.c	/^struct Page * mem_map;$/;"	v	typeref:struct:Page
mem_map	kernel.asm	/^  mem_map = base;$/;"	d
memcmp	string.c	/^memcmp(const void *v1, const void *v2, uint n)$/;"	f
memmove	string.c	/^memmove(void *dst, const void *src, uint n)$/;"	f
memmove	ulib.c	/^memmove(void *vdst, void *vsrc, int n)$/;"	f
memset	string.c	/^memset(void *dst, int c, uint n)$/;"	f
memset	ulib.c	/^memset(void *dst, int c, uint n)$/;"	f
memsz	elf.h	/^  uint memsz;$/;"	m	struct:proghdr
microdelay	lapic.c	/^microdelay(int us)$/;"	f	file:
min	fs.c	25;"	d	file:
min	mkfs.c	236;"	d	file:
minor	fs.h	/^  short minor;          \/\/ Minor device number (T_DEV only)$/;"	m	struct:dinode
minor	fsvar.h	/^  short minor;$/;"	m	struct:inode
mode	sh.c	/^  int mode;$/;"	m	struct:redircmd	file:
morecore	umalloc.c	/^morecore(uint nu)$/;"	f	file:
mp	mp.h	/^struct mp {             \/\/ floating pointer$/;"	s
mp_bcpu	mp.c	/^mp_bcpu(void)$/;"	f
mp_config	mp.c	/^mp_config(struct mp **pmp)$/;"	f	file:
mp_init	mp.c	/^mp_init(void)$/;"	f
mp_search	mp.c	/^mp_search(void)$/;"	f	file:
mp_search1	mp.c	/^mp_search1(uchar *addr, int len)$/;"	f	file:
mpconf	mp.h	/^struct mpconf {         \/\/ configuration table header$/;"	s
mpioapic	mp.h	/^struct mpioapic {       \/\/ I\/O APIC table entry$/;"	s
mpmain	main.c	/^mpmain(void)$/;"	f	file:
mpproc	mp.h	/^struct mpproc {         \/\/ processor table entry$/;"	s
n	cat.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	cat.asm	/^  n = 0;$/;"	d
n	echo.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	echo.asm	/^  n = 0;$/;"	d
n	forktest.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	forktest.asm	/^  n = 0;$/;"	d
n	grep.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	grep.asm	/^  n = 0;$/;"	d
n	init.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	init.asm	/^  n = 0;$/;"	d
n	kernel.asm	/^    n = MAXFILE*BSIZE - off;$/;"	d
n	kernel.asm	/^    n = ip->size - off;$/;"	d
n	kill.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	kill.asm	/^  n = 0;$/;"	d
n	ln.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	ln.asm	/^  n = 0;$/;"	d
n	ls.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	ls.asm	/^  n = 0;$/;"	d
n	mkdir.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	mkdir.asm	/^  n = 0;$/;"	d
n	rm.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	rm.asm	/^  n = 0;$/;"	d
n	sh.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	sh.asm	/^  n = 0;$/;"	d
n	usertests.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	usertests.asm	/^  n = 0;$/;"	d
n	wc.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	wc.asm	/^  n = 0;$/;"	d
n	zombie.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	zombie.asm	/^  n = 0;$/;"	d
name	fs.h	/^  char name[DIRSIZ];$/;"	m	struct:dirent
name	proc.h	/^  char name[16];            \/\/ Process name (debugging)$/;"	m	struct:proc
name	spinlock.h	/^  char *name;    \/\/ Name of lock.$/;"	m	struct:spinlock
name	usertests.c	/^char name[3];$/;"	v
name	usys.S	/^  name: \\$/;"	l
namecmp	fs.c	/^namecmp(const char *s, const char *t)$/;"	f
namei	fs.c	/^namei(char *path)$/;"	f
nameiparent	fs.c	/^nameiparent(char *path, char *name)$/;"	f
nblocks	fs.h	/^  uint nblocks;      \/\/ Number of data blocks$/;"	m	struct:superblock
nblocks	mkfs.c	/^int nblocks = 995;$/;"	v
nc	usertests.asm	/^  nc = np = 0;$/;"	d
ncli	proc.h	/^  int ncli;                   \/\/ Depth of pushcli nesting.$/;"	m	struct:cpu
ncpu	mp.c	/^int ncpu;$/;"	v
neg	cat.asm	/^    neg = 1;$/;"	d
neg	cat.asm	/^  neg = 0;$/;"	d
neg	echo.asm	/^    neg = 1;$/;"	d
neg	echo.asm	/^  neg = 0;$/;"	d
neg	grep.asm	/^    neg = 1;$/;"	d
neg	grep.asm	/^  neg = 0;$/;"	d
neg	init.asm	/^    neg = 1;$/;"	d
neg	init.asm	/^  neg = 0;$/;"	d
neg	kernel.asm	/^    neg = 1;$/;"	d
neg	kill.asm	/^    neg = 1;$/;"	d
neg	kill.asm	/^  neg = 0;$/;"	d
neg	ln.asm	/^    neg = 1;$/;"	d
neg	ln.asm	/^  neg = 0;$/;"	d
neg	ls.asm	/^    neg = 1;$/;"	d
neg	ls.asm	/^  neg = 0;$/;"	d
neg	mkdir.asm	/^    neg = 1;$/;"	d
neg	mkdir.asm	/^  neg = 0;$/;"	d
neg	rm.asm	/^    neg = 1;$/;"	d
neg	rm.asm	/^  neg = 0;$/;"	d
neg	sh.asm	/^    neg = 1;$/;"	d
neg	sh.asm	/^  neg = 0;$/;"	d
neg	usertests.asm	/^    neg = 1;$/;"	d
neg	usertests.asm	/^  neg = 0;$/;"	d
neg	wc.asm	/^    neg = 1;$/;"	d
neg	wc.asm	/^  neg = 0;$/;"	d
neg	zombie.asm	/^    neg = 1;$/;"	d
neg	zombie.asm	/^  neg = 0;$/;"	d
newmem	kernel.asm	/^  newmem = kalloc(cp->sz + n);$/;"	d
next	buf.h	/^  struct buf *next;$/;"	m	struct:buf	typeref:struct:buf::buf
next	kalloc.c	/^  struct run *next;$/;"	m	struct:run	typeref:struct:run::run	file:
nextpid	proc.c	/^int nextpid = 1;$/;"	v
ninodes	fs.h	/^  uint ninodes;      \/\/ Number of inodes.$/;"	m	struct:superblock
ninodes	mkfs.c	/^int ninodes = 200;$/;"	v
nlink	fs.h	/^  short nlink;          \/\/ Number of links to inode in file system$/;"	m	struct:dinode
nlink	fsvar.h	/^  short nlink;$/;"	m	struct:inode
nlink	stat.h	/^  short nlink; \/\/ Number of links to file$/;"	m	struct:stat
normalmap	kbd.h	/^static uchar normalmap[256] =$/;"	v
npages	kalloc.c	/^uint npages;  \/\/ number of available pages$/;"	v
npages	kernel.asm	/^  npages = 0;$/;"	d
nr_free	buddy.h	/^	unsigned long nr_free;$/;"	m	struct:free_area
nr_map	pmap.h	/^	int nr_map;$/;"	m	struct:e820map
nu	cat.asm	/^    nu = PAGE;$/;"	d
nu	echo.asm	/^    nu = PAGE;$/;"	d
nu	grep.asm	/^    nu = PAGE;$/;"	d
nu	init.asm	/^    nu = PAGE;$/;"	d
nu	kill.asm	/^    nu = PAGE;$/;"	d
nu	ln.asm	/^    nu = PAGE;$/;"	d
nu	ls.asm	/^    nu = PAGE;$/;"	d
nu	mkdir.asm	/^    nu = PAGE;$/;"	d
nu	rm.asm	/^    nu = PAGE;$/;"	d
nu	sh.asm	/^    nu = PAGE;$/;"	d
nu	usertests.asm	/^    nu = PAGE;$/;"	d
nu	wc.asm	/^    nu = PAGE;$/;"	d
nu	zombie.asm	/^    nu = PAGE;$/;"	d
nulterminate	sh.c	/^nulterminate(struct cmd *cmd)$/;"	f
num	kernel.asm	/^  num = cp->tf->eax;$/;"	d
nunits	cat.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	echo.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	grep.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	init.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	kill.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	ln.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	ls.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	mkdir.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	rm.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	sh.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	usertests.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	wc.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	zombie.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
oemlength	mp.h	/^  ushort oemlength;             \/\/ OEM table length$/;"	m	struct:mpconf
oemtable	mp.h	/^  uint *oemtable;               \/\/ OEM table pointer$/;"	m	struct:mpconf
oesp	x86.h	/^  uint oesp;      \/\/ useless & ignored$/;"	m	struct:trapframe
off	file.h	/^  uint off;$/;"	m	struct:file
off_15_0	mmu.h	/^  uint off_15_0 : 16;   \/\/ low 16 bits of offset in segment$/;"	m	struct:gatedesc
off_31_16	mmu.h	/^  uint off_31_16 : 16;  \/\/ high bits of offset in segment$/;"	m	struct:gatedesc
offset	bootblock.asm	/^  offset = (offset \/ SECTSIZE) + 1;$/;"	d
offset	elf.h	/^  uint offset;$/;"	m	struct:proghdr
ofile	proc.h	/^  struct file *ofile[NOFILE];  \/\/ Open files$/;"	m	struct:proc	typeref:struct:proc::file
opentest	usertests.c	/^opentest(void)$/;"	f
os	cat.asm	/^  os = s;$/;"	d
os	echo.asm	/^  os = s;$/;"	d
os	forktest.asm	/^  os = s;$/;"	d
os	grep.asm	/^  os = s;$/;"	d
os	init.asm	/^  os = s;$/;"	d
os	kernel.asm	/^  os = s;$/;"	d
os	kill.asm	/^  os = s;$/;"	d
os	ln.asm	/^  os = s;$/;"	d
os	ls.asm	/^  os = s;$/;"	d
os	mkdir.asm	/^  os = s;$/;"	d
os	rm.asm	/^  os = s;$/;"	d
os	sh.asm	/^  os = s;$/;"	d
os	usertests.asm	/^  os = s;$/;"	d
os	wc.asm	/^  os = s;$/;"	d
os	zombie.asm	/^  os = s;$/;"	d
out	kernel.asm	/^ out:$/;"	l
outb	x86.h	/^outb(ushort port, uchar data)$/;"	f
outsl	x86.h	/^outsl(int port, const void *addr, int cnt)$/;"	f
outw	x86.h	/^outw(ushort port, ushort data)$/;"	f
p	cat.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	echo.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	grep.asm	/^      p = q+1;$/;"	d
p	grep.asm	/^    p = buf;$/;"	d
p	grep.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	init.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	kernel.asm	/^      p = &proc[i];$/;"	d
p	kernel.asm	/^      p = (char*)r + r->len;$/;"	d
p	kernel.asm	/^    p = &proc[i];$/;"	d
p	kernel.asm	/^    p = ((bda[0x14]<<8)|bda[0x13])*1024;$/;"	d
p	kernel.asm	/^  p = (struct run*)v;$/;"	d
p	kernel.asm	/^  p = 0;$/;"	d
p	kernel.asm	/^  p = copyproc(0);$/;"	d
p	kernel.asm	/^  p = cpus[cpu()].curproc;$/;"	d
p	kill.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	ln.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	ls.asm	/^    p = buf+strlen(buf);$/;"	d
p	ls.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	mkdir.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	mmu.h	/^  uint p : 1;           \/\/ Present$/;"	m	struct:gatedesc
p	mmu.h	/^  uint p : 1;          \/\/ Present$/;"	m	struct:segdesc
p	rm.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	sh.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	usertests.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	wc.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	zombie.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
pa	elf.h	/^  uint pa;$/;"	m	struct:proghdr
pad	ioapic.c	/^  uint pad[3];$/;"	m	struct:ioapic	file:
padding1	mmu.h	/^  ushort padding1;$/;"	m	struct:taskstate
padding1	x86.h	/^  ushort padding1;$/;"	m	struct:trapframe
padding10	mmu.h	/^  ushort padding10;$/;"	m	struct:taskstate
padding2	mmu.h	/^  ushort padding2;$/;"	m	struct:taskstate
padding2	x86.h	/^  ushort padding2;$/;"	m	struct:trapframe
padding3	mmu.h	/^  ushort padding3;$/;"	m	struct:taskstate
padding3	x86.h	/^  ushort padding3;$/;"	m	struct:trapframe
padding4	mmu.h	/^  ushort padding4;$/;"	m	struct:taskstate
padding4	x86.h	/^  ushort padding4;$/;"	m	struct:trapframe
padding5	mmu.h	/^  ushort padding5;$/;"	m	struct:taskstate
padding6	mmu.h	/^  ushort padding6;$/;"	m	struct:taskstate
padding7	mmu.h	/^  ushort padding7;$/;"	m	struct:taskstate
padding8	mmu.h	/^  ushort padding8;$/;"	m	struct:taskstate
padding9	mmu.h	/^  ushort padding9;$/;"	m	struct:taskstate
paddr_t	types.h	/^typedef uint paddr_t;$/;"	t
page	kernel.asm	/^    page = LIST_FIRST(&(free_area[current_order].free_list));$/;"	d
page_frame	pmap.h	48;"	d
page_is_buddy	buddy.c	/^page_is_buddy(struct Page * page, int order)$/;"	f
page_list_entry_t	pmap.h	/^typedef LIST_ENTRY(Page) page_list_entry_t;$/;"	t
page_list_head_t	pmap.h	/^typedef LIST_HEAD(Page_list, Page) page_list_head_t;$/;"	t
page_t	pmap.h	/^typedef struct Page page_t;$/;"	t	typeref:struct:Page
page_table_lock	proc.h	/^  spinlock_t page_table_lock;  \/\/ Page table's spin lock$/;"	m	struct:proc_vm
pages	kernel.asm	/^  pages = (struct Page *)start;$/;"	d
pages	pmap.c	/^struct Page * pages;    \/\/ Physical Page descriptor array$/;"	v	typeref:struct:Page
pages	pmap.c	/^struct Page * pages;    \/\/ all page descriptors $/;"	v	typeref:struct:Page
panic	console.c	/^panic(char *s)$/;"	f
panic	sh.c	/^panic(char *s)$/;"	f
panicked	console.c	/^int panicked = 0;$/;"	v
panicked	kernel.asm	/^  panicked = 1; \/\/ freeze other CPU$/;"	d
parent	proc.h	/^  struct proc *parent;      \/\/ Parent process$/;"	m	struct:proc	typeref:struct:proc::proc
parseblock	sh.c	/^parseblock(char **ps, char *es)$/;"	f
parsecmd	sh.c	/^parsecmd(char *s)$/;"	f
parseexec	sh.c	/^parseexec(char **ps, char *es)$/;"	f
parseline	sh.c	/^parseline(char **ps, char *es)$/;"	f
parsepipe	sh.c	/^parsepipe(char **ps, char *es)$/;"	f
parseredirs	sh.c	/^parseredirs(struct cmd *cmd, char **ps, char *es)$/;"	f
pattern	grep.asm	/^  pattern = argv[1];$/;"	d
pcmd	sh.asm	/^    pcmd = (struct pipecmd*)cmd;$/;"	d
pcs	spinlock.h	/^  uint pcs[10];  \/\/ The call stack (an array of program counters)$/;"	m	struct:spinlock
pde_t	types.h	/^typedef uint pde_t;$/;"	t
peek	sh.c	/^peek(char **ps, char *es, char *toks)$/;"	f
pend	kernel.asm	/^  pend = (struct run*)(v + len);$/;"	d
pgdir	kernel.asm	/^	pgdir = (pde_t *)alloc_page();$/;"	d
pgdir	kernel.asm	/^  pgdir = (pde_t *)alloc_page();$/;"	d
pgdir	proc.h	/^  pde_t * pgdir;            \/\/ Pointer to the page directory$/;"	m	struct:proc_vm
ph	bootblock.asm	/^  ph = (struct proghdr*)((uchar*)elf + elf->phoff);$/;"	d
phentsize	elf.h	/^  ushort phentsize;$/;"	m	struct:elfhdr
phnum	elf.h	/^  ushort phnum;$/;"	m	struct:elfhdr
phoff	elf.h	/^  uint phoff;$/;"	m	struct:elfhdr
phy_mem_lock	pmap.c	/^spinlock_t phy_mem_lock;$/;"	v
physaddr	mp.h	/^  void *physaddr;               \/\/ phys addr of MP config table$/;"	m	struct:mp
pic_enable	picirq.c	/^pic_enable(int irq)$/;"	f
pic_init	picirq.c	/^pic_init(void)$/;"	f
pic_setmask	picirq.c	/^pic_setmask(ushort mask)$/;"	f	file:
pid	forktest.asm	/^    pid = fork();$/;"	d
pid	init.asm	/^    pid = fork();$/;"	d
pid	kernel.asm	/^          pid = p->pid;$/;"	d
pid	kernel.asm	/^  pid = np->pid;$/;"	d
pid	proc.h	/^  int pid;                  \/\/ Process ID$/;"	m	struct:proc
pid	sh.asm	/^  pid = fork();$/;"	d
pid	usertests.asm	/^    pid = fork();$/;"	d
pid	usertests.asm	/^  pid = fork();$/;"	d
pid1	usertests.asm	/^  pid1 = fork();$/;"	d
pid2	usertests.asm	/^  pid2 = fork();$/;"	d
pid3	usertests.asm	/^  pid3 = fork();$/;"	d
pinit	proc.c	/^pinit(void)$/;"	f
pipe	file.h	/^  struct pipe *pipe;$/;"	m	struct:file	typeref:struct:file::pipe
pipe	pipe.c	/^struct pipe {$/;"	s	file:
pipe1	usertests.c	/^pipe1(void)$/;"	f
pipealloc	pipe.c	/^pipealloc(struct file **f0, struct file **f1)$/;"	f
pipeclose	pipe.c	/^pipeclose(struct pipe *p, int writable)$/;"	f
pipecmd	sh.c	/^pipecmd(struct cmd *left, struct cmd *right)$/;"	f
pipecmd	sh.c	/^struct pipecmd {$/;"	s	file:
piperead	pipe.c	/^piperead(struct pipe *p, char *addr, int n)$/;"	f
pipewrite	pipe.c	/^pipewrite(struct pipe *p, char *addr, int n)$/;"	f
popcli	spinlock.c	/^popcli(void)$/;"	f
pos	kernel.asm	/^  pos = inb(CRTPORT+1) << 8;$/;"	d
preempt	usertests.c	/^preempt(void)$/;"	f
prev	buf.h	/^  struct buf *prev; \/\/ LRU cache list$/;"	m	struct:buf	typeref:struct:buf::buf
print_buddy	buddy.c	/^print_buddy()$/;"	f
printf	forktest.c	/^printf(int fd, char *s, ...)$/;"	f
printf	printf.c	/^printf(int fd, char *fmt, ...)$/;"	f
printint	console.c	/^printint(int xx, int base, int sgn)$/;"	f
printint	printf.c	/^printint(int fd, int xx, int base, int sgn)$/;"	f	file:
probe_memory	bootasm.S	/^probe_memory:$/;"	l
probe_memory	bootblock.asm	/^probe_memory:$/;"	l
proc	kernel.asm	/^      proc = (struct mpproc*)p;$/;"	d
proc	proc.c	/^struct proc proc[NPROC];$/;"	v	typeref:struct:proc
proc	proc.h	/^struct proc {$/;"	s
proc_state	proc.h	/^enum proc_state { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	g
proc_table_lock	proc.c	/^struct spinlock proc_table_lock;$/;"	v	typeref:struct:spinlock
proc_vm	proc.h	/^struct proc_vm {$/;"	s
procdump	proc.c	/^procdump(void)$/;"	f
product	mp.h	/^  uchar product[20];            \/\/ product id$/;"	m	struct:mpconf
proghdr	elf.h	/^struct proghdr {$/;"	s
property	pmap.h	/^	uint32_t property;  \/\/ when the page is free , this field is used by the buddy system$/;"	m	struct:Page
protcseg	bootasm.S	/^protcseg:$/;"	l
protcseg	bootblock.asm	/^protcseg:$/;"	l
protcseg	bootother.S	/^protcseg:$/;"	l
protcseg	meminfo.S	/^protcseg:$/;"	l
pte	kernel.asm	/^			pte = (pte_t *)alloc_page();$/;"	d
pte	kernel.asm	/^	pte = &(((pte_t *)PTE_ADDR(*pde))[PTX(va)]);$/;"	d
pte_t	kernel.asm	/^pte_t *$/;"	l
pte_t	types.h	/^typedef uint pte_t;$/;"	t
ptr	umalloc.c	/^    union header *ptr;$/;"	m	struct:header::__anon5	typeref:union:header::__anon5::header	file:
pushcli	spinlock.c	/^pushcli(void)$/;"	f
putc	printf.c	/^putc(int fd, char c)$/;"	f	file:
qnext	buf.h	/^  struct buf *qnext; \/\/ disk queue$/;"	m	struct:buf	typeref:struct:buf::buf
r	cat.asm	/^  r = fstat(fd, st);$/;"	d
r	console.c	/^  uint r;  \/\/ Read index$/;"	m	struct:__anon1	file:
r	echo.asm	/^  r = fstat(fd, st);$/;"	d
r	forktest.asm	/^  r = fstat(fd, st);$/;"	d
r	grep.asm	/^  r = fstat(fd, st);$/;"	d
r	init.asm	/^  r = fstat(fd, st);$/;"	d
r	kill.asm	/^  r = fstat(fd, st);$/;"	d
r	ln.asm	/^  r = fstat(fd, st);$/;"	d
r	ls.asm	/^  r = fstat(fd, st);$/;"	d
r	mkdir.asm	/^  r = fstat(fd, st);$/;"	d
r	rm.asm	/^  r = fstat(fd, st);$/;"	d
r	sh.asm	/^  r = fstat(fd, st);$/;"	d
r	usertests.asm	/^  r = fstat(fd, st);$/;"	d
r	wc.asm	/^  r = fstat(fd, st);$/;"	d
r	zombie.asm	/^  r = fstat(fd, st);$/;"	d
rcmd	sh.asm	/^    rcmd = (struct redircmd*)cmd;$/;"	d
rcr0	x86.h	/^rcr0(void)$/;"	f
rcr3	x86.h	/^rcr3(void)$/;"	f
read	dev.h	/^  int (*read)(struct inode*, char*, int);$/;"	m	struct:devsw
read_ebp	x86.h	/^read_ebp(void)$/;"	f
read_eflags	x86.h	/^read_eflags(void)$/;"	f
readable	file.h	/^  char readable;$/;"	m	struct:file
readi	fs.c	/^readi(struct inode *ip, char *dst, uint off, uint n)$/;"	f
readopen	pipe.c	/^  int readopen;   \/\/ read fd is still open$/;"	m	struct:pipe	file:
readp	pipe.c	/^  uint readp;     \/\/ next index to read$/;"	m	struct:pipe	file:
readsb	fs.c	/^readsb(int dev, struct superblock *sb)$/;"	f	file:
readsect	bootmain.c	/^readsect(void *dst, uint offset)$/;"	f
readseg	bootmain.c	/^readseg(uint va, uint count, uint offset)$/;"	f
realcseg	meminfo.S	/^realcseg:$/;"	l
redircmd	sh.c	/^redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)$/;"	f
redircmd	sh.c	/^struct redircmd {$/;"	s	file:
ref	file.h	/^  int ref; \/\/ reference count$/;"	m	struct:file
ref	fsvar.h	/^  int ref;            \/\/ Reference count$/;"	m	struct:inode
reg	ioapic.c	/^  uint reg;$/;"	m	struct:ioapic	file:
release	spinlock.c	/^release(struct spinlock *lock)$/;"	f
remove_page	pmap.c	/^remove_page()$/;"	f
rend	kernel.asm	/^    rend = (struct run*)((char*)r + r->len);$/;"	d
reserved	mp.h	/^  uchar reserved;$/;"	m	struct:mpconf
reserved	mp.h	/^  uchar reserved[3];$/;"	m	struct:mp
reserved	mp.h	/^  uchar reserved[8];$/;"	m	struct:mpproc
ret	kernel.asm	/^		ret = check_va2pa(i);$/;"	d
ret	sh.asm	/^      ret = '+';$/;"	d
ret	sh.asm	/^    ret = 'a';$/;"	d
ret	sh.asm	/^    ret = parseredirs(ret, ps, es);$/;"	d
ret	sh.asm	/^  ret = *s;$/;"	d
ret	sh.asm	/^  ret = execcmd();$/;"	d
ret	sh.asm	/^  ret = parseredirs(ret, ps, es);$/;"	d
right	sh.c	/^  struct cmd *right;$/;"	m	struct:listcmd	typeref:struct:listcmd::cmd	file:
right	sh.c	/^  struct cmd *right;$/;"	m	struct:pipecmd	typeref:struct:pipecmd::cmd	file:
rinode	mkfs.c	/^rinode(uint inum, struct dinode *ip)$/;"	f
rmdot	usertests.c	/^rmdot(void)$/;"	f
rsect	mkfs.c	/^rsect(uint sec, void *buf)$/;"	f
rsv1	mmu.h	/^  uint rsv1 : 1;       \/\/ Reserved$/;"	m	struct:segdesc
rsv1	mmu.h	/^  uint rsv1 : 3;        \/\/ reserved(should be zero I guess)$/;"	m	struct:gatedesc
run	kalloc.c	/^struct run {$/;"	s	file:
runcmd	sh.c	/^runcmd(struct cmd *cmd)$/;"	f
s	cat.asm	/^          s = "(null)";$/;"	d
s	cat.asm	/^        s = (char*)*ap;$/;"	d
s	echo.asm	/^          s = "(null)";$/;"	d
s	echo.asm	/^        s = (char*)*ap;$/;"	d
s	grep.asm	/^          s = "(null)";$/;"	d
s	grep.asm	/^        s = (char*)*ap;$/;"	d
s	init.asm	/^          s = "(null)";$/;"	d
s	init.asm	/^        s = (char*)*ap;$/;"	d
s	kernel.asm	/^          s = "(null)";$/;"	d
s	kernel.asm	/^        s = (char*)*argp++;$/;"	d
s	kernel.asm	/^  s = path;$/;"	d
s	kernel.asm	/^  s = src;$/;"	d
s	kill.asm	/^          s = "(null)";$/;"	d
s	kill.asm	/^        s = (char*)*ap;$/;"	d
s	ln.asm	/^          s = "(null)";$/;"	d
s	ln.asm	/^        s = (char*)*ap;$/;"	d
s	ls.asm	/^          s = "(null)";$/;"	d
s	ls.asm	/^        s = (char*)*ap;$/;"	d
s	mkdir.asm	/^          s = "(null)";$/;"	d
s	mkdir.asm	/^        s = (char*)*ap;$/;"	d
s	mmu.h	/^  uint s : 1;           \/\/ must be 0 (system)$/;"	m	struct:gatedesc
s	mmu.h	/^  uint s : 1;          \/\/ 0 = system, 1 = application$/;"	m	struct:segdesc
s	rm.asm	/^          s = "(null)";$/;"	d
s	rm.asm	/^        s = (char*)*ap;$/;"	d
s	sh.asm	/^          s = "(null)";$/;"	d
s	sh.asm	/^        s = (char*)*ap;$/;"	d
s	sh.asm	/^  s = *ps;$/;"	d
s	umalloc.c	/^  } s;$/;"	m	union:header	typeref:struct:header::__anon5	file:
s	usertests.asm	/^          s = "(null)";$/;"	d
s	usertests.asm	/^        s = (char*)*ap;$/;"	d
s	wc.asm	/^          s = "(null)";$/;"	d
s	wc.asm	/^        s = (char*)*ap;$/;"	d
s	zombie.asm	/^          s = "(null)";$/;"	d
s	zombie.asm	/^        s = (char*)*ap;$/;"	d
s1	kernel.asm	/^  s1 = v1;$/;"	d
s2	kernel.asm	/^  s2 = v2;$/;"	d
safestrcpy	string.c	/^safestrcpy(char *s, const char *t, int n)$/;"	f
sb	mkfs.c	/^struct superblock sb;$/;"	v	typeref:struct:superblock
sched	proc.c	/^sched(void)$/;"	f
scheduler	proc.c	/^scheduler(void)$/;"	f
sector	buf.h	/^  uint sector;$/;"	m	struct:buf
segdesc	mmu.h	/^struct segdesc {$/;"	s
segment	meminfo.S	/^segment .text$/;"	l
seq	usertests.asm	/^  seq = 0;$/;"	d
setupsegs	proc.c	/^setupsegs(struct proc *p)$/;"	f
sh_args	init.c	/^char *sh_args[] = { "sh", 0 };$/;"	v
sharedfd	usertests.c	/^sharedfd(void)$/;"	f
shentsize	elf.h	/^  ushort shentsize;$/;"	m	struct:elfhdr
shiftcode	kbd.h	/^static uchar shiftcode[256] =$/;"	v
shiftmap	kbd.h	/^static uchar shiftmap[256] =$/;"	v
shnum	elf.h	/^  ushort shnum;$/;"	m	struct:elfhdr
shoff	elf.h	/^  uint shoff;$/;"	m	struct:elfhdr
shstrndx	elf.h	/^  ushort shstrndx;$/;"	m	struct:elfhdr
signature	mp.h	/^  uchar signature[4];           \/\/ "PCMP"$/;"	m	struct:mpconf
signature	mp.h	/^  uchar signature[4];           \/\/ "_MP_"$/;"	m	struct:mp
signature	mp.h	/^  uchar signature[4];           \/\/ CPU signature$/;"	m	struct:mpproc
size	fs.h	/^  uint size;            \/\/ Size of file (bytes)$/;"	m	struct:dinode
size	fs.h	/^  uint size;         \/\/ Size of file system image (blocks)$/;"	m	struct:superblock
size	fsvar.h	/^  uint size;$/;"	m	struct:inode
size	kernel.asm	/^  size = 1 << current_order;$/;"	d
size	mkfs.c	/^int size = 1024;$/;"	v
size	pmap.h	/^		long long size;$/;"	m	struct:e820map::__anon2
size	stat.h	/^  uint size;   \/\/ Size of file in bytes$/;"	m	struct:stat
size	umalloc.c	/^    uint size;$/;"	m	struct:header::__anon5	file:
skipelem	fs.c	/^skipelem(char *path, char *name)$/;"	f	file:
sleep	proc.c	/^sleep(void *chan, struct spinlock *lk)$/;"	f
sp	kernel.asm	/^  sp = argp;$/;"	d
sp	kernel.asm	/^  sp = sz;$/;"	d
specrev	mp.h	/^  uchar specrev;                \/\/ [14]$/;"	m	struct:mp
spin	bootasm.S	/^spin:$/;"	l
spin	bootblock.asm	/^spin:$/;"	l
spin	meminfo.S	/^spin:$/;"	l
spinlock	spinlock.h	/^struct spinlock {$/;"	s
spinlock_t	spinlock.h	/^typedef struct spinlock spinlock_t;$/;"	t	typeref:struct:spinlock
src	cat.asm	/^  src = vsrc;$/;"	d
src	echo.asm	/^  src = vsrc;$/;"	d
src	forktest.asm	/^  src = vsrc;$/;"	d
src	grep.asm	/^  src = vsrc;$/;"	d
src	init.asm	/^  src = vsrc;$/;"	d
src	kill.asm	/^  src = vsrc;$/;"	d
src	ln.asm	/^  src = vsrc;$/;"	d
src	ls.asm	/^  src = vsrc;$/;"	d
src	mkdir.asm	/^  src = vsrc;$/;"	d
src	rm.asm	/^  src = vsrc;$/;"	d
src	sh.asm	/^  src = vsrc;$/;"	d
src	usertests.asm	/^  src = vsrc;$/;"	d
src	wc.asm	/^  src = vsrc;$/;"	d
src	zombie.asm	/^  src = vsrc;$/;"	d
ss	mmu.h	/^  ushort ss;$/;"	m	struct:taskstate
ss	x86.h	/^  ushort ss;$/;"	m	struct:trapframe
ss0	mmu.h	/^  ushort ss0;        \/\/   after an increase in privilege level$/;"	m	struct:taskstate
ss1	mmu.h	/^  ushort ss1;$/;"	m	struct:taskstate
ss2	mmu.h	/^  ushort ss2;$/;"	m	struct:taskstate
st	kernel.asm	/^  st = inb(KBSTATP);$/;"	d
stack	kernel.asm	/^    stack = kalloc(KSTACKSIZE);$/;"	d
start	bootasm.S	/^start:$/;"	l
start	bootblock.asm	/^start:$/;"	l
start	bootother.S	/^start:$/;"	l
start	initcode.S	/^start:$/;"	l
start	kalloc.c	/^char * start;  \/\/ start address after kernel$/;"	v
start	kernel.asm	/^  start = (char*) &end;$/;"	d
start	kernel.asm	/^  start = (char*) (((uint)start + PAGE) & ~(PAGE-1));$/;"	d
start_code	proc.h	/^  vaddr_t start_code;       \/\/ Initial address of executable code$/;"	m	struct:proc_vm
start_data	proc.h	/^  vaddr_t start_data;       \/\/ Initial address of data$/;"	m	struct:proc_vm
start_probe	bootasm.S	/^start_probe:$/;"	l
start_probe	bootblock.asm	/^start_probe:$/;"	l
start_stack	proc.h	/^  vaddr_t start_stack;      \/\/ Initial address of user mode stack$/;"	m	struct:proc_vm
stat	stat.h	/^struct stat {$/;"	s
stat	ulib.c	/^stat(char *n, struct stat *st)$/;"	f
state	cat.asm	/^        state = '%';$/;"	d
state	cat.asm	/^      state = 0;$/;"	d
state	cat.asm	/^  state = 0;$/;"	d
state	echo.asm	/^        state = '%';$/;"	d
state	echo.asm	/^      state = 0;$/;"	d
state	echo.asm	/^  state = 0;$/;"	d
state	grep.asm	/^        state = '%';$/;"	d
state	grep.asm	/^      state = 0;$/;"	d
state	grep.asm	/^  state = 0;$/;"	d
state	init.asm	/^        state = '%';$/;"	d
state	init.asm	/^      state = 0;$/;"	d
state	init.asm	/^  state = 0;$/;"	d
state	kernel.asm	/^        state = '%';$/;"	d
state	kernel.asm	/^      state = "???";$/;"	d
state	kernel.asm	/^      state = 0;$/;"	d
state	kernel.asm	/^      state = states[p->state];$/;"	d
state	kernel.asm	/^  state = 0;$/;"	d
state	kill.asm	/^        state = '%';$/;"	d
state	kill.asm	/^      state = 0;$/;"	d
state	kill.asm	/^  state = 0;$/;"	d
state	ln.asm	/^        state = '%';$/;"	d
state	ln.asm	/^      state = 0;$/;"	d
state	ln.asm	/^  state = 0;$/;"	d
state	ls.asm	/^        state = '%';$/;"	d
state	ls.asm	/^      state = 0;$/;"	d
state	ls.asm	/^  state = 0;$/;"	d
state	mkdir.asm	/^        state = '%';$/;"	d
state	mkdir.asm	/^      state = 0;$/;"	d
state	mkdir.asm	/^  state = 0;$/;"	d
state	proc.h	/^  enum proc_state state;    \/\/ Process state$/;"	m	struct:proc	typeref:enum:proc::proc_state
state	rm.asm	/^        state = '%';$/;"	d
state	rm.asm	/^      state = 0;$/;"	d
state	rm.asm	/^  state = 0;$/;"	d
state	sh.asm	/^        state = '%';$/;"	d
state	sh.asm	/^      state = 0;$/;"	d
state	sh.asm	/^  state = 0;$/;"	d
state	usertests.asm	/^        state = '%';$/;"	d
state	usertests.asm	/^      state = 0;$/;"	d
state	usertests.asm	/^  state = 0;$/;"	d
state	wc.asm	/^        state = '%';$/;"	d
state	wc.asm	/^      state = 0;$/;"	d
state	wc.asm	/^  state = 0;$/;"	d
state	zombie.asm	/^        state = '%';$/;"	d
state	zombie.asm	/^      state = 0;$/;"	d
state	zombie.asm	/^  state = 0;$/;"	d
stati	fs.c	/^stati(struct inode *ip, struct stat *st)$/;"	f
static	bootblock.asm	/^static inline uchar$/;"	l
static	bootblock.asm	/^static inline void$/;"	l
static	cat.asm	/^static Header *freep;$/;"	l
static	cat.asm	/^static Header base;$/;"	l
static	cat.asm	/^static Header*$/;"	l
static	cat.asm	/^static void$/;"	l
static	echo.asm	/^static Header *freep;$/;"	l
static	echo.asm	/^static Header base;$/;"	l
static	echo.asm	/^static Header*$/;"	l
static	echo.asm	/^static void$/;"	l
static	grep.asm	/^static Header *freep;$/;"	l
static	grep.asm	/^static Header base;$/;"	l
static	grep.asm	/^static Header*$/;"	l
static	grep.asm	/^static void$/;"	l
static	init.asm	/^static Header *freep;$/;"	l
static	init.asm	/^static Header base;$/;"	l
static	init.asm	/^static Header*$/;"	l
static	init.asm	/^static void$/;"	l
static	kernel.asm	/^static char*$/;"	l
static	kernel.asm	/^static inline uchar$/;"	l
static	kernel.asm	/^static inline uint$/;"	l
static	kernel.asm	/^static inline void$/;"	l
static	kernel.asm	/^static int$/;"	l
static	kernel.asm	/^static paddr_t$/;"	l
static	kernel.asm	/^static struct buf*$/;"	t
static	kernel.asm	/^static struct inode*$/;"	t
static	kernel.asm	/^static struct mp*$/;"	t
static	kernel.asm	/^static struct proc*$/;"	t
static	kernel.asm	/^static uchar$/;"	l
static	kernel.asm	/^static uint$/;"	l
static	kernel.asm	/^static ushort irqmask = 0xFFFF & ~(1<<IRQ_SLAVE);$/;"	l
static	kernel.asm	/^static void check_boot_pgdir();$/;"	l
static	kernel.asm	/^static void ide_start_request();$/;"	l
static	kernel.asm	/^static void itrunc(struct inode*);$/;"	l
static	kernel.asm	/^static void mpmain(void) __attribute__((noreturn));$/;"	l
static	kernel.asm	/^static void$/;"	l
static	kill.asm	/^static Header *freep;$/;"	l
static	kill.asm	/^static Header base;$/;"	l
static	kill.asm	/^static Header*$/;"	l
static	kill.asm	/^static void$/;"	l
static	ln.asm	/^static Header *freep;$/;"	l
static	ln.asm	/^static Header base;$/;"	l
static	ln.asm	/^static Header*$/;"	l
static	ln.asm	/^static void$/;"	l
static	ls.asm	/^static Header *freep;$/;"	l
static	ls.asm	/^static Header base;$/;"	l
static	ls.asm	/^static Header*$/;"	l
static	ls.asm	/^static void$/;"	l
static	mkdir.asm	/^static Header *freep;$/;"	l
static	mkdir.asm	/^static Header base;$/;"	l
static	mkdir.asm	/^static Header*$/;"	l
static	mkdir.asm	/^static void$/;"	l
static	rm.asm	/^static Header *freep;$/;"	l
static	rm.asm	/^static Header base;$/;"	l
static	rm.asm	/^static Header*$/;"	l
static	rm.asm	/^static void$/;"	l
static	sh.asm	/^static Header *freep;$/;"	l
static	sh.asm	/^static Header base;$/;"	l
static	sh.asm	/^static Header*$/;"	l
static	sh.asm	/^static void$/;"	l
static	usertests.asm	/^static Header *freep;$/;"	l
static	usertests.asm	/^static Header base;$/;"	l
static	usertests.asm	/^static Header*$/;"	l
static	usertests.asm	/^static void$/;"	l
static	wc.asm	/^static Header *freep;$/;"	l
static	wc.asm	/^static Header base;$/;"	l
static	wc.asm	/^static Header*$/;"	l
static	wc.asm	/^static void$/;"	l
static	zombie.asm	/^static Header *freep;$/;"	l
static	zombie.asm	/^static Header base;$/;"	l
static	zombie.asm	/^static Header*$/;"	l
static	zombie.asm	/^static void$/;"	l
static_assert	assert.h	8;"	d
stdout	usertests.c	/^int stdout = 1;$/;"	v
sti	x86.h	/^sti(void)$/;"	f
strchr	ulib.c	/^strchr(const char *s, char c)$/;"	f
strcmp	ulib.c	/^strcmp(const char *p, const char *q)$/;"	f
strcpy	ulib.c	/^strcpy(char *s, char *t)$/;"	f
strlen	string.c	/^strlen(const char *s)$/;"	f
strlen	ulib.c	/^strlen(char *s)$/;"	f
strncmp	string.c	/^strncmp(const char *p, const char *q, uint n)$/;"	f
strncpy	string.c	/^strncpy(char *s, const char *t, int n)$/;"	f
struct	kernel.asm	/^  struct proc *np;$/;"	l
struct	kernel.asm	/^  struct proc *p;$/;"	l
subdir	usertests.c	/^subdir(void)$/;"	f
sum	kernel.asm	/^  sum = 0;$/;"	d
sum	mp.c	/^sum(uchar *addr, int len)$/;"	f	file:
superblock	fs.h	/^struct superblock {$/;"	s
swtch	swtch.S	/^swtch:$/;"	l
symbols	sh.c	/^char symbols[] = "<|>&;()";$/;"	v
sys_chdir	sysfile.c	/^sys_chdir(void)$/;"	f
sys_close	sysfile.c	/^sys_close(void)$/;"	f
sys_dup	sysfile.c	/^sys_dup(void)$/;"	f
sys_exec	sysfile.c	/^sys_exec(void)$/;"	f
sys_exit	sysproc.c	/^sys_exit(void)$/;"	f
sys_fork	sysproc.c	/^sys_fork(void)$/;"	f
sys_fstat	sysfile.c	/^sys_fstat(void)$/;"	f
sys_getpid	sysproc.c	/^sys_getpid(void)$/;"	f
sys_kill	sysproc.c	/^sys_kill(void)$/;"	f
sys_link	sysfile.c	/^sys_link(void)$/;"	f
sys_mkdir	sysfile.c	/^sys_mkdir(void)$/;"	f
sys_mknod	sysfile.c	/^sys_mknod(void)$/;"	f
sys_open	sysfile.c	/^sys_open(void)$/;"	f
sys_pipe	sysfile.c	/^sys_pipe(void)$/;"	f
sys_read	sysfile.c	/^sys_read(void)$/;"	f
sys_sbrk	sysproc.c	/^sys_sbrk(void)$/;"	f
sys_sleep	sysproc.c	/^sys_sleep(void)$/;"	f
sys_unlink	sysfile.c	/^sys_unlink(void)$/;"	f
sys_wait	sysproc.c	/^sys_wait(void)$/;"	f
sys_write	sysfile.c	/^sys_write(void)$/;"	f
syscall	syscall.c	/^syscall(void)$/;"	f
syscalls	syscall.c	/^static int (*syscalls[])(void) = {$/;"	v	file:
sz	kernel.asm	/^  sz = (sz+PAGE-1) & ~(PAGE-1);$/;"	d
sz	kernel.asm	/^  sz = 0;$/;"	d
sz	proc.h	/^  uint sz;                  \/\/ Size of process memory (bytes)$/;"	m	struct:proc
t	mmu.h	/^  ushort t;          \/\/ Trap on task switch$/;"	m	struct:taskstate
target	kernel.asm	/^  target = n;$/;"	d
taskstate	mmu.h	/^struct taskstate {$/;"	s
test_buddy	buddy.c	/^test_buddy()$/;"	f
tf	proc.h	/^  struct trapframe *tf;     \/\/ Trap frame for current interrupt$/;"	m	struct:proc	typeref:struct:proc::trapframe
ticks	trap.c	/^int ticks;$/;"	v
ticks0	kernel.asm	/^  ticks0 = ticks;$/;"	d
tickslock	trap.c	/^struct spinlock tickslock;$/;"	v	typeref:struct:spinlock
timer_init	timer.c	/^timer_init(void)$/;"	f
togglecode	kbd.h	/^static uchar togglecode[256] =$/;"	v
tok	sh.asm	/^    tok = gettoken(ps, es, 0, 0);$/;"	d
total	usertests.asm	/^    total = 0;$/;"	d
total	usertests.asm	/^  total = 0;$/;"	d
trap	trap.c	/^trap(struct trapframe *tf)$/;"	f
trapframe	x86.h	/^struct trapframe {$/;"	s
trapno	x86.h	/^  uint trapno;$/;"	m	struct:trapframe
trapret	trapasm.S	/^trapret:$/;"	l
ts	proc.h	/^  struct taskstate ts;        \/\/ Used by x86 to find stack for interrupt$/;"	m	struct:cpu	typeref:struct:cpu::taskstate
tvinit	trap.c	/^tvinit(void)$/;"	f
twofiles	usertests.c	/^twofiles(void)$/;"	f
type	elf.h	/^  uint type;$/;"	m	struct:proghdr
type	elf.h	/^  ushort type;$/;"	m	struct:elfhdr
type	file.h	/^  enum { FD_CLOSED, FD_NONE, FD_PIPE, FD_INODE } type;$/;"	m	struct:file	typeref:enum:file::__anon4
type	fs.h	/^  short type;           \/\/ File type$/;"	m	struct:dinode
type	fsvar.h	/^  short type;         \/\/ copy of disk inode$/;"	m	struct:inode
type	mmu.h	/^  uint type : 4;        \/\/ type(STS_{TG,IG32,TG32})$/;"	m	struct:gatedesc
type	mmu.h	/^  uint type : 4;       \/\/ Segment type (see STS_ constants)$/;"	m	struct:segdesc
type	mp.h	/^  uchar type;                   \/\/ MP system config type$/;"	m	struct:mp
type	mp.h	/^  uchar type;                   \/\/ entry type (0)$/;"	m	struct:mpproc
type	mp.h	/^  uchar type;                   \/\/ entry type (2)$/;"	m	struct:mpioapic
type	pmap.h	/^		long type;$/;"	m	struct:e820map::__anon2
type	sh.c	/^  int type;$/;"	m	struct:backcmd	file:
type	sh.c	/^  int type;$/;"	m	struct:cmd	file:
type	sh.c	/^  int type;$/;"	m	struct:execcmd	file:
type	sh.c	/^  int type;$/;"	m	struct:listcmd	file:
type	sh.c	/^  int type;$/;"	m	struct:pipecmd	file:
type	sh.c	/^  int type;$/;"	m	struct:redircmd	file:
type	stat.h	/^  short type;  \/\/ Type of file$/;"	m	struct:stat
uchar	kernel.asm	/^uchar ioapic_id;$/;"	l
uchar	types.h	/^typedef unsigned char  uchar;$/;"	t
uint	cat.asm	/^uint$/;"	l
uint	echo.asm	/^uint$/;"	l
uint	forktest.asm	/^uint$/;"	l
uint	grep.asm	/^uint$/;"	l
uint	init.asm	/^uint$/;"	l
uint	kill.asm	/^uint$/;"	l
uint	ln.asm	/^uint$/;"	l
uint	ls.asm	/^uint$/;"	l
uint	mkdir.asm	/^uint$/;"	l
uint	rm.asm	/^uint$/;"	l
uint	sh.asm	/^uint$/;"	l
uint	types.h	/^typedef unsigned int   uint;$/;"	t
uint	usertests.asm	/^uint$/;"	l
uint	wc.asm	/^uint$/;"	l
uint	zombie.asm	/^uint$/;"	l
uint32_t	types.h	/^typedef unsigned int   uint32_t;$/;"	t
unlinkread	usertests.c	/^unlinkread(void)$/;"	f
use_console_lock	console.c	/^int use_console_lock = 0;$/;"	v
use_console_lock	kernel.asm	/^  use_console_lock = 0;$/;"	d
use_console_lock	kernel.asm	/^  use_console_lock = 1;$/;"	d
usedblocks	mkfs.c	/^uint usedblocks;$/;"	v
userinit	proc.c	/^userinit(void)$/;"	f
ushort	types.h	/^typedef unsigned short ushort;$/;"	t
va	elf.h	/^  uint va;$/;"	m	struct:proghdr
vaddr_t	types.h	/^typedef uint vaddr_t;$/;"	t
vector0	vectors.S	/^vector0:$/;"	l
vector1	vectors.S	/^vector1:$/;"	l
vector10	vectors.S	/^vector10:$/;"	l
vector100	vectors.S	/^vector100:$/;"	l
vector101	vectors.S	/^vector101:$/;"	l
vector102	vectors.S	/^vector102:$/;"	l
vector103	vectors.S	/^vector103:$/;"	l
vector104	vectors.S	/^vector104:$/;"	l
vector105	vectors.S	/^vector105:$/;"	l
vector106	vectors.S	/^vector106:$/;"	l
vector107	vectors.S	/^vector107:$/;"	l
vector108	vectors.S	/^vector108:$/;"	l
vector109	vectors.S	/^vector109:$/;"	l
vector11	vectors.S	/^vector11:$/;"	l
vector110	vectors.S	/^vector110:$/;"	l
vector111	vectors.S	/^vector111:$/;"	l
vector112	vectors.S	/^vector112:$/;"	l
vector113	vectors.S	/^vector113:$/;"	l
vector114	vectors.S	/^vector114:$/;"	l
vector115	vectors.S	/^vector115:$/;"	l
vector116	vectors.S	/^vector116:$/;"	l
vector117	vectors.S	/^vector117:$/;"	l
vector118	vectors.S	/^vector118:$/;"	l
vector119	vectors.S	/^vector119:$/;"	l
vector12	vectors.S	/^vector12:$/;"	l
vector120	vectors.S	/^vector120:$/;"	l
vector121	vectors.S	/^vector121:$/;"	l
vector122	vectors.S	/^vector122:$/;"	l
vector123	vectors.S	/^vector123:$/;"	l
vector124	vectors.S	/^vector124:$/;"	l
vector125	vectors.S	/^vector125:$/;"	l
vector126	vectors.S	/^vector126:$/;"	l
vector127	vectors.S	/^vector127:$/;"	l
vector128	vectors.S	/^vector128:$/;"	l
vector129	vectors.S	/^vector129:$/;"	l
vector13	vectors.S	/^vector13:$/;"	l
vector130	vectors.S	/^vector130:$/;"	l
vector131	vectors.S	/^vector131:$/;"	l
vector132	vectors.S	/^vector132:$/;"	l
vector133	vectors.S	/^vector133:$/;"	l
vector134	vectors.S	/^vector134:$/;"	l
vector135	vectors.S	/^vector135:$/;"	l
vector136	vectors.S	/^vector136:$/;"	l
vector137	vectors.S	/^vector137:$/;"	l
vector138	vectors.S	/^vector138:$/;"	l
vector139	vectors.S	/^vector139:$/;"	l
vector14	vectors.S	/^vector14:$/;"	l
vector140	vectors.S	/^vector140:$/;"	l
vector141	vectors.S	/^vector141:$/;"	l
vector142	vectors.S	/^vector142:$/;"	l
vector143	vectors.S	/^vector143:$/;"	l
vector144	vectors.S	/^vector144:$/;"	l
vector145	vectors.S	/^vector145:$/;"	l
vector146	vectors.S	/^vector146:$/;"	l
vector147	vectors.S	/^vector147:$/;"	l
vector148	vectors.S	/^vector148:$/;"	l
vector149	vectors.S	/^vector149:$/;"	l
vector15	vectors.S	/^vector15:$/;"	l
vector150	vectors.S	/^vector150:$/;"	l
vector151	vectors.S	/^vector151:$/;"	l
vector152	vectors.S	/^vector152:$/;"	l
vector153	vectors.S	/^vector153:$/;"	l
vector154	vectors.S	/^vector154:$/;"	l
vector155	vectors.S	/^vector155:$/;"	l
vector156	vectors.S	/^vector156:$/;"	l
vector157	vectors.S	/^vector157:$/;"	l
vector158	vectors.S	/^vector158:$/;"	l
vector159	vectors.S	/^vector159:$/;"	l
vector16	vectors.S	/^vector16:$/;"	l
vector160	vectors.S	/^vector160:$/;"	l
vector161	vectors.S	/^vector161:$/;"	l
vector162	vectors.S	/^vector162:$/;"	l
vector163	vectors.S	/^vector163:$/;"	l
vector164	vectors.S	/^vector164:$/;"	l
vector165	vectors.S	/^vector165:$/;"	l
vector166	vectors.S	/^vector166:$/;"	l
vector167	vectors.S	/^vector167:$/;"	l
vector168	vectors.S	/^vector168:$/;"	l
vector169	vectors.S	/^vector169:$/;"	l
vector17	vectors.S	/^vector17:$/;"	l
vector170	vectors.S	/^vector170:$/;"	l
vector171	vectors.S	/^vector171:$/;"	l
vector172	vectors.S	/^vector172:$/;"	l
vector173	vectors.S	/^vector173:$/;"	l
vector174	vectors.S	/^vector174:$/;"	l
vector175	vectors.S	/^vector175:$/;"	l
vector176	vectors.S	/^vector176:$/;"	l
vector177	vectors.S	/^vector177:$/;"	l
vector178	vectors.S	/^vector178:$/;"	l
vector179	vectors.S	/^vector179:$/;"	l
vector18	vectors.S	/^vector18:$/;"	l
vector180	vectors.S	/^vector180:$/;"	l
vector181	vectors.S	/^vector181:$/;"	l
vector182	vectors.S	/^vector182:$/;"	l
vector183	vectors.S	/^vector183:$/;"	l
vector184	vectors.S	/^vector184:$/;"	l
vector185	vectors.S	/^vector185:$/;"	l
vector186	vectors.S	/^vector186:$/;"	l
vector187	vectors.S	/^vector187:$/;"	l
vector188	vectors.S	/^vector188:$/;"	l
vector189	vectors.S	/^vector189:$/;"	l
vector19	vectors.S	/^vector19:$/;"	l
vector190	vectors.S	/^vector190:$/;"	l
vector191	vectors.S	/^vector191:$/;"	l
vector192	vectors.S	/^vector192:$/;"	l
vector193	vectors.S	/^vector193:$/;"	l
vector194	vectors.S	/^vector194:$/;"	l
vector195	vectors.S	/^vector195:$/;"	l
vector196	vectors.S	/^vector196:$/;"	l
vector197	vectors.S	/^vector197:$/;"	l
vector198	vectors.S	/^vector198:$/;"	l
vector199	vectors.S	/^vector199:$/;"	l
vector2	vectors.S	/^vector2:$/;"	l
vector20	vectors.S	/^vector20:$/;"	l
vector200	vectors.S	/^vector200:$/;"	l
vector201	vectors.S	/^vector201:$/;"	l
vector202	vectors.S	/^vector202:$/;"	l
vector203	vectors.S	/^vector203:$/;"	l
vector204	vectors.S	/^vector204:$/;"	l
vector205	vectors.S	/^vector205:$/;"	l
vector206	vectors.S	/^vector206:$/;"	l
vector207	vectors.S	/^vector207:$/;"	l
vector208	vectors.S	/^vector208:$/;"	l
vector209	vectors.S	/^vector209:$/;"	l
vector21	vectors.S	/^vector21:$/;"	l
vector210	vectors.S	/^vector210:$/;"	l
vector211	vectors.S	/^vector211:$/;"	l
vector212	vectors.S	/^vector212:$/;"	l
vector213	vectors.S	/^vector213:$/;"	l
vector214	vectors.S	/^vector214:$/;"	l
vector215	vectors.S	/^vector215:$/;"	l
vector216	vectors.S	/^vector216:$/;"	l
vector217	vectors.S	/^vector217:$/;"	l
vector218	vectors.S	/^vector218:$/;"	l
vector219	vectors.S	/^vector219:$/;"	l
vector22	vectors.S	/^vector22:$/;"	l
vector220	vectors.S	/^vector220:$/;"	l
vector221	vectors.S	/^vector221:$/;"	l
vector222	vectors.S	/^vector222:$/;"	l
vector223	vectors.S	/^vector223:$/;"	l
vector224	vectors.S	/^vector224:$/;"	l
vector225	vectors.S	/^vector225:$/;"	l
vector226	vectors.S	/^vector226:$/;"	l
vector227	vectors.S	/^vector227:$/;"	l
vector228	vectors.S	/^vector228:$/;"	l
vector229	vectors.S	/^vector229:$/;"	l
vector23	vectors.S	/^vector23:$/;"	l
vector230	vectors.S	/^vector230:$/;"	l
vector231	vectors.S	/^vector231:$/;"	l
vector232	vectors.S	/^vector232:$/;"	l
vector233	vectors.S	/^vector233:$/;"	l
vector234	vectors.S	/^vector234:$/;"	l
vector235	vectors.S	/^vector235:$/;"	l
vector236	vectors.S	/^vector236:$/;"	l
vector237	vectors.S	/^vector237:$/;"	l
vector238	vectors.S	/^vector238:$/;"	l
vector239	vectors.S	/^vector239:$/;"	l
vector24	vectors.S	/^vector24:$/;"	l
vector240	vectors.S	/^vector240:$/;"	l
vector241	vectors.S	/^vector241:$/;"	l
vector242	vectors.S	/^vector242:$/;"	l
vector243	vectors.S	/^vector243:$/;"	l
vector244	vectors.S	/^vector244:$/;"	l
vector245	vectors.S	/^vector245:$/;"	l
vector246	vectors.S	/^vector246:$/;"	l
vector247	vectors.S	/^vector247:$/;"	l
vector248	vectors.S	/^vector248:$/;"	l
vector249	vectors.S	/^vector249:$/;"	l
vector25	vectors.S	/^vector25:$/;"	l
vector250	vectors.S	/^vector250:$/;"	l
vector251	vectors.S	/^vector251:$/;"	l
vector252	vectors.S	/^vector252:$/;"	l
vector253	vectors.S	/^vector253:$/;"	l
vector254	vectors.S	/^vector254:$/;"	l
vector255	vectors.S	/^vector255:$/;"	l
vector26	vectors.S	/^vector26:$/;"	l
vector27	vectors.S	/^vector27:$/;"	l
vector28	vectors.S	/^vector28:$/;"	l
vector29	vectors.S	/^vector29:$/;"	l
vector3	vectors.S	/^vector3:$/;"	l
vector30	vectors.S	/^vector30:$/;"	l
vector31	vectors.S	/^vector31:$/;"	l
vector32	vectors.S	/^vector32:$/;"	l
vector33	vectors.S	/^vector33:$/;"	l
vector34	vectors.S	/^vector34:$/;"	l
vector35	vectors.S	/^vector35:$/;"	l
vector36	vectors.S	/^vector36:$/;"	l
vector37	vectors.S	/^vector37:$/;"	l
vector38	vectors.S	/^vector38:$/;"	l
vector39	vectors.S	/^vector39:$/;"	l
vector4	vectors.S	/^vector4:$/;"	l
vector40	vectors.S	/^vector40:$/;"	l
vector41	vectors.S	/^vector41:$/;"	l
vector42	vectors.S	/^vector42:$/;"	l
vector43	vectors.S	/^vector43:$/;"	l
vector44	vectors.S	/^vector44:$/;"	l
vector45	vectors.S	/^vector45:$/;"	l
vector46	vectors.S	/^vector46:$/;"	l
vector47	vectors.S	/^vector47:$/;"	l
vector48	vectors.S	/^vector48:$/;"	l
vector49	vectors.S	/^vector49:$/;"	l
vector5	vectors.S	/^vector5:$/;"	l
vector50	vectors.S	/^vector50:$/;"	l
vector51	vectors.S	/^vector51:$/;"	l
vector52	vectors.S	/^vector52:$/;"	l
vector53	vectors.S	/^vector53:$/;"	l
vector54	vectors.S	/^vector54:$/;"	l
vector55	vectors.S	/^vector55:$/;"	l
vector56	vectors.S	/^vector56:$/;"	l
vector57	vectors.S	/^vector57:$/;"	l
vector58	vectors.S	/^vector58:$/;"	l
vector59	vectors.S	/^vector59:$/;"	l
vector6	vectors.S	/^vector6:$/;"	l
vector60	vectors.S	/^vector60:$/;"	l
vector61	vectors.S	/^vector61:$/;"	l
vector62	vectors.S	/^vector62:$/;"	l
vector63	vectors.S	/^vector63:$/;"	l
vector64	vectors.S	/^vector64:$/;"	l
vector65	vectors.S	/^vector65:$/;"	l
vector66	vectors.S	/^vector66:$/;"	l
vector67	vectors.S	/^vector67:$/;"	l
vector68	vectors.S	/^vector68:$/;"	l
vector69	vectors.S	/^vector69:$/;"	l
vector7	vectors.S	/^vector7:$/;"	l
vector70	vectors.S	/^vector70:$/;"	l
vector71	vectors.S	/^vector71:$/;"	l
vector72	vectors.S	/^vector72:$/;"	l
vector73	vectors.S	/^vector73:$/;"	l
vector74	vectors.S	/^vector74:$/;"	l
vector75	vectors.S	/^vector75:$/;"	l
vector76	vectors.S	/^vector76:$/;"	l
vector77	vectors.S	/^vector77:$/;"	l
vector78	vectors.S	/^vector78:$/;"	l
vector79	vectors.S	/^vector79:$/;"	l
vector8	vectors.S	/^vector8:$/;"	l
vector80	vectors.S	/^vector80:$/;"	l
vector81	vectors.S	/^vector81:$/;"	l
vector82	vectors.S	/^vector82:$/;"	l
vector83	vectors.S	/^vector83:$/;"	l
vector84	vectors.S	/^vector84:$/;"	l
vector85	vectors.S	/^vector85:$/;"	l
vector86	vectors.S	/^vector86:$/;"	l
vector87	vectors.S	/^vector87:$/;"	l
vector88	vectors.S	/^vector88:$/;"	l
vector89	vectors.S	/^vector89:$/;"	l
vector9	vectors.S	/^vector9:$/;"	l
vector90	vectors.S	/^vector90:$/;"	l
vector91	vectors.S	/^vector91:$/;"	l
vector92	vectors.S	/^vector92:$/;"	l
vector93	vectors.S	/^vector93:$/;"	l
vector94	vectors.S	/^vector94:$/;"	l
vector95	vectors.S	/^vector95:$/;"	l
vector96	vectors.S	/^vector96:$/;"	l
vector97	vectors.S	/^vector97:$/;"	l
vector98	vectors.S	/^vector98:$/;"	l
vector99	vectors.S	/^vector99:$/;"	l
vectors	vectors.S	/^vectors:$/;"	l
version	elf.h	/^  uint version;$/;"	m	struct:elfhdr
version	mp.h	/^  uchar version;                \/\/ I\/O APIC version$/;"	m	struct:mpioapic
version	mp.h	/^  uchar version;                \/\/ [14]$/;"	m	struct:mpconf
version	mp.h	/^  uchar version;                \/\/ local APIC verison$/;"	m	struct:mpproc
vm	proc.h	/^  struct proc_vm vm;        \/\/ Information about the process address space$/;"	m	struct:proc	typeref:struct:proc::proc_vm
void	bootblock.asm	/^void readseg(uint, uint, uint);$/;"	l
void	bootblock.asm	/^void$/;"	l
void	cat.asm	/^void$/;"	l
void	echo.asm	/^void$/;"	l
void	forktest.asm	/^void$/;"	l
void	grep.asm	/^void$/;"	l
void	init.asm	/^void$/;"	l
void	kernel.asm	/^void$/;"	l
void	kill.asm	/^void$/;"	l
void	ln.asm	/^void$/;"	l
void	ls.asm	/^void$/;"	l
void	mkdir.asm	/^void$/;"	l
void	rm.asm	/^void$/;"	l
void	sh.asm	/^void$/;"	l
void	usertests.asm	/^void dirtest(void)$/;"	l
void	usertests.asm	/^void$/;"	l
void	wc.asm	/^void$/;"	l
void	zombie.asm	/^void$/;"	l
volatile	kernel.asm	/^volatile uint *lapic;  \/\/ Initialized in mp.c$/;"	l
w	console.c	/^  uint w;  \/\/ Write index$/;"	m	struct:__anon1	file:
wait	proc.c	/^wait(void)$/;"	f
waitdisk	bootmain.c	/^waitdisk(void)$/;"	f
wakeup	proc.c	/^wakeup(void *chan)$/;"	f
wakeup1	proc.c	/^wakeup1(void *chan)$/;"	f	file:
wc	wc.c	/^wc(int fd, char *name)$/;"	f
whitespace	sh.c	/^char whitespace[] = " \\t\\r\\n\\v";$/;"	v
winode	mkfs.c	/^winode(uint inum, struct dinode *ip)$/;"	f
writable	file.h	/^  char writable;$/;"	m	struct:file
write	dev.h	/^  int (*write)(struct inode*, char*, int);$/;"	m	struct:devsw
write_eflags	x86.h	/^write_eflags(uint eflags)$/;"	f
writei	fs.c	/^writei(struct inode *ip, char *src, uint off, uint n)$/;"	f
writeopen	pipe.c	/^  int writeopen;  \/\/ write fd is still open$/;"	m	struct:pipe	file:
writep	pipe.c	/^  uint writep;    \/\/ next index to write$/;"	m	struct:pipe	file:
writetest	usertests.c	/^writetest(void)$/;"	f
writetest1	usertests.c	/^writetest1(void)$/;"	f
wrv	kernel.asm	/^  wrv = (ushort*)(0x40<<4 | 0x67);  \/\/ Warm reset vector$/;"	d
wsect	mkfs.c	/^wsect(uint sec, void *buf)$/;"	f
x	cat.asm	/^    x = -xx;$/;"	d
x	cat.asm	/^    x = xx;$/;"	d
x	echo.asm	/^    x = -xx;$/;"	d
x	echo.asm	/^    x = xx;$/;"	d
x	grep.asm	/^    x = -xx;$/;"	d
x	grep.asm	/^    x = xx;$/;"	d
x	init.asm	/^    x = -xx;$/;"	d
x	init.asm	/^    x = xx;$/;"	d
x	kernel.asm	/^    x = 0 - xx;$/;"	d
x	kernel.asm	/^    x = xx;$/;"	d
x	kill.asm	/^    x = -xx;$/;"	d
x	kill.asm	/^    x = xx;$/;"	d
x	ln.asm	/^    x = -xx;$/;"	d
x	ln.asm	/^    x = xx;$/;"	d
x	ls.asm	/^    x = -xx;$/;"	d
x	ls.asm	/^    x = xx;$/;"	d
x	mkdir.asm	/^    x = -xx;$/;"	d
x	mkdir.asm	/^    x = xx;$/;"	d
x	rm.asm	/^    x = -xx;$/;"	d
x	rm.asm	/^    x = xx;$/;"	d
x	sh.asm	/^    x = -xx;$/;"	d
x	sh.asm	/^    x = xx;$/;"	d
x	umalloc.c	/^  Align x;$/;"	m	union:header	file:
x	usertests.asm	/^    x = -xx;$/;"	d
x	usertests.asm	/^    x = xx;$/;"	d
x	wc.asm	/^    x = -xx;$/;"	d
x	wc.asm	/^    x = xx;$/;"	d
x	zombie.asm	/^    x = -xx;$/;"	d
x	zombie.asm	/^    x = xx;$/;"	d
xchecksum	mp.h	/^  uchar xchecksum;              \/\/ extended table checksum$/;"	m	struct:mpconf
xchg	x86.h	/^xchg(volatile uint *addr, uint newval)$/;"	f
xint	mkfs.c	/^xint(uint x)$/;"	f
xlength	mp.h	/^  ushort xlength;               \/\/ extended table length$/;"	m	struct:mpconf
xshort	mkfs.c	/^xshort(ushort x)$/;"	f
yield	proc.c	/^yield(void)$/;"	f
zeroes	mkfs.c	/^char zeroes[512];$/;"	v
