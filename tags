!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.7	//
ALT	kbd.h	11;"	d
AS	Makefile	?^AS = $(TOOLPREFIX)gas$?;"	m
ASFLAGS	Makefile	?^ASFLAGS = -m32$?;"	m
ASSERT	lapic.c	22;"	d	file:
Align	umalloc.c	?^typedef long Align;$?;"	t	file:
BACK	sh.c	12;"	d	file:
BACKSPACE	console.c	17;"	d	file:
BBLOCK	fs.h	47;"	d
BCAST	lapic.c	24;"	d	file:
BPB	fs.h	44;"	d
BSIZE	fs.h	8;"	d
B_BUSY	buf.h	10;"	d
B_DIRTY	buf.h	12;"	d
B_VALID	buf.h	11;"	d
C	console.c	194;"	d	file:
C	kbd.h	32;"	d
CAPSLOCK	kbd.h	13;"	d
CC	Makefile	?^CC = $(TOOLPREFIX)gcc-3.4$?;"	m
CFLAGS	Makefile	?^CFLAGS = -fno-builtin -O2 -Wall -MD -ggdb -m32$?;"	m
CLEAR_PAGE_RESERVED	pmap.h	64;"	d
CONSOLE	dev.h	8;"	d
CR0_AM	mmu.h	25;"	d
CR0_CD	mmu.h	27;"	d
CR0_EM	mmu.h	20;"	d
CR0_ET	mmu.h	22;"	d
CR0_MP	mmu.h	19;"	d
CR0_NE	mmu.h	23;"	d
CR0_NW	mmu.h	26;"	d
CR0_PE	mmu.h	18;"	d
CR0_PG	mmu.h	28;"	d
CR0_TS	mmu.h	21;"	d
CR0_WP	mmu.h	24;"	d
CR4_DE	mmu.h	33;"	d
CR4_MCE	mmu.h	31;"	d
CR4_PCE	mmu.h	30;"	d
CR4_PSE	mmu.h	32;"	d
CR4_PVI	mmu.h	35;"	d
CR4_TSD	mmu.h	34;"	d
CR4_VME	mmu.h	36;"	d
CRTPORT	console.c	15;"	d	file:
CTL	kbd.h	10;"	d
ClearPageProperty	pmap.h	67;"	d
DELIVS	lapic.c	21;"	d	file:
DIRSIZ	fs.h	50;"	d
DPL_USER	mmu.h	126;"	d
DecPageCount	pmap.h	70;"	d
E0ESC	kbd.h	17;"	d
E820MAX	pmap.h	10;"	d
E820_ARM	pmap.h	11;"	d
E820_ARR	pmap.h	12;"	d
ELF_MAGIC	elf.h	3;"	d
ELF_PROG_FLAG_EXEC	elf.h	40;"	d
ELF_PROG_FLAG_READ	elf.h	42;"	d
ELF_PROG_FLAG_WRITE	elf.h	41;"	d
ELF_PROG_LOAD	elf.h	37;"	d
EMBRYO	proc.h	?^enum proc_state { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$?;"	e	enum:proc_state
ENABLE	lapic.c	16;"	d	file:
EOI	lapic.c	14;"	d	file:
ERROR	lapic.c	32;"	d	file:
ESR	lapic.c	17;"	d	file:
EXEC	sh.c	8;"	d	file:
E_ALREADY_FREE	errorno.h	8;"	d
E_MAP_EXIST	errorno.h	6;"	d
E_NOT_AT_PGBOUND	errorno.h	5;"	d
E_NO_MEM	errorno.h	7;"	d
FD_CLOSED	file.h	?^  enum { FD_CLOSED, FD_NONE, FD_PIPE, FD_INODE } type;$?;"	e	enum:file::__anon4
FD_INODE	file.h	?^  enum { FD_CLOSED, FD_NONE, FD_PIPE, FD_INODE } type;$?;"	e	enum:file::__anon4
FD_NONE	file.h	?^  enum { FD_CLOSED, FD_NONE, FD_PIPE, FD_INODE } type;$?;"	e	enum:file::__anon4
FD_PIPE	file.h	?^  enum { FD_CLOSED, FD_NONE, FD_PIPE, FD_INODE } type;$?;"	e	enum:file::__anon4
FILES	Makefile	?^FILES = $(shell grep -v '^\\#' runoff.list)$?;"	m
FL_AC	mmu.h	90;"	d
FL_AF	mmu.h	75;"	d
FL_CF	mmu.h	73;"	d
FL_DF	mmu.h	80;"	d
FL_ID	mmu.h	93;"	d
FL_IF	mmu.h	79;"	d
FL_IOPL_0	mmu.h	83;"	d
FL_IOPL_1	mmu.h	84;"	d
FL_IOPL_2	mmu.h	85;"	d
FL_IOPL_3	mmu.h	86;"	d
FL_IOPL_MASK	mmu.h	82;"	d
FL_NT	mmu.h	87;"	d
FL_OF	mmu.h	81;"	d
FL_PF	mmu.h	74;"	d
FL_RF	mmu.h	88;"	d
FL_SF	mmu.h	77;"	d
FL_TF	mmu.h	78;"	d
FL_VIF	mmu.h	91;"	d
FL_VIP	mmu.h	92;"	d
FL_VM	mmu.h	89;"	d
FL_ZF	mmu.h	76;"	d
FreeAreaSize	buddy.c	?^const int FreeAreaSize[MAX_ORDER] = {1,2,4,8,16,32,64,128,256,512,1024};$?;"	v
Header	umalloc.c	?^typedef union header Header;$?;"	t	typeref:union:header	file:
IBLOCK	fs.h	41;"	d
ICRHI	lapic.c	25;"	d	file:
ICRLO	lapic.c	18;"	d	file:
ID	lapic.c	11;"	d	file:
IDE_BSY	ide.c	13;"	d	file:
IDE_CMD_READ	ide.c	18;"	d	file:
IDE_CMD_WRITE	ide.c	19;"	d	file:
IDE_DF	ide.c	15;"	d	file:
IDE_DRDY	ide.c	14;"	d	file:
IDE_ERR	ide.c	16;"	d	file:
INDIRECT	fs.h	19;"	d
INIT	lapic.c	19;"	d	file:
INPUT_BUF	console.c	185;"	d	file:
INT_ACTIVELOW	ioapic.c	22;"	d	file:
INT_DISABLED	ioapic.c	20;"	d	file:
INT_LEVEL	ioapic.c	21;"	d	file:
INT_LOGICAL	ioapic.c	23;"	d	file:
IOAPIC	ioapic.c	9;"	d	file:
IO_PIC1	picirq.c	8;"	d	file:
IO_PIC2	picirq.c	9;"	d	file:
IO_RTC	lapic.c	133;"	d	file:
IO_TIMER1	timer.c	10;"	d	file:
IPB	fs.h	38;"	d
IRQ_ERROR	traps.h	35;"	d
IRQ_IDE	traps.h	34;"	d
IRQ_KBD	traps.h	33;"	d
IRQ_OFFSET	traps.h	30;"	d
IRQ_SLAVE	picirq.c	11;"	d	file:
IRQ_SPURIOUS	traps.h	36;"	d
IRQ_TIMER	traps.h	32;"	d
I_BUSY	fsvar.h	17;"	d
I_VALID	fsvar.h	18;"	d
IncPageCount	pmap.h	69;"	d
IsPageMapped	pmap.h	71;"	d
JOS_INC_QUEUE_H	queue.h	36;"	d
KBDATAP	kbd.h	5;"	d
KBSTATP	kbd.h	3;"	d
KBS_DIB	kbd.h	4;"	d
KERNTOP	memlayout.h	3;"	d
KEY_DEL	kbd.h	29;"	d
KEY_DN	kbd.h	23;"	d
KEY_END	kbd.h	21;"	d
KEY_HOME	kbd.h	20;"	d
KEY_INS	kbd.h	28;"	d
KEY_LF	kbd.h	24;"	d
KEY_PGDN	kbd.h	27;"	d
KEY_PGUP	kbd.h	26;"	d
KEY_RT	kbd.h	25;"	d
KEY_UP	kbd.h	22;"	d
KSTACKSIZE	param.h	5;"	d
KSTACKTOP	memlayout.h	10;"	d
LD	Makefile	?^LD = $(TOOLPREFIX)ld$?;"	m
LEVEL	lapic.c	23;"	d	file:
LINT0	lapic.c	30;"	d	file:
LINT1	lapic.c	31;"	d	file:
LIST	sh.c	11;"	d	file:
LIST_EMPTY	queue.h	142;"	d
LIST_ENTRY	queue.h	129;"	d
LIST_FIRST	queue.h	147;"	d
LIST_FOREACH	queue.h	160;"	d
LIST_HEAD	queue.h	109;"	d
LIST_HEAD_INITIALIZER	queue.h	118;"	d
LIST_INIT	queue.h	168;"	d
LIST_INSERT_AFTER	queue.h	177;"	d
LIST_INSERT_BEFORE	queue.h	190;"	d
LIST_INSERT_HEAD	queue.h	201;"	d
LIST_NEXT	queue.h	153;"	d
LIST_REMOVE	queue.h	212;"	d
LPTPORT	console.c	16;"	d	file:
MASKED	lapic.c	33;"	d	file:
MAXARGS	sh.c	14;"	d	file:
MAXFILE	fs.h	21;"	d
MAX_ORDER	buddy.h	5;"	d
MPBOOT	mp.h	34;"	d
MPBUS	mp.h	50;"	d
MPIOAPIC	mp.h	51;"	d
MPIOINTR	mp.h	52;"	d
MPLINTR	mp.h	53;"	d
MPPROC	mp.h	49;"	d
NADDRS	fs.h	17;"	d
NBUF	param.h	9;"	d
NCPU	param.h	6;"	d
NDEV	param.h	11;"	d
NDIRECT	fs.h	18;"	d
NELEM	defs.h	150;"	d
NFILE	param.h	8;"	d
NINDIRECT	fs.h	20;"	d
NINODE	param.h	10;"	d
NO	kbd.h	7;"	d
NOFILE	param.h	7;"	d
NPROC	param.h	3;"	d
NSEGS	proc.h	10;"	d
NULL	pmap.h	7;"	d
NUMLOCK	kbd.h	14;"	d
OBJCOPY	Makefile	?^OBJCOPY = $(TOOLPREFIX)objcopy$?;"	m
OBJDUMP	Makefile	?^OBJDUMP = $(TOOLPREFIX)objdump$?;"	m
OBJS	Makefile	?^OBJS = \\$?;"	m
O_CREATE	fcntl.h	4;"	d
O_RDONLY	fcntl.h	1;"	d
O_RDWR	fcntl.h	3;"	d
O_WRONLY	fcntl.h	2;"	d
PAGE	param.h	4;"	d
PCINT	lapic.c	29;"	d	file:
PDX	mmu.h	52;"	d
PDXSHIFT	mmu.h	67;"	d
PERIODIC	lapic.c	28;"	d	file:
PGOFF	mmu.h	61;"	d
PG_dirty	pmap.h	18;"	d
PG_locked	pmap.h	17;"	d
PG_property	pmap.h	16;"	d
PG_reserved	pmap.h	15;"	d
PIPE	sh.c	10;"	d	file:
PIPESIZE	pipe.c	9;"	d	file:
PPN	mmu.h	55;"	d
PRINT	Makefile	?^PRINT = runoff.list $(FILES)$?;"	m
PTENTRY	mmu.h	69;"	d
PTE_A	mmu.h	12;"	d
PTE_ADDR	mmu.h	64;"	d
PTE_D	mmu.h	13;"	d
PTE_MBZ	mmu.h	15;"	d
PTE_P	mmu.h	7;"	d
PTE_PCD	mmu.h	11;"	d
PTE_PS	mmu.h	14;"	d
PTE_PWT	mmu.h	10;"	d
PTE_U	mmu.h	9;"	d
PTE_W	mmu.h	8;"	d
PTSIZE	mmu.h	70;"	d
PTX	mmu.h	58;"	d
PTXSHIFT	mmu.h	68;"	d
Page	pmap.h	?^struct Page {$?;"	s
PageProperty	pmap.h	68;"	d
PageReserved	pmap.h	65;"	d
REDIR	sh.c	9;"	d	file:
REG_ID	ioapic.c	11;"	d	file:
REG_TABLE	ioapic.c	13;"	d	file:
REG_VER	ioapic.c	12;"	d	file:
ROOTDEV	param.h	12;"	d
ROUNDDOWN	types.h	14;"	d
ROUNDUP	types.h	21;"	d
RUNNABLE	proc.h	?^enum proc_state { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$?;"	e	enum:proc_state
RUNNING	proc.h	?^enum proc_state { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$?;"	e	enum:proc_state
SCROLLLOCK	kbd.h	15;"	d
SECTSIZE	bootmain.c	12;"	d	file:
SEG	mmu.h	116;"	d
SEG16	mmu.h	121;"	d
SEG_ASM	asm.h	9;"	d
SEG_KCODE	proc.h	5;"	d
SEG_KDATA	proc.h	6;"	d
SEG_NULL	mmu.h	113;"	d
SEG_NULLASM	asm.h	5;"	d
SEG_TSS	proc.h	9;"	d
SEG_UCODE	proc.h	7;"	d
SEG_UDATA	proc.h	8;"	d
SETGATE	mmu.h	212;"	d
SET_PAGE_RESERVED	pmap.h	63;"	d
SHIFT	kbd.h	9;"	d
SLEEPING	proc.h	?^enum proc_state { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$?;"	e	enum:proc_state
STARTUP	lapic.c	20;"	d	file:
STA_A	asm.h	19;"	d
STA_A	mmu.h	134;"	d
STA_C	asm.h	16;"	d
STA_C	mmu.h	131;"	d
STA_E	asm.h	15;"	d
STA_E	mmu.h	130;"	d
STA_R	asm.h	18;"	d
STA_R	mmu.h	133;"	d
STA_W	asm.h	17;"	d
STA_W	mmu.h	132;"	d
STA_X	asm.h	14;"	d
STA_X	mmu.h	129;"	d
STS_CG16	mmu.h	140;"	d
STS_CG32	mmu.h	146;"	d
STS_IG16	mmu.h	142;"	d
STS_IG32	mmu.h	147;"	d
STS_LDT	mmu.h	138;"	d
STS_T16A	mmu.h	137;"	d
STS_T16B	mmu.h	139;"	d
STS_T32A	mmu.h	144;"	d
STS_T32B	mmu.h	145;"	d
STS_TG	mmu.h	141;"	d
STS_TG16	mmu.h	143;"	d
STS_TG32	mmu.h	148;"	d
STUB	usys.S	?^#define STUB(name) \\$?;"	d
SVR	lapic.c	15;"	d	file:
SYS_chdir	syscall.h	17;"	d
SYS_close	syscall.h	8;"	d
SYS_dup	syscall.h	18;"	d
SYS_exec	syscall.h	10;"	d
SYS_exit	syscall.h	3;"	d
SYS_fork	syscall.h	2;"	d
SYS_fstat	syscall.h	14;"	d
SYS_getpid	syscall.h	19;"	d
SYS_kill	syscall.h	9;"	d
SYS_link	syscall.h	15;"	d
SYS_mkdir	syscall.h	16;"	d
SYS_mknod	syscall.h	12;"	d
SYS_open	syscall.h	11;"	d
SYS_pipe	syscall.h	5;"	d
SYS_read	syscall.h	7;"	d
SYS_sbrk	syscall.h	20;"	d
SYS_sleep	syscall.h	21;"	d
SYS_unlink	syscall.h	13;"	d
SYS_wait	syscall.h	4;"	d
SYS_write	syscall.h	6;"	d
SetPageProperty	pmap.h	66;"	d
TCCR	lapic.c	35;"	d	file:
TDCR	lapic.c	36;"	d	file:
TICR	lapic.c	34;"	d	file:
TIMER	lapic.c	26;"	d	file:
TIMER_16BIT	timer.c	22;"	d	file:
TIMER_DIV	timer.c	17;"	d	file:
TIMER_FREQ	timer.c	16;"	d	file:
TIMER_MODE	timer.c	19;"	d	file:
TIMER_RATEGEN	timer.c	21;"	d	file:
TIMER_SEL0	timer.c	20;"	d	file:
TOOLPREFIX	Makefile	?^TOOLPREFIX = $?;"	m
TPR	lapic.c	13;"	d	file:
T_ALIGN	traps.h	21;"	d
T_BOUND	traps.h	9;"	d
T_BRKPT	traps.h	7;"	d
T_DBLFLT	traps.h	12;"	d
T_DEBUG	traps.h	5;"	d
T_DEFAULT	traps.h	28;"	d
T_DEV	fs.h	35;"	d
T_DEVICE	traps.h	11;"	d
T_DIR	fs.h	33;"	d
T_DIVIDE	traps.h	4;"	d
T_FILE	fs.h	34;"	d
T_FPERR	traps.h	20;"	d
T_GPFLT	traps.h	17;"	d
T_ILLOP	traps.h	10;"	d
T_MCHK	traps.h	22;"	d
T_NMI	traps.h	6;"	d
T_OFLOW	traps.h	8;"	d
T_PGFLT	traps.h	18;"	d
T_SEGNP	traps.h	15;"	d
T_SIMDERR	traps.h	23;"	d
T_STACK	traps.h	16;"	d
T_SYSCALL	traps.h	27;"	d
T_TSS	traps.h	14;"	d
ULIB	Makefile	?^ULIB = ulib.o usys.o printf.o umalloc.o$?;"	m
UNUSED	proc.h	?^enum proc_state { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$?;"	e	enum:proc_state
UPROGS	Makefile	?^UPROGS=\\$?;"	m
UVPT	memlayout.h	9;"	d
VER	lapic.c	12;"	d	file:
VPT	memlayout.h	8;"	d
X1	lapic.c	27;"	d	file:
ZOMBIE	proc.h	?^enum proc_state { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$?;"	e	enum:proc_state
_ASSERT_H_	assert.h	2;"	d
_ATOMIC_H_	atomic.h	2;"	d
_BUDDY_H_	buddy.h	2;"	d
_DEFS_H_	defs.h	2;"	d
_ERRORNO_H_	errorno.h	2;"	d
_MEMLAYOUT_H_	memlayout.h	2;"	d
_MMU_H_	mmu.h	2;"	d
_PARAM_H_	param.h	2;"	d
_PMAP_H_	pmap.h	2;"	d
_SPINLOCK_H_	spinlock.h	2;"	d
_TYPES_H_	types.h	2;"	d
__alloc_pages	buddy.c	?^__alloc_pages(int nr)$?;"	f
__free_pages	buddy.c	?^__free_pages(struct Page * page, int nr)$?;"	f
_getmeminfo	meminfo.S	?^_getmeminfo:$?;"	l
_namei	fs.c	?^_namei(char *path, int parent, char *name)$?;"	f	file:
acquire	spinlock.c	?^acquire(struct spinlock *lock)$?;"	f
addr	mp.h	?^  uint *addr;                  // I/O APIC address$?;"	m	struct:mpioapic
addr	pmap.h	?^		long long addr;$?;"	m	struct:e820map::__anon2
addrs	fs.h	?^  uint addrs[NADDRS];   // Data block addresses$?;"	m	struct:dinode
addrs	fsvar.h	?^  uint addrs[NADDRS];$?;"	m	struct:inode
align	elf.h	?^  uint align;$?;"	m	struct:proghdr
alloc_page	pmap.c	?^alloc_page()$?;"	f
alloc_pages_bulk	buddy.c	?^alloc_pages_bulk(int order)$?;"	f
allocproc	proc.c	?^allocproc(void)$?;"	f	file:
alltraps	trapasm.S	?^alltraps:$?;"	l
apicid	mp.h	?^  uchar apicid;                 // local APIC id$?;"	m	struct:mpproc
apicid	proc.h	?^  uchar apicid;               // Local APIC ID$?;"	m	struct:cpu
apicno	mp.h	?^  uchar apicno;                 // I/O APIC id$?;"	m	struct:mpioapic
argfd	sysfile.c	?^argfd(int n, int *pfd, struct file **pf)$?;"	f	file:
argint	syscall.c	?^argint(int n, int *ip)$?;"	f
argptr	syscall.c	?^argptr(int n, char **pp, int size)$?;"	f
args	mmu.h	?^  uint args : 5;        // # args, 0 for interrupt/trap gates$?;"	m	struct:gatedesc
argstr	syscall.c	?^argstr(int n, char **pp)$?;"	f
argv	initcode.S	?^argv:$?;"	l
argv	sh.c	?^  char *argv[MAXARGS];$?;"	m	struct:execcmd	file:
assert	assert.h	4;"	d
atoi	ulib.c	?^atoi(const char *s)$?;"	f
atomic_t	atomic.h	?^} atomic_t;$?;"	t	typeref:struct:__anon3
avl	mmu.h	?^  uint avl : 1;        // Unused (available for software use)$?;"	m	struct:segdesc
backcmd	sh.c	?^backcmd(struct cmd *subcmd)$?;"	f
backcmd	sh.c	?^struct backcmd {$?;"	s	file:
balloc	fs.c	?^balloc(uint dev)$?;"	f	file:
balloc	mkfs.c	?^balloc(int used)$?;"	f
base	umalloc.c	?^static Header base;$?;"	v	file:
base_15_0	mmu.h	?^  uint base_15_0 : 16; // Low bits of segment base address$?;"	m	struct:segdesc
base_23_16	mmu.h	?^  uint base_23_16 : 8; // Middle bits of segment base address$?;"	m	struct:segdesc
base_31_24	mmu.h	?^  uint base_31_24 : 8; // High bits of segment base address$?;"	m	struct:segdesc
bcpu	mp.c	?^static struct cpu *bcpu;$?;"	v	typeref:struct:cpu	file:
bfree	fs.c	?^bfree(int dev, uint b)$?;"	f	file:
bget	bio.c	?^bget(uint dev, uint sector)$?;"	f	file:
bigdir	usertests.c	?^bigdir(void)$?;"	f
bigfile	usertests.c	?^bigfile(void)$?;"	f
binit	bio.c	?^binit(void)$?;"	f
bitblocks	mkfs.c	?^uint bitblocks;$?;"	v
bmap	fs.c	?^bmap(struct inode *ip, uint bn, int alloc)$?;"	f	file:
boot_cr3	pmap.c	?^paddr_t boot_cr3;    // physical address of boot time page directory$?;"	v
boot_map_segment	pmap.c	?^boot_map_segment(pde_t * pgdir, paddr_t pa, vaddr_t la, uint size, uint perm)$?;"	f	file:
boot_pgdir	pmap.c	?^pde_t * boot_pgdir;    // virtual address of boot time page directory$?;"	v
booted	proc.h	?^  volatile uint booted;        // Has the CPU started\?$?;"	m	struct:cpu
bootmain	bootmain.c	?^bootmain(void)$?;"	f
bootothers	main.c	?^bootothers(void)$?;"	f	file:
bread	bio.c	?^bread(uint dev, uint sector)$?;"	f
brelse	bio.c	?^brelse(struct buf *b)$?;"	f
buf	bio.c	?^struct buf buf[NBUF];$?;"	v	typeref:struct:buf
buf	buf.h	?^struct buf {$?;"	s
buf	cat.c	?^char buf[512];$?;"	v
buf	console.c	?^  char buf[INPUT_BUF];$?;"	m	struct:__anon1	file:
buf	grep.c	?^char buf[1024];$?;"	v
buf	usertests.c	?^char buf[2048];$?;"	v
buf	wc.c	?^char buf[512];$?;"	v
buf_table_lock	bio.c	?^struct spinlock buf_table_lock;$?;"	v	typeref:struct:spinlock
bufhead	bio.c	?^struct buf bufhead;$?;"	v	typeref:struct:buf
bwrite	bio.c	?^bwrite(struct buf *b)$?;"	f
bzero	fs.c	?^bzero(int dev, int bno)$?;"	f	file:
cat	cat.c	?^cat(int fd)$?;"	f
cat_args	usertests.c	?^char *cat_args[] = { "cat", "README", 0 };$?;"	v
cga_putc	console.c	?^cga_putc(int c)$?;"	f	file:
chan	proc.h	?^  void *chan;               // If non-zero, sleeping on chan$?;"	m	struct:proc
check_boot_pgdir	pmap.c	?^check_boot_pgdir()$?;"	f	file:
check_va2pa	pmap.c	?^check_va2pa(pde_t * pgdir, vaddr_t va)$?;"	f
checksum	mp.h	?^  uchar checksum;               // all bytes must add up to 0$?;"	m	struct:mp
checksum	mp.h	?^  uchar checksum;               // all bytes must add up to 0$?;"	m	struct:mpconf
cli	x86.h	?^cli(void)$?;"	f
cmd	sh.c	?^  struct cmd *cmd;$?;"	m	struct:backcmd	typeref:struct:backcmd::cmd	file:
cmd	sh.c	?^  struct cmd *cmd;$?;"	m	struct:redircmd	typeref:struct:redircmd::cmd	file:
cmd	sh.c	?^struct cmd {$?;"	s	file:
concreate	usertests.c	?^concreate(void)$?;"	f
cons_putc	console.c	?^cons_putc(int c)$?;"	f
console_init	console.c	?^console_init(void)$?;"	f
console_intr	console.c	?^console_intr(int (*getc)(void))$?;"	f
console_lock	console.c	?^static struct spinlock console_lock;$?;"	v	typeref:struct:spinlock	file:
console_read	console.c	?^console_read(struct inode *ip, char *dst, int n)$?;"	f
console_write	console.c	?^console_write(struct inode *ip, char *buf, int n)$?;"	f
cont	bootasm.S	?^cont:$?;"	l
context	proc.h	?^  struct context context;     // Switch here to enter scheduler$?;"	m	struct:cpu	typeref:struct:cpu::context
context	proc.h	?^  struct context context;   // Switch here to run process$?;"	m	struct:proc	typeref:struct:proc::context
context	proc.h	?^struct context {$?;"	s
copyproc	proc.c	?^copyproc(struct proc *p)$?;"	f
count	atomic.h	?^	int count;$?;"	m	struct:__anon3
cp	proc.h	85;"	d
cprintf	console.c	?^cprintf(char *fmt, ...)$?;"	f
cpu	lapic.c	?^cpu(void)$?;"	f
cpu	proc.h	?^struct cpu {$?;"	s
cpu	spinlock.h	?^  int  cpu;      // The number of the cpu holding the lock.$?;"	m	struct:spinlock
cpus	mp.c	?^struct cpu cpus[NCPU];$?;"	v	typeref:struct:cpu
cr3	mmu.h	?^  void *cr3;         // Page directory base$?;"	m	struct:taskstate
cr3	proc.h	?^  paddr_t cr3;                // cr3 register$?;"	m	struct:cpu
create	sysfile.c	?^create(char *path, int canexist, short type, short major, short minor)$?;"	f	file:
createdelete	usertests.c	?^createdelete(void)$?;"	f
createtest	usertests.c	?^createtest(void)$?;"	f
crt	console.c	?^static ushort *crt = (ushort*)0xb8000;  // CGA memory$?;"	v	file:
cs	mmu.h	?^  uint cs : 16;         // code segment selector$?;"	m	struct:gatedesc
cs	mmu.h	?^  ushort cs;$?;"	m	struct:taskstate
cs	x86.h	?^  ushort cs;$?;"	m	struct:trapframe
ctlmap	kbd.h	?^static uchar ctlmap[256] =$?;"	v
curproc	proc.c	?^curproc(void)$?;"	f
curproc	proc.h	?^  struct proc *curproc;       // Process currently running.$?;"	m	struct:cpu	typeref:struct:cpu::proc
cwd	proc.h	?^  struct inode *cwd;        // Current directory$?;"	m	struct:proc	typeref:struct:proc::inode
data	buf.h	?^  uchar data[512];$?;"	m	struct:buf
data	ioapic.c	?^  uint data;$?;"	m	struct:ioapic	file:
data	pipe.c	?^  char data[PIPESIZE];$?;"	m	struct:pipe	file:
db	mmu.h	?^  uint db : 1;         // 0 = 16-bit segment, 1 = 32-bit segment$?;"	m	struct:segdesc
dbg	kalloc.c	?^uint dbg = 0;$?;"	v
dbmsg	defs.h	152;"	d
dbmsg	defs.h	154;"	d
dev	buf.h	?^  uint dev;$?;"	m	struct:buf
dev	fsvar.h	?^  uint dev;           // Device number$?;"	m	struct:inode
dev	stat.h	?^  int dev;     // Device number$?;"	m	struct:stat
devsw	dev.h	?^struct devsw {$?;"	s
devsw	file.c	?^struct devsw devsw[NDEV];$?;"	v	typeref:struct:devsw
dinode	fs.h	?^struct dinode {$?;"	s
dirent	fs.h	?^struct dirent {$?;"	s
dirfile	usertests.c	?^dirfile(void)$?;"	f
dirlink	fs.c	?^dirlink(struct inode *dp, char *name, uint ino)$?;"	f
dirlookup	fs.c	?^dirlookup(struct inode *dp, char *name, uint *poff)$?;"	f
dirtest	usertests.c	?^void dirtest(void)$?;"	f
disk_1_present	ide.c	?^static int disk_1_present;$?;"	v	file:
do_unmap	pmap.c	?^do_unmap(pde_t * pgdir, vaddr_t va, uint size)$?;"	f
dpl	mmu.h	?^  uint dpl : 2;         // descriptor(meaning new) privilege level$?;"	m	struct:gatedesc
dpl	mmu.h	?^  uint dpl : 2;        // Descriptor Privilege Level$?;"	m	struct:segdesc
ds	mmu.h	?^  ushort ds;$?;"	m	struct:taskstate
ds	x86.h	?^  ushort ds;$?;"	m	struct:trapframe
e	console.c	?^  uint e;  // Edit index$?;"	m	struct:__anon1	file:
e820_memmap	kalloc.c	?^struct e820map * e820_memmap;$?;"	v	typeref:struct:e820map
e820map	pmap.h	?^struct e820map {$?;"	s
eargv	sh.c	?^  char *eargv[MAXARGS];$?;"	m	struct:execcmd	file:
eax	mmu.h	?^  uint eax;          // More saved state (registers)$?;"	m	struct:taskstate
eax	x86.h	?^  uint eax;$?;"	m	struct:trapframe
ebp	mmu.h	?^  uint *ebp;$?;"	m	struct:taskstate
ebp	proc.h	?^  int ebp;$?;"	m	struct:context
ebp	x86.h	?^  uint ebp;$?;"	m	struct:trapframe
ebx	mmu.h	?^  uint ebx;$?;"	m	struct:taskstate
ebx	proc.h	?^  int ebx;$?;"	m	struct:context
ebx	x86.h	?^  uint ebx;$?;"	m	struct:trapframe
echo_args	usertests.c	?^char *echo_args[] = { "echo", "ALL", "TESTS", "PASSED", 0 };$?;"	v
ecx	mmu.h	?^  uint ecx;$?;"	m	struct:taskstate
ecx	proc.h	?^  int ecx;$?;"	m	struct:context
ecx	x86.h	?^  uint ecx;$?;"	m	struct:trapframe
edi	mmu.h	?^  uint edi;$?;"	m	struct:taskstate
edi	proc.h	?^  int edi;$?;"	m	struct:context
edi	x86.h	?^  uint edi;$?;"	m	struct:trapframe
edx	mmu.h	?^  uint edx;$?;"	m	struct:taskstate
edx	proc.h	?^  int edx;$?;"	m	struct:context
edx	x86.h	?^  uint edx;$?;"	m	struct:trapframe
efile	sh.c	?^  char *efile;$?;"	m	struct:redircmd	file:
eflags	mmu.h	?^  uint eflags;$?;"	m	struct:taskstate
eflags	x86.h	?^  uint eflags;$?;"	m	struct:trapframe
ehsize	elf.h	?^  ushort ehsize;$?;"	m	struct:elfhdr
eip	mmu.h	?^  uint *eip;         // Saved state from last task switch$?;"	m	struct:taskstate
eip	proc.h	?^  int eip;$?;"	m	struct:context
eip	x86.h	?^  uint eip;$?;"	m	struct:trapframe
elf	elf.h	?^  uchar elf[12];$?;"	m	struct:elfhdr
elfhdr	elf.h	?^struct elfhdr {$?;"	s
enable_paging	pmap.c	?^enable_paging(void)$?;"	f
end_code	proc.h	?^  vaddr_t end_code;         // End address of executable code$?;"	m	struct:proc_vm
end_data	proc.h	?^  vaddr_t end_data;         // End address of data$?;"	m	struct:proc_vm
entry	elf.h	?^  uint entry;$?;"	m	struct:elfhdr
entry	mp.h	?^  ushort entry;                 // entry count$?;"	m	struct:mpconf
err	x86.h	?^  uint err;$?;"	m	struct:trapframe
es	mmu.h	?^  ushort es;         // Even more saved state (segment selectors)$?;"	m	struct:taskstate
es	x86.h	?^  ushort es;$?;"	m	struct:trapframe
esi	mmu.h	?^  uint esi;$?;"	m	struct:taskstate
esi	proc.h	?^  int esi;$?;"	m	struct:context
esi	x86.h	?^  uint esi;$?;"	m	struct:trapframe
esp	mmu.h	?^  uint *esp;$?;"	m	struct:taskstate
esp	proc.h	?^  int esp;$?;"	m	struct:context
esp	x86.h	?^  uint esp;$?;"	m	struct:trapframe
esp0	mmu.h	?^  uint esp0;         // Stack pointers and segment selectors$?;"	m	struct:taskstate
esp1	mmu.h	?^  uint *esp1;$?;"	m	struct:taskstate
esp2	mmu.h	?^  uint *esp2;$?;"	m	struct:taskstate
exec	exec.c	?^exec(char *path, char **argv)$?;"	f
execcmd	sh.c	?^execcmd(void)$?;"	f
execcmd	sh.c	?^struct execcmd {$?;"	s	file:
exectest	usertests.c	?^exectest(void)$?;"	f
exit	initcode.S	?^exit:$?;"	l
exit	proc.c	?^exit(void)$?;"	f
exitwait	usertests.c	?^exitwait(void)$?;"	f
f	Makefile	?^	dd if=/dev/zero of=xv6.img count=10000$?;"	m
f	Makefile	?^	dd if=bootblock of=xv6.img conv=notrunc$?;"	m
f	Makefile	?^	dd if=kernel of=xv6.img seek=1 conv=notrunc$?;"	m
fd	sh.c	?^  int fd;$?;"	m	struct:redircmd	file:
fdalloc	sysfile.c	?^fdalloc(struct file *f)$?;"	f	file:
feature	mp.h	?^  uint feature;                 // feature flags from CPUID instruction$?;"	m	struct:mpproc
fetchint	syscall.c	?^fetchint(struct proc *p, uint addr, int *ip)$?;"	f
fetchstr	syscall.c	?^fetchstr(struct proc *p, uint addr, char **pp)$?;"	f
file	file.c	?^struct file file[NFILE];$?;"	v	typeref:struct:file
file	file.h	?^struct file {$?;"	s
file	sh.c	?^  char *file;$?;"	m	struct:redircmd	file:
file_table_lock	file.c	?^struct spinlock file_table_lock;$?;"	v	typeref:struct:spinlock
filealloc	file.c	?^filealloc(void)$?;"	f
fileclose	file.c	?^fileclose(struct file *f)$?;"	f
filedup	file.c	?^filedup(struct file *f)$?;"	f
fileinit	file.c	?^fileinit(void)$?;"	f
fileread	file.c	?^fileread(struct file *f, char *addr, int n)$?;"	f
filestat	file.c	?^filestat(struct file *f, struct stat *st)$?;"	f
filesz	elf.h	?^  uint filesz;$?;"	m	struct:proghdr
filewrite	file.c	?^filewrite(struct file *f, char *addr, int n)$?;"	f
finish_probe	bootasm.S	?^finish_probe:$?;"	l
flags	buf.h	?^  int flags;$?;"	m	struct:buf
flags	elf.h	?^  uint flags;$?;"	m	struct:elfhdr
flags	elf.h	?^  uint flags;$?;"	m	struct:proghdr
flags	fsvar.h	?^  int flags;          // I_BUSY, I_VALID$?;"	m	struct:inode
flags	mp.h	?^  uchar flags;                  // CPU flags$?;"	m	struct:mpproc
flags	mp.h	?^  uchar flags;                  // I/O APIC flags$?;"	m	struct:mpioapic
flags	pmap.h	?^	uint32_t flags;  // flags for page descriptors$?;"	m	struct:Page
fmtname	ls.c	?^fmtname(char *path)$?;"	f
fork1	sh.c	?^fork1(void)$?;"	f
forkret	proc.c	?^forkret(void)$?;"	f
forkret1	trapasm.S	?^forkret1:$?;"	l
forktest	forktest.c	?^forktest(void)$?;"	f
forktest	usertests.c	?^forktest(void)$?;"	f
fourteen	usertests.c	?^fourteen(void)$?;"	f
free	umalloc.c	?^free(void *ap)$?;"	f
free_area	buddy.c	?^free_area_t free_area[MAX_ORDER];$?;"	v
free_area	buddy.h	?^typedef struct free_area {$?;"	s
free_area_t	buddy.h	?^} free_area_t;$?;"	t	typeref:struct:free_area
free_list	buddy.h	?^	page_list_head_t free_list;$?;"	m	struct:free_area
free_pages_bulk	buddy.c	?^free_pages_bulk(struct Page * page, int order)$?;"	f
freeblock	mkfs.c	?^uint freeblock;$?;"	v
freeinode	mkfs.c	?^uint freeinode = 1;$?;"	v
freelist	kalloc.c	?^struct run *freelist;$?;"	v	typeref:struct:run
freep	umalloc.c	?^static Header *freep;$?;"	v	file:
fs	mmu.h	?^  ushort fs;$?;"	m	struct:taskstate
fsfd	mkfs.c	?^int fsfd;$?;"	v
g	mmu.h	?^  uint g : 1;          // Granularity: limit scaled by 4K when set$?;"	m	struct:segdesc
gatedesc	mmu.h	?^struct gatedesc {$?;"	s
gdt	bootasm.S	?^gdt:$?;"	l
gdt	bootother.S	?^gdt:$?;"	l
gdt	meminfo.S	?^gdt:$?;"	l
gdt	proc.h	?^  struct segdesc gdt[NSEGS];  // x86 global descriptor table$?;"	m	struct:cpu	typeref:struct:cpu::segdesc
gdtdesc	bootasm.S	?^gdtdesc:$?;"	l
gdtdesc	bootother.S	?^gdtdesc:$?;"	l
gdtdesc	meminfo.S	?^gdtdesc:$?;"	l
get_pte	pmap.c	?^get_pte(pde_t * pgdir, vaddr_t va, int create)$?;"	f
getcallerpcs	spinlock.c	?^getcallerpcs(void *v, uint pcs[])$?;"	f
getcmd	sh.c	?^getcmd(char *buf, int nbuf)$?;"	f
gets	ulib.c	?^gets(char *buf, int max)$?;"	f
gettoken	sh.c	?^gettoken(char **ps, char *es, char **q, char **eq)$?;"	f
grep	grep.c	?^grep(char *pattern, int fd)$?;"	f
growproc	proc.c	?^growproc(int n)$?;"	f
gs	mmu.h	?^  ushort gs;$?;"	m	struct:taskstate
header	umalloc.c	?^union header {$?;"	u	file:
holding	spinlock.c	?^holding(struct spinlock *lock)$?;"	f
i2b	mkfs.c	?^i2b(uint inum)$?;"	f
i386_vm_init	pmap.c	?^i386_vm_init(void)$?;"	f
ialloc	fs.c	?^ialloc(uint dev, short type)$?;"	f
ialloc	mkfs.c	?^ialloc(ushort type)$?;"	f
iappend	mkfs.c	?^iappend(uint inum, void *xp, int n)$?;"	f
icache	fs.c	?^} icache;$?;"	v	typeref:struct:__anon6
ide_init	ide.c	?^ide_init(void)$?;"	f
ide_intr	ide.c	?^ide_intr(void)$?;"	f
ide_lock	ide.c	?^static struct spinlock ide_lock;$?;"	v	typeref:struct:spinlock	file:
ide_queue	ide.c	?^static struct buf *ide_queue;$?;"	v	typeref:struct:buf	file:
ide_rw	ide.c	?^ide_rw(struct buf *b)$?;"	f
ide_start_request	ide.c	?^ide_start_request(struct buf *b)$?;"	f	file:
ide_wait_ready	ide.c	?^ide_wait_ready(int check_error)$?;"	f	file:
idt	trap.c	?^struct gatedesc idt[256];$?;"	v	typeref:struct:gatedesc
idtinit	trap.c	?^idtinit(void)$?;"	f
idup	fs.c	?^idup(struct inode *ip)$?;"	f
iget	fs.c	?^iget(uint dev, uint inum)$?;"	f	file:
iinit	fs.c	?^iinit(void)$?;"	f
ilock	fs.c	?^ilock(struct inode *ip)$?;"	f
imcrp	mp.h	?^  uchar imcrp;$?;"	m	struct:mp
inb	x86.h	?^inb(ushort port)$?;"	f
index	pmap.h	?^	uint32_t index;$?;"	m	struct:Page
init	initcode.S	?^init:$?;"	l
init_memmap	buddy.c	?^init_memmap(struct Page * base, unsigned long nr)$?;"	f
init_pages_list	kalloc.c	?^init_pages_list(paddr_t start_addr, uint len, uint32_t flags)$?;"	f
init_phypages	kalloc.c	?^init_phypages(void)$?;"	f
initlock	spinlock.c	?^initlock(struct spinlock *lock, char *name)$?;"	f
initproc	proc.c	?^static struct proc *initproc;$?;"	v	typeref:struct:proc	file:
ino	stat.h	?^  uint ino;    // Inode number on device$?;"	m	struct:stat
inode	fs.c	?^  struct inode inode[NINODE];$?;"	m	struct:__anon6	typeref:struct:__anon6::inode	file:
inode	fsvar.h	?^struct inode {$?;"	s
input	console.c	?^} input;$?;"	v	typeref:struct:__anon1
insert_page	pmap.c	?^insert_page(pde_t * pgdir, paddr_t pa, vaddr_t va, uint perm, uint kmap)$?;"	f
insl	x86.h	?^insl(int port, void *addr, int cnt)$?;"	f
intena	proc.h	?^  int intena;                 // Were interrupts enabled before pushcli\? $?;"	m	struct:cpu
inum	fs.h	?^  ushort inum;$?;"	m	struct:dirent
inum	fsvar.h	?^  uint inum;          // Inode number$?;"	m	struct:inode
ioapic	ioapic.c	?^struct ioapic {$?;"	s	file:
ioapic	ioapic.c	?^volatile struct ioapic *ioapic;$?;"	v	typeref:struct:ioapic
ioapic_enable	ioapic.c	?^ioapic_enable(int irq, int cpunum)$?;"	f
ioapic_id	mp.c	?^uchar ioapic_id;$?;"	v
ioapic_init	ioapic.c	?^ioapic_init(void)$?;"	f
ioapic_read	ioapic.c	?^ioapic_read(int reg)$?;"	f	file:
ioapic_write	ioapic.c	?^ioapic_write(int reg, uint data)$?;"	f	file:
iomb	mmu.h	?^  ushort iomb;       // I/O map base address$?;"	m	struct:taskstate
ip	file.h	?^  struct inode *ip;$?;"	m	struct:file	typeref:struct:file::inode
iput	fs.c	?^iput(struct inode *ip)$?;"	f
iref	usertests.c	?^iref(void)$?;"	f
irqmask	picirq.c	?^static ushort irqmask = 0xFFFF & ~(1<<IRQ_SLAVE);$?;"	v	file:
isdirempty	sysfile.c	?^isdirempty(struct inode *dp)$?;"	f	file:
ismp	mp.c	?^int ismp;$?;"	v
itrunc	fs.c	?^itrunc(struct inode *ip)$?;"	f	file:
iunlock	fs.c	?^iunlock(struct inode *ip)$?;"	f
iunlockput	fs.c	?^iunlockput(struct inode *ip)$?;"	f
iupdate	fs.c	?^iupdate(struct inode *ip)$?;"	f
k	proc.h	?^  char *k;$?;"	m	struct:proc
kalloc	kalloc.c	?^kalloc(int n)$?;"	f
kalloc_lock	kalloc.c	?^struct spinlock kalloc_lock;$?;"	v	typeref:struct:spinlock
kbd_getc	kbd.c	?^kbd_getc(void)$?;"	f
kbd_intr	kbd.c	?^kbd_intr(void)$?;"	f
kfree	kalloc.c	?^kfree(char *v, int len)$?;"	f
kill	proc.c	?^kill(int pid)$?;"	f
killed	proc.h	?^  int killed;               // If non-zero, have been killed$?;"	m	struct:proc
kinit	kalloc.c	?^kinit(void)$?;"	f
kstack	proc.h	?^  char *kstack;             // Bottom of kernel stack for this process$?;"	m	struct:proc
lapic	lapic.c	?^volatile uint *lapic;  // Initialized in mp.c$?;"	v
lapic_eoi	lapic.c	?^lapic_eoi(void)$?;"	f
lapic_init	lapic.c	?^lapic_init(int c)$?;"	f
lapic_startap	lapic.c	?^lapic_startap(uchar apicid, uint addr)$?;"	f
lapicaddr	mp.h	?^  uint *lapicaddr;              // address of local APIC$?;"	m	struct:mpconf
lapicw	lapic.c	?^lapicw(int index, int value)$?;"	f	file:
lcr0	x86.h	?^lcr0(uint val)$?;"	f
lcr3	x86.h	?^lcr3(uint val)$?;"	f
ldt	mmu.h	?^  ushort ldt;$?;"	m	struct:taskstate
left	sh.c	?^  struct cmd *left;$?;"	m	struct:listcmd	typeref:struct:listcmd::cmd	file:
left	sh.c	?^  struct cmd *left;$?;"	m	struct:pipecmd	typeref:struct:pipecmd::cmd	file:
len	kalloc.c	?^  int len; // bytes$?;"	m	struct:run	file:
length	mp.h	?^  uchar length;                 // 1$?;"	m	struct:mp
length	mp.h	?^  ushort length;                // total table length$?;"	m	struct:mpconf
lgdt	x86.h	?^lgdt(struct segdesc *p, int size)$?;"	f
lidt	x86.h	?^lidt(struct gatedesc *p, int size)$?;"	f
lim_15_0	mmu.h	?^  uint lim_15_0 : 16;  // Low bits of segment limit$?;"	m	struct:segdesc
lim_19_16	mmu.h	?^  uint lim_19_16 : 4;  // High bits of segment limit$?;"	m	struct:segdesc
link	mmu.h	?^  uint link;         // Old ts selector$?;"	m	struct:taskstate
linktest	usertests.c	?^linktest(void)$?;"	f
listcmd	sh.c	?^listcmd(struct cmd *left, struct cmd *right)$?;"	f
listcmd	sh.c	?^struct listcmd {$?;"	s	file:
lock	console.c	?^  struct spinlock lock;$?;"	m	struct:__anon1	typeref:struct:__anon1::spinlock	file:
lock	fs.c	?^  struct spinlock lock;$?;"	m	struct:__anon6	typeref:struct:__anon6::spinlock	file:
lock	pipe.c	?^  struct spinlock lock;$?;"	m	struct:pipe	typeref:struct:pipe::spinlock	file:
locked	spinlock.h	?^  uint locked;   // Is the lock held\?$?;"	m	struct:spinlock
lpt_putc	console.c	?^lpt_putc(int c)$?;"	f	file:
lru	pmap.h	?^	page_list_entry_t lru; /* free list link */$?;"	m	struct:Page
ls	ls.c	?^ls(char *path)$?;"	f
ltr	x86.h	?^ltr(ushort sel)$?;"	f
machine	elf.h	?^  ushort machine;$?;"	m	struct:elfhdr
magic	elf.h	?^  uint magic;  // must equal ELF_MAGIC$?;"	m	struct:elfhdr
main	cat.c	?^main(int argc, char *argv[])$?;"	f
main	echo.c	?^main(int argc, char *argv[])$?;"	f
main	forktest.c	?^main(void)$?;"	f
main	grep.c	?^main(int argc, char *argv[])$?;"	f
main	init.c	?^main(void)$?;"	f
main	kill.c	?^main(int argc, char **argv)$?;"	f
main	ln.c	?^main(int argc, char *argv[])$?;"	f
main	ls.c	?^main(int argc, char *argv[])$?;"	f
main	main.c	?^main(void)$?;"	f
main	mkdir.c	?^main(int argc, char *argv[])$?;"	f
main	mkfs.c	?^main(int argc, char *argv[])$?;"	f
main	rm.c	?^main(int argc, char *argv[])$?;"	f
main	sh.c	?^main(void)$?;"	f
main	usertests.c	?^main(int argc, char *argv[])$?;"	f
main	wc.c	?^main(int argc, char *argv[])$?;"	f
main	zombie.c	?^main(void)$?;"	f
major	fs.h	?^  short major;          // Major device number (T_DEV only)$?;"	m	struct:dinode
major	fsvar.h	?^  short major;$?;"	m	struct:inode
malloc	umalloc.c	?^malloc(uint nbytes)$?;"	f
map	pmap.h	?^	} map[E820MAX];$?;"	m	struct:e820map	typeref:struct:e820map::__anon2
map_segment	pmap.c	?^map_segment(pde_t * pgdir, paddr_t pa, vaddr_t la, uint size, uint perm)$?;"	f
mapcount	pmap.h	?^	uint32_t mapcount;  // number of page table entries that refer to the page frame$?;"	m	struct:Page
match	grep.c	?^match(char *re, char *text)$?;"	f
matchhere	grep.c	?^int matchhere(char *re, char *text)$?;"	f
matchstar	grep.c	?^int matchstar(int c, char *re, char *text)$?;"	f
mem	proc.h	?^  char *mem;                // Start of process memory (kernel address)$?;"	m	struct:proc
mem	usertests.c	?^mem(void)$?;"	f
mem_map	buddy.c	?^struct Page * mem_map;$?;"	v	typeref:struct:Page
memcmp	string.c	?^memcmp(const void *v1, const void *v2, uint n)$?;"	f
memmove	string.c	?^memmove(void *dst, const void *src, uint n)$?;"	f
memmove	ulib.c	?^memmove(void *vdst, void *vsrc, int n)$?;"	f
memset	string.c	?^memset(void *dst, int c, uint n)$?;"	f
memset	ulib.c	?^memset(void *dst, int c, uint n)$?;"	f
memsz	elf.h	?^  uint memsz;$?;"	m	struct:proghdr
microdelay	lapic.c	?^microdelay(int us)$?;"	f	file:
min	fs.c	25;"	d	file:
min	mkfs.c	236;"	d	file:
minor	fs.h	?^  short minor;          // Minor device number (T_DEV only)$?;"	m	struct:dinode
minor	fsvar.h	?^  short minor;$?;"	m	struct:inode
mode	sh.c	?^  int mode;$?;"	m	struct:redircmd	file:
morecore	umalloc.c	?^morecore(uint nu)$?;"	f	file:
mp	mp.h	?^struct mp {             // floating pointer$?;"	s
mp_bcpu	mp.c	?^mp_bcpu(void)$?;"	f
mp_config	mp.c	?^mp_config(struct mp **pmp)$?;"	f	file:
mp_init	mp.c	?^mp_init(void)$?;"	f
mp_search	mp.c	?^mp_search(void)$?;"	f	file:
mp_search1	mp.c	?^mp_search1(uchar *addr, int len)$?;"	f	file:
mpconf	mp.h	?^struct mpconf {         // configuration table header$?;"	s
mpioapic	mp.h	?^struct mpioapic {       // I/O APIC table entry$?;"	s
mpmain	main.c	?^mpmain(void)$?;"	f	file:
mpproc	mp.h	?^struct mpproc {         // processor table entry$?;"	s
name	fs.h	?^  char name[DIRSIZ];$?;"	m	struct:dirent
name	proc.h	?^  char name[16];            // Process name (debugging)$?;"	m	struct:proc
name	spinlock.h	?^  char *name;    // Name of lock.$?;"	m	struct:spinlock
name	usertests.c	?^char name[3];$?;"	v
name	usys.S	?^  name: \\$?;"	l
namecmp	fs.c	?^namecmp(const char *s, const char *t)$?;"	f
namei	fs.c	?^namei(char *path)$?;"	f
nameiparent	fs.c	?^nameiparent(char *path, char *name)$?;"	f
nblocks	fs.h	?^  uint nblocks;      // Number of data blocks$?;"	m	struct:superblock
nblocks	mkfs.c	?^int nblocks = 995;$?;"	v
ncli	proc.h	?^  int ncli;                   // Depth of pushcli nesting.$?;"	m	struct:cpu
ncpu	mp.c	?^int ncpu;$?;"	v
next	buf.h	?^  struct buf *next;$?;"	m	struct:buf	typeref:struct:buf::buf
next	kalloc.c	?^  struct run *next;$?;"	m	struct:run	typeref:struct:run::run	file:
nextpid	proc.c	?^int nextpid = 1;$?;"	v
ninodes	fs.h	?^  uint ninodes;      // Number of inodes.$?;"	m	struct:superblock
ninodes	mkfs.c	?^int ninodes = 200;$?;"	v
nlink	fs.h	?^  short nlink;          // Number of links to inode in file system$?;"	m	struct:dinode
nlink	fsvar.h	?^  short nlink;$?;"	m	struct:inode
nlink	stat.h	?^  short nlink; // Number of links to file$?;"	m	struct:stat
normalmap	kbd.h	?^static uchar normalmap[256] =$?;"	v
npages	kalloc.c	?^uint npages;  // number of available pages$?;"	v
nr_free	buddy.h	?^	unsigned long nr_free;$?;"	m	struct:free_area
nr_map	pmap.h	?^	int nr_map;$?;"	m	struct:e820map
nulterminate	sh.c	?^nulterminate(struct cmd *cmd)$?;"	f
oemlength	mp.h	?^  ushort oemlength;             // OEM table length$?;"	m	struct:mpconf
oemtable	mp.h	?^  uint *oemtable;               // OEM table pointer$?;"	m	struct:mpconf
oesp	x86.h	?^  uint oesp;      // useless & ignored$?;"	m	struct:trapframe
off	file.h	?^  uint off;$?;"	m	struct:file
off_15_0	mmu.h	?^  uint off_15_0 : 16;   // low 16 bits of offset in segment$?;"	m	struct:gatedesc
off_31_16	mmu.h	?^  uint off_31_16 : 16;  // high bits of offset in segment$?;"	m	struct:gatedesc
offset	elf.h	?^  uint offset;$?;"	m	struct:proghdr
ofile	proc.h	?^  struct file *ofile[NOFILE];  // Open files$?;"	m	struct:proc	typeref:struct:proc::file
opentest	usertests.c	?^opentest(void)$?;"	f
outb	x86.h	?^outb(ushort port, uchar data)$?;"	f
outsl	x86.h	?^outsl(int port, const void *addr, int cnt)$?;"	f
outw	x86.h	?^outw(ushort port, ushort data)$?;"	f
p	mmu.h	?^  uint p : 1;           // Present$?;"	m	struct:gatedesc
p	mmu.h	?^  uint p : 1;          // Present$?;"	m	struct:segdesc
pa	elf.h	?^  uint pa;$?;"	m	struct:proghdr
pad	ioapic.c	?^  uint pad[3];$?;"	m	struct:ioapic	file:
padding1	mmu.h	?^  ushort padding1;$?;"	m	struct:taskstate
padding1	x86.h	?^  ushort padding1;$?;"	m	struct:trapframe
padding10	mmu.h	?^  ushort padding10;$?;"	m	struct:taskstate
padding2	mmu.h	?^  ushort padding2;$?;"	m	struct:taskstate
padding2	x86.h	?^  ushort padding2;$?;"	m	struct:trapframe
padding3	mmu.h	?^  ushort padding3;$?;"	m	struct:taskstate
padding3	x86.h	?^  ushort padding3;$?;"	m	struct:trapframe
padding4	mmu.h	?^  ushort padding4;$?;"	m	struct:taskstate
padding4	x86.h	?^  ushort padding4;$?;"	m	struct:trapframe
padding5	mmu.h	?^  ushort padding5;$?;"	m	struct:taskstate
padding6	mmu.h	?^  ushort padding6;$?;"	m	struct:taskstate
padding7	mmu.h	?^  ushort padding7;$?;"	m	struct:taskstate
padding8	mmu.h	?^  ushort padding8;$?;"	m	struct:taskstate
padding9	mmu.h	?^  ushort padding9;$?;"	m	struct:taskstate
paddr_t	types.h	?^typedef uint paddr_t;$?;"	t
page_addr	pmap.h	49;"	d
page_frame	pmap.h	48;"	d
page_is_buddy	buddy.c	?^page_is_buddy(struct Page * page, int order)$?;"	f
page_list_entry_t	pmap.h	?^typedef LIST_ENTRY(Page) page_list_entry_t;$?;"	t
page_list_head_t	pmap.h	?^typedef LIST_HEAD(Page_list, Page) page_list_head_t;$?;"	t
page_t	pmap.h	?^typedef struct Page page_t;$?;"	t	typeref:struct:Page
page_table_lock	proc.h	?^  spinlock_t page_table_lock;  // Page table's spin lock$?;"	m	struct:proc_vm
pages	pmap.c	?^struct Page * pages;    // Physical Page descriptor array$?;"	v	typeref:struct:Page
pages	pmap.c	?^struct Page * pages;    // all page descriptors $?;"	v	typeref:struct:Page
panic	console.c	?^panic(char *s)$?;"	f
panic	sh.c	?^panic(char *s)$?;"	f
panicked	console.c	?^int panicked = 0;$?;"	v
parent	proc.h	?^  struct proc *parent;      // Parent process$?;"	m	struct:proc	typeref:struct:proc::proc
parseblock	sh.c	?^parseblock(char **ps, char *es)$?;"	f
parsecmd	sh.c	?^parsecmd(char *s)$?;"	f
parseexec	sh.c	?^parseexec(char **ps, char *es)$?;"	f
parseline	sh.c	?^parseline(char **ps, char *es)$?;"	f
parsepipe	sh.c	?^parsepipe(char **ps, char *es)$?;"	f
parseredirs	sh.c	?^parseredirs(struct cmd *cmd, char **ps, char *es)$?;"	f
pcs	spinlock.h	?^  uint pcs[10];  // The call stack (an array of program counters)$?;"	m	struct:spinlock
pde_t	types.h	?^typedef uint pde_t;$?;"	t
peek	sh.c	?^peek(char **ps, char *es, char *toks)$?;"	f
pgdir	proc.h	?^  pde_t * pgdir;            // Pointer to the page directory$?;"	m	struct:proc_vm
phentsize	elf.h	?^  ushort phentsize;$?;"	m	struct:elfhdr
phnum	elf.h	?^  ushort phnum;$?;"	m	struct:elfhdr
phoff	elf.h	?^  uint phoff;$?;"	m	struct:elfhdr
phy_mem_lock	pmap.c	?^spinlock_t phy_mem_lock;$?;"	v
physaddr	mp.h	?^  void *physaddr;               // phys addr of MP config table$?;"	m	struct:mp
pic_enable	picirq.c	?^pic_enable(int irq)$?;"	f
pic_init	picirq.c	?^pic_init(void)$?;"	f
pic_setmask	picirq.c	?^pic_setmask(ushort mask)$?;"	f	file:
pid	proc.h	?^  int pid;                  // Process ID$?;"	m	struct:proc
pinit	proc.c	?^pinit(void)$?;"	f
pipe	file.h	?^  struct pipe *pipe;$?;"	m	struct:file	typeref:struct:file::pipe
pipe	pipe.c	?^struct pipe {$?;"	s	file:
pipe1	usertests.c	?^pipe1(void)$?;"	f
pipealloc	pipe.c	?^pipealloc(struct file **f0, struct file **f1)$?;"	f
pipeclose	pipe.c	?^pipeclose(struct pipe *p, int writable)$?;"	f
pipecmd	sh.c	?^pipecmd(struct cmd *left, struct cmd *right)$?;"	f
pipecmd	sh.c	?^struct pipecmd {$?;"	s	file:
piperead	pipe.c	?^piperead(struct pipe *p, char *addr, int n)$?;"	f
pipewrite	pipe.c	?^pipewrite(struct pipe *p, char *addr, int n)$?;"	f
popcli	spinlock.c	?^popcli(void)$?;"	f
preempt	usertests.c	?^preempt(void)$?;"	f
prev	buf.h	?^  struct buf *prev; // LRU cache list$?;"	m	struct:buf	typeref:struct:buf::buf
print_buddy	buddy.c	?^print_buddy()$?;"	f
printf	forktest.c	?^printf(int fd, char *s, ...)$?;"	f
printf	printf.c	?^printf(int fd, char *fmt, ...)$?;"	f
printint	console.c	?^printint(int xx, int base, int sgn)$?;"	f
printint	printf.c	?^printint(int fd, int xx, int base, int sgn)$?;"	f	file:
probe_memory	bootasm.S	?^probe_memory:$?;"	l
proc	proc.c	?^struct proc proc[NPROC];$?;"	v	typeref:struct:proc
proc	proc.h	?^struct proc {$?;"	s
proc_state	proc.h	?^enum proc_state { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$?;"	g
proc_table_lock	proc.c	?^struct spinlock proc_table_lock;$?;"	v	typeref:struct:spinlock
proc_vm	proc.h	?^struct proc_vm {$?;"	s
procdump	proc.c	?^procdump(void)$?;"	f
product	mp.h	?^  uchar product[20];            // product id$?;"	m	struct:mpconf
proghdr	elf.h	?^struct proghdr {$?;"	s
property	pmap.h	?^	uint32_t property;  // when the page is free , this field is used by the buddy system$?;"	m	struct:Page
protcseg	bootasm.S	?^protcseg:$?;"	l
protcseg	bootother.S	?^protcseg:$?;"	l
protcseg	meminfo.S	?^protcseg:$?;"	l
pte_t	types.h	?^typedef uint pte_t;$?;"	t
ptr	umalloc.c	?^    union header *ptr;$?;"	m	struct:header::__anon5	typeref:union:header::__anon5::header	file:
pushcli	spinlock.c	?^pushcli(void)$?;"	f
putc	printf.c	?^putc(int fd, char c)$?;"	f	file:
qnext	buf.h	?^  struct buf *qnext; // disk queue$?;"	m	struct:buf	typeref:struct:buf::buf
r	console.c	?^  uint r;  // Read index$?;"	m	struct:__anon1	file:
rcr0	x86.h	?^rcr0(void)$?;"	f
rcr2	x86.h	?^rcr2(void)$?;"	f
rcr3	x86.h	?^rcr3(void)$?;"	f
read	dev.h	?^  int (*read)(struct inode*, char*, int);$?;"	m	struct:devsw
read_ebp	x86.h	?^read_ebp(void)$?;"	f
read_eflags	x86.h	?^read_eflags(void)$?;"	f
readable	file.h	?^  char readable;$?;"	m	struct:file
readi	fs.c	?^readi(struct inode *ip, char *dst, uint off, uint n)$?;"	f
readopen	pipe.c	?^  int readopen;   // read fd is still open$?;"	m	struct:pipe	file:
readp	pipe.c	?^  uint readp;     // next index to read$?;"	m	struct:pipe	file:
readsb	fs.c	?^readsb(int dev, struct superblock *sb)$?;"	f	file:
readsect	bootmain.c	?^readsect(void *dst, uint offset)$?;"	f
readseg	bootmain.c	?^readseg(uint va, uint count, uint offset)$?;"	f
realcseg	meminfo.S	?^realcseg:$?;"	l
redircmd	sh.c	?^redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)$?;"	f
redircmd	sh.c	?^struct redircmd {$?;"	s	file:
ref	file.h	?^  int ref; // reference count$?;"	m	struct:file
ref	fsvar.h	?^  int ref;            // Reference count$?;"	m	struct:inode
reg	ioapic.c	?^  uint reg;$?;"	m	struct:ioapic	file:
release	spinlock.c	?^release(struct spinlock *lock)$?;"	f
remove_page	pmap.c	?^remove_page(pde_t * pgdir, vaddr_t va)$?;"	f
remove_pte	pmap.c	?^remove_pte(pde_t * pgdir, pte_t * pte)$?;"	f
reserved	mp.h	?^  uchar reserved;$?;"	m	struct:mpconf
reserved	mp.h	?^  uchar reserved[3];$?;"	m	struct:mp
reserved	mp.h	?^  uchar reserved[8];$?;"	m	struct:mpproc
right	sh.c	?^  struct cmd *right;$?;"	m	struct:listcmd	typeref:struct:listcmd::cmd	file:
right	sh.c	?^  struct cmd *right;$?;"	m	struct:pipecmd	typeref:struct:pipecmd::cmd	file:
rinode	mkfs.c	?^rinode(uint inum, struct dinode *ip)$?;"	f
rmdot	usertests.c	?^rmdot(void)$?;"	f
rsect	mkfs.c	?^rsect(uint sec, void *buf)$?;"	f
rsv1	mmu.h	?^  uint rsv1 : 1;       // Reserved$?;"	m	struct:segdesc
rsv1	mmu.h	?^  uint rsv1 : 3;        // reserved(should be zero I guess)$?;"	m	struct:gatedesc
run	kalloc.c	?^struct run {$?;"	s	file:
runcmd	sh.c	?^runcmd(struct cmd *cmd)$?;"	f
s	mmu.h	?^  uint s : 1;           // must be 0 (system)$?;"	m	struct:gatedesc
s	mmu.h	?^  uint s : 1;          // 0 = system, 1 = application$?;"	m	struct:segdesc
s	umalloc.c	?^  } s;$?;"	m	union:header	typeref:struct:header::__anon5	file:
safestrcpy	string.c	?^safestrcpy(char *s, const char *t, int n)$?;"	f
sb	mkfs.c	?^struct superblock sb;$?;"	v	typeref:struct:superblock
sched	proc.c	?^sched(void)$?;"	f
scheduler	proc.c	?^scheduler(void)$?;"	f
sector	buf.h	?^  uint sector;$?;"	m	struct:buf
segdesc	mmu.h	?^struct segdesc {$?;"	s
segment	meminfo.S	?^segment .text$?;"	l
setupsegs	proc.c	?^setupsegs(struct proc *p)$?;"	f
sh_args	init.c	?^char *sh_args[] = { "sh", 0 };$?;"	v
sharedfd	usertests.c	?^sharedfd(void)$?;"	f
shentsize	elf.h	?^  ushort shentsize;$?;"	m	struct:elfhdr
shiftcode	kbd.h	?^static uchar shiftcode[256] =$?;"	v
shiftmap	kbd.h	?^static uchar shiftmap[256] =$?;"	v
shnum	elf.h	?^  ushort shnum;$?;"	m	struct:elfhdr
shoff	elf.h	?^  uint shoff;$?;"	m	struct:elfhdr
shstrndx	elf.h	?^  ushort shstrndx;$?;"	m	struct:elfhdr
signature	mp.h	?^  uchar signature[4];           // "PCMP"$?;"	m	struct:mpconf
signature	mp.h	?^  uchar signature[4];           // "_MP_"$?;"	m	struct:mp
signature	mp.h	?^  uchar signature[4];           // CPU signature$?;"	m	struct:mpproc
size	fs.h	?^  uint size;            // Size of file (bytes)$?;"	m	struct:dinode
size	fs.h	?^  uint size;         // Size of file system image (blocks)$?;"	m	struct:superblock
size	fsvar.h	?^  uint size;$?;"	m	struct:inode
size	mkfs.c	?^int size = 1024;$?;"	v
size	pmap.h	?^		long long size;$?;"	m	struct:e820map::__anon2
size	stat.h	?^  uint size;   // Size of file in bytes$?;"	m	struct:stat
size	umalloc.c	?^    uint size;$?;"	m	struct:header::__anon5	file:
skipelem	fs.c	?^skipelem(char *path, char *name)$?;"	f	file:
sleep	proc.c	?^sleep(void *chan, struct spinlock *lk)$?;"	f
specrev	mp.h	?^  uchar specrev;                // [14]$?;"	m	struct:mp
spin	bootasm.S	?^spin:$?;"	l
spin	meminfo.S	?^spin:$?;"	l
spinlock	spinlock.h	?^struct spinlock {$?;"	s
spinlock_t	spinlock.h	?^typedef struct spinlock spinlock_t;$?;"	t	typeref:struct:spinlock
ss	mmu.h	?^  ushort ss;$?;"	m	struct:taskstate
ss	x86.h	?^  ushort ss;$?;"	m	struct:trapframe
ss0	mmu.h	?^  ushort ss0;        //   after an increase in privilege level$?;"	m	struct:taskstate
ss1	mmu.h	?^  ushort ss1;$?;"	m	struct:taskstate
ss2	mmu.h	?^  ushort ss2;$?;"	m	struct:taskstate
start	bootasm.S	?^start:$?;"	l
start	bootother.S	?^start:$?;"	l
start	initcode.S	?^start:$?;"	l
start	kalloc.c	?^char * start;  // start address after kernel$?;"	v
start_code	proc.h	?^  vaddr_t start_code;       // Initial address of executable code$?;"	m	struct:proc_vm
start_data	proc.h	?^  vaddr_t start_data;       // Initial address of data$?;"	m	struct:proc_vm
start_probe	bootasm.S	?^start_probe:$?;"	l
start_stack	proc.h	?^  vaddr_t start_stack;      // Initial address of user mode stack$?;"	m	struct:proc_vm
stat	stat.h	?^struct stat {$?;"	s
stat	ulib.c	?^stat(char *n, struct stat *st)$?;"	f
state	proc.h	?^  enum proc_state state;    // Process state$?;"	m	struct:proc	typeref:enum:proc::proc_state
stati	fs.c	?^stati(struct inode *ip, struct stat *st)$?;"	f
static_assert	assert.h	8;"	d
stdout	usertests.c	?^int stdout = 1;$?;"	v
sti	x86.h	?^sti(void)$?;"	f
strchr	ulib.c	?^strchr(const char *s, char c)$?;"	f
strcmp	ulib.c	?^strcmp(const char *p, const char *q)$?;"	f
strcpy	ulib.c	?^strcpy(char *s, char *t)$?;"	f
strlen	string.c	?^strlen(const char *s)$?;"	f
strlen	ulib.c	?^strlen(char *s)$?;"	f
strncmp	string.c	?^strncmp(const char *p, const char *q, uint n)$?;"	f
strncpy	string.c	?^strncpy(char *s, const char *t, int n)$?;"	f
subdir	usertests.c	?^subdir(void)$?;"	f
sum	mp.c	?^sum(uchar *addr, int len)$?;"	f	file:
superblock	fs.h	?^struct superblock {$?;"	s
swtch	swtch.S	?^swtch:$?;"	l
symbols	sh.c	?^char symbols[] = "<|>&;()";$?;"	v
sys_chdir	sysfile.c	?^sys_chdir(void)$?;"	f
sys_close	sysfile.c	?^sys_close(void)$?;"	f
sys_dup	sysfile.c	?^sys_dup(void)$?;"	f
sys_exec	sysfile.c	?^sys_exec(void)$?;"	f
sys_exit	sysproc.c	?^sys_exit(void)$?;"	f
sys_fork	sysproc.c	?^sys_fork(void)$?;"	f
sys_fstat	sysfile.c	?^sys_fstat(void)$?;"	f
sys_getpid	sysproc.c	?^sys_getpid(void)$?;"	f
sys_kill	sysproc.c	?^sys_kill(void)$?;"	f
sys_link	sysfile.c	?^sys_link(void)$?;"	f
sys_mkdir	sysfile.c	?^sys_mkdir(void)$?;"	f
sys_mknod	sysfile.c	?^sys_mknod(void)$?;"	f
sys_open	sysfile.c	?^sys_open(void)$?;"	f
sys_pipe	sysfile.c	?^sys_pipe(void)$?;"	f
sys_read	sysfile.c	?^sys_read(void)$?;"	f
sys_sbrk	sysproc.c	?^sys_sbrk(void)$?;"	f
sys_sleep	sysproc.c	?^sys_sleep(void)$?;"	f
sys_unlink	sysfile.c	?^sys_unlink(void)$?;"	f
sys_wait	sysproc.c	?^sys_wait(void)$?;"	f
sys_write	sysfile.c	?^sys_write(void)$?;"	f
syscall	syscall.c	?^syscall(void)$?;"	f
syscalls	syscall.c	?^static int (*syscalls[])(void) = {$?;"	v	file:
sz	proc.h	?^  uint sz;                  // Size of process memory (bytes)$?;"	m	struct:proc
t	mmu.h	?^  ushort t;          // Trap on task switch$?;"	m	struct:taskstate
taskstate	mmu.h	?^struct taskstate {$?;"	s
test_buddy	buddy.c	?^test_buddy()$?;"	f
tf	proc.h	?^  struct trapframe *tf;     // Trap frame for current interrupt$?;"	m	struct:proc	typeref:struct:proc::trapframe
ticks	trap.c	?^int ticks;$?;"	v
tickslock	trap.c	?^struct spinlock tickslock;$?;"	v	typeref:struct:spinlock
timer_init	timer.c	?^timer_init(void)$?;"	f
togglecode	kbd.h	?^static uchar togglecode[256] =$?;"	v
trap	trap.c	?^trap(struct trapframe *tf)$?;"	f
trapframe	x86.h	?^struct trapframe {$?;"	s
trapno	x86.h	?^  uint trapno;$?;"	m	struct:trapframe
trapret	trapasm.S	?^trapret:$?;"	l
ts	proc.h	?^  struct taskstate ts;        // Used by x86 to find stack for interrupt$?;"	m	struct:cpu	typeref:struct:cpu::taskstate
tvinit	trap.c	?^tvinit(void)$?;"	f
twofiles	usertests.c	?^twofiles(void)$?;"	f
type	elf.h	?^  uint type;$?;"	m	struct:proghdr
type	elf.h	?^  ushort type;$?;"	m	struct:elfhdr
type	file.h	?^  enum { FD_CLOSED, FD_NONE, FD_PIPE, FD_INODE } type;$?;"	m	struct:file	typeref:enum:file::__anon4
type	fs.h	?^  short type;           // File type$?;"	m	struct:dinode
type	fsvar.h	?^  short type;         // copy of disk inode$?;"	m	struct:inode
type	mmu.h	?^  uint type : 4;        // type(STS_{TG,IG32,TG32})$?;"	m	struct:gatedesc
type	mmu.h	?^  uint type : 4;       // Segment type (see STS_ constants)$?;"	m	struct:segdesc
type	mp.h	?^  uchar type;                   // MP system config type$?;"	m	struct:mp
type	mp.h	?^  uchar type;                   // entry type (0)$?;"	m	struct:mpproc
type	mp.h	?^  uchar type;                   // entry type (2)$?;"	m	struct:mpioapic
type	pmap.h	?^		long type;$?;"	m	struct:e820map::__anon2
type	sh.c	?^  int type;$?;"	m	struct:backcmd	file:
type	sh.c	?^  int type;$?;"	m	struct:cmd	file:
type	sh.c	?^  int type;$?;"	m	struct:execcmd	file:
type	sh.c	?^  int type;$?;"	m	struct:listcmd	file:
type	sh.c	?^  int type;$?;"	m	struct:pipecmd	file:
type	sh.c	?^  int type;$?;"	m	struct:redircmd	file:
type	stat.h	?^  short type;  // Type of file$?;"	m	struct:stat
uchar	types.h	?^typedef unsigned char  uchar;$?;"	t
uint	types.h	?^typedef unsigned int   uint;$?;"	t
uint32_t	types.h	?^typedef unsigned int   uint32_t;$?;"	t
unlinkread	usertests.c	?^unlinkread(void)$?;"	f
unmap_userspace	pmap.c	?^unmap_userspace(pde_t * pgdir)$?;"	f
use_console_lock	console.c	?^int use_console_lock = 0;$?;"	v
usedblocks	mkfs.c	?^uint usedblocks;$?;"	v
userinit	proc.c	?^userinit(void)$?;"	f
ushort	types.h	?^typedef unsigned short ushort;$?;"	t
va	elf.h	?^  uint va;$?;"	m	struct:proghdr
vaddr_t	types.h	?^typedef uint vaddr_t;$?;"	t
version	elf.h	?^  uint version;$?;"	m	struct:elfhdr
version	mp.h	?^  uchar version;                // I/O APIC version$?;"	m	struct:mpioapic
version	mp.h	?^  uchar version;                // [14]$?;"	m	struct:mpconf
version	mp.h	?^  uchar version;                // local APIC verison$?;"	m	struct:mpproc
vm	proc.h	?^  struct proc_vm vm;        // Information about the process address space$?;"	m	struct:proc	typeref:struct:proc::proc_vm
w	console.c	?^  uint w;  // Write index$?;"	m	struct:__anon1	file:
wait	proc.c	?^wait(void)$?;"	f
waitdisk	bootmain.c	?^waitdisk(void)$?;"	f
wakeup	proc.c	?^wakeup(void *chan)$?;"	f
wakeup1	proc.c	?^wakeup1(void *chan)$?;"	f	file:
wc	wc.c	?^wc(int fd, char *name)$?;"	f
whitespace	sh.c	?^char whitespace[] = " \\t\\r\\n\\v";$?;"	v
winode	mkfs.c	?^winode(uint inum, struct dinode *ip)$?;"	f
writable	file.h	?^  char writable;$?;"	m	struct:file
write	dev.h	?^  int (*write)(struct inode*, char*, int);$?;"	m	struct:devsw
write_eflags	x86.h	?^write_eflags(uint eflags)$?;"	f
writei	fs.c	?^writei(struct inode *ip, char *src, uint off, uint n)$?;"	f
writeopen	pipe.c	?^  int writeopen;  // write fd is still open$?;"	m	struct:pipe	file:
writep	pipe.c	?^  uint writep;    // next index to write$?;"	m	struct:pipe	file:
writetest	usertests.c	?^writetest(void)$?;"	f
writetest1	usertests.c	?^writetest1(void)$?;"	f
wsect	mkfs.c	?^wsect(uint sec, void *buf)$?;"	f
x	umalloc.c	?^  Align x;$?;"	m	union:header	file:
xchecksum	mp.h	?^  uchar xchecksum;              // extended table checksum$?;"	m	struct:mpconf
xchg	x86.h	?^xchg(volatile uint *addr, uint newval)$?;"	f
xint	mkfs.c	?^xint(uint x)$?;"	f
xlength	mp.h	?^  ushort xlength;               // extended table length$?;"	m	struct:mpconf
xshort	mkfs.c	?^xshort(ushort x)$?;"	f
yield	proc.c	?^yield(void)$?;"	f
zeroes	mkfs.c	?^char zeroes[512];$?;"	v
